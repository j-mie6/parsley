<!DOCTYPE html>
<html lang="en">
  
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Typelevel Laika + Parsley Theme" />
    
    <title>Parsley</title>
    
    
    <meta name="author" content="parsley contributors"/>
    
    
    <meta name="description" content="This page describes the main API of Parsley."/>
    
    
    
    <link rel="icon" sizes="32x32" type="image/svg+xml" href="../../icons/greenLeaf.svg"/>
    
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
    
    <link rel="stylesheet" type="text/css" href="../../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../../css/parsley-style.css" />
    <script src="../../helium/site/laika-helium.js"></script>
    <script src="../../helium/site/laika-versions.js"></script>
    <script>initVersions("../../", "/api-guide/Parsley.html", "4.6", null);</script>
    
    <script> /* for avoiding page load transitions */ </script>
  </head>


  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    <div class="menu-container version-menu">
      <a class="text-link menu-toggle" href="#">Version 4.6.x</a>
      <nav class="menu-content">
        <ul class="nav-list">
        </ul>
      </nav>
    </div>
  </div>

  <a class="icon-link svg-link" href="../../"><span class="leaf" title="Home"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 128 128" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M101.39,86.21c-14.25-5.91-22.34-4.3-28.47-2.5c-6.5,1.91-12.31,8.58-12.31,8.58s-1.93-0.58-5.04-0.51 c-1.49,0.04-2.67,0.28-3.54,0.54c2.64-5.99,4.51-12.08,7.57-18.76c1.95-0.81,4.63-1.86,6.35-2.23c2.96-0.64,6.45-0.84,6.45-0.84 c0.82,0.64,2,1.39,3.69,2.23c9.56,4.78,21.5,2.16,27.35-0.16c8.13-3.23,20.21-12.95,20.21-13.69s-5.5-3.38-13.32-5.71 c-7.82-2.33-18.27-2.44-26.21,0.95c-7.28,3.11-10.67,8.58-12.54,11.86c0,0-2.9,0.46-5,0.82c-1.56,0.27-2.96,0.64-4.07,0.99 c0.22-0.4,0.45-0.81,0.68-1.21C67.77,58.61,72.83,52.5,77,48.2c5.87,0.55,17.89,0.35,27.62-8.46 c15.64-14.15,18.46-35.92,18.07-36.35S97.35,3.34,84.54,14.91c-12.19,11.01-11.97,25.4-11.4,30.69c-3.97,3.71-8.81,9.17-14.2,17.12 c-0.04-2.12-0.29-4.73-0.29-4.73s7.19-6.73,7.72-17.18c0.42-8.24-0.46-15.89-5-24.14c-3.56-6.43-6.53-8.03-7.06-7.93 c-0.93,0.19-5.33,7.06-8.03,13.63c-2.13,5.17-4.26,18.38-0.45,26.52s8.22,9.68,8.22,9.68s0.54,2.37,0.48,5.55 c-0.02,1.36-0.13,4.51-0.18,5.98c-3.57,6.32-5.96,12.07-8.23,17.22c-0.34-0.99-0.73-1.96-1.11-2.65c-1.16-2.11-1.59-2.85-1.59-2.85 s2.57-15.99-1.8-29.17C36.45,37,27.57,31.08,19.33,27.59C11.09,24.1,6.54,24.11,5.8,24.95c-1.08,1.23,1.37,4.33,1.59,11.31 c0.17,5.71,1.16,25.05,6.87,34.98s13.63,12.37,16.17,13.21c2.54,0.85,8.03,0.95,8.03,0.95s2.33,2.01,3.17,4.86 c0.39,1.31,0.78,2.92,1.09,4.27c-1.95,3.71-4.17,7-7.21,9.86c-5.01,4.71-13.09,7.94-13.09,7.94s-6.47-0.15-6.91,0.15 c-0.44,0.29-1.73,3.53,0.69,7.51c2,3.29,5.05,4.12,6.08,4.26c1.03,0.15,2.94-4.27,3.68-4.86c0.74-0.59,9.43-3.93,15.6-10.74 c2.83-3.13,5.02-6.16,6.81-9.17c1.65-1.01,4.07-2.17,6.72-2.31c2.64-0.15,4.94,1.12,4.94,1.12s2.22,9.16,12.15,13 c12.5,4.83,25.83,0.61,31.64-1.4c5.81-2,19.83-8.42,19.94-10.22C123.86,97.87,115.66,92.13,101.39,86.21z"/>
  </g>
</svg></span></a>

  <div class="row links">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.6.0/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.6.0/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../../downloads.html">Documentation Downloads</a></li>
    <li class="level1 nav-leaf"><a href="../../home.html">Home</a></li>
    <li class="level1 nav-leaf"><a href="../faq.html">FAQ</a></li>
    <li class="level1 nav-leaf"><a href="../cheatsheet.html">Cheatsheet</a></li>
    <li class="level1 nav-node"><a href="index.html">Understanding the API</a></li>
    <li class="level2 active nav-leaf"><a href="#"><code>parsley.Parsley</code></a></li>
    <li class="level2 nav-leaf"><a href="character.html"><code>parsley.character</code></a></li>
    <li class="level2 nav-leaf"><a href="combinator.html"><code>parsley.combinator</code></a></li>
    <li class="level2 nav-leaf"><a href="generic.html"><code>parsley.generic</code></a></li>
    <li class="level2 nav-leaf"><a href="syntax.html"><code>parsley.syntax</code></a></li>
    <li class="level2 nav-leaf"><a href="position.html"><code>parsley.position</code></a></li>
    <li class="level2 nav-leaf"><a href="state.html"><code>parsley.state</code></a></li>
    <li class="level2 nav-leaf"><a href="debug.html"><code>parsley.debug</code></a></li>
    <li class="level2 nav-header"><code>parsley.expr</code></li>
    <li class="level3 nav-leaf"><a href="expr/chain.html"><code>chain</code></a></li>
    <li class="level3 nav-leaf"><a href="expr/infix.html"><code>infix</code></a></li>
    <li class="level3 nav-leaf"><a href="expr/precedence.html"><code>precedence</code></a></li>
    <li class="level2 nav-header"><code>parsley.token</code></li>
    <li class="level3 nav-leaf"><a href="token/Lexer.html"><code>Lexer</code></a></li>
    <li class="level3 nav-leaf"><a href="token/descriptions.html"><code>descriptions</code></a></li>
    <li class="level3 nav-leaf"><a href="token/errors.html"><code>errors</code></a></li>
    <li class="level2 nav-header"><code>parsley.errors</code></li>
    <li class="level3 nav-leaf"><a href="errors/combinator.html"><code>combinator</code></a></li>
    <li class="level3 nav-leaf"><a href="errors/patterns.html"><code>patterns</code></a></li>
    <li class="level3 nav-leaf"><a href="errors/ErrorBuilder.html"><code>ErrorBuilder</code></a></li>
    <li class="level3 nav-leaf"><a href="errors/tokenextractors.html"><code>tokenextractors</code></a></li>
    <li class="level1 nav-node"><a href="../tutorial/">Parser Combinator Tutorial</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/basics-of-combinators.html">Basics of Combinators</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/building-expression-parsers.html">Building Expression Parsers</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/effective-whitespace-parsing.html">Effective Whitespace Parsing</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/effective-lexing.html">Effective Lexing</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/parser-bridge-pattern.html">The Parser Bridge Pattern</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/interlude-1-haskell.html">Interlude 1: Building a Parser for Haskell</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/customising-error-messages.html">Customising Error Messages</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/advanced-error-messages.html">Advanced Error Messages</a></li>
    <li class="level1 nav-header">Related Projects</li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/parsley-cats">parsley-cats</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/gigaparsec">gigaparsec (Haskell)</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#"><code>parsley.Parsley</code></a></p>

  <ul class="nav-list">
    <li class="level1 nav-node"><a href="#class-parsley">Class <code>Parsley</code></a></li>
    <li class="level2 nav-leaf"><a href="#running-parsers">Running Parsers</a></li>
    <li class="level2 nav-leaf"><a href="#altering-results">Altering Results</a></li>
    <li class="level2 nav-leaf"><a href="#composing-parsers">Composing Parsers</a></li>
    <li class="level2 nav-leaf"><a href="#filtering-results">Filtering Results</a></li>
    <li class="level2 nav-leaf"><a href="#reductions">Reductions</a></li>
    <li class="level2 nav-leaf"><a href="#special-methods">Special Methods</a></li>
    <li class="level1 nav-node"><a href="#object-parsley">Object <code>Parsley</code></a></li>
    <li class="level2 nav-leaf"><a href="#iterative-combinators">Iterative Combinators</a></li>
  </ul>

  <p class="footer"><a href="https://github.com/j-mie6/parsley/blob/master/docs/api-guide/Parsley.md"><i class="icofont-laika edit" title="Edit">&#xef10;</i>Source for this page</a></p>
</nav>


      <main class="content">

        <h1 id="parsley-parsley-parsley" class="title">Parsley (<code>parsley.Parsley</code>)</h1>
        <p>All parsers have type <code>Parsley</code>, which has many methods (combinators) for composing parsers
        together. The companion object also contains some primitive combinators and parsers.</p>
        <div class="callout info">
          <i class="icofont-laika info">&#xef4e;</i>
          <p><em>The Scaladoc for this page can be found at <a class="api" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.6.0/parsley/Parsley.html"><code>parsley.Parsley</code> (class)</a>
          and <a class="api" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.6.0/parsley/Parsley$.html"><code>parsley.Parsley</code> (object)</a>.</em></p>
        </div>
        
        <h2 id="class-parsley" class="section"><a class="anchor-link left" href="#class-parsley"><i class="icofont-laika link">&#xef71;</i></a>Class <code>Parsley</code></h2>
        <p>The <code>Parsley</code> class is the value class responsible for representing parsers.
        It has methods largely grouped into the following categories:</p>
        <ul>
          <li>Methods to execute a parser, like <code>parse</code>.</li>
          <li>Methods to alter the result of a parser, like <code>map</code>, <code>as</code>, <code>void</code>, and <code>span</code>.</li>
          <li>Methods to sequence multiple parsers, like <code>flatMap</code>, <code>zip</code>, <code>&lt;~</code>, and <code>~&gt;</code>.</li>
          <li>Methods to compose parsers in alternation, like <code>orElse</code>, <code>|</code>, and <code>&lt;+&gt;</code>.</li>
          <li>Methods to filter the results of parsers, like <code>filter</code>, <code>collect</code>,
          and <code>mapFilter</code>.</li>
          <li>Methods to repeat a parser and collapse the results, like <code>foldLeft</code>,
          <code>reduceRight</code>, and so on.</li>
          <li>Special methods to help direct <code>parsley</code>, like <code>impure</code>, <code>overflows</code>, and
          <code>force</code>.</li>
        </ul>
        
        <h3 id="running-parsers" class="section"><a class="anchor-link left" href="#running-parsers"><i class="icofont-laika link">&#xef71;</i></a>Running Parsers</h3>
        <p>The <code>parse</code> method runs a parser with some given input. The type signature has
        an additional <code>Err</code> parameter, with an implicit requirement for
        <code>ErrorBuilder[Err]</code>. This is discussed in
        <a href="errors/ErrorBuilder.html#constructing-custom-errors"><code>parsley.errors.ErrorBuilder</code></a>, but for
        the purposes of basic use, you can assume that Scala will automatically infer
        this type to be <code>String</code>, for which an <code>ErrorBuilder[String]</code> does implicitly
        exist.</p>
        <p>By importing <code>parsley.io._</code>, another <code>parseFromFile</code> method is added to
        <code>Parsley</code>, which works similarly, but loads the input from a file first.
        In future versions of <code>parsley</code>, this import will no longer be needed, and
        this will be an overloading of <code>parse</code>.</p>
        
        <h3 id="altering-results" class="section"><a class="anchor-link left" href="#altering-results"><i class="icofont-laika link">&#xef71;</i></a>Altering Results</h3>
        <p>The results of an individual parser can be altered using <code>map</code> or combinators
        derived from it, such as <code>as</code> or <code>void</code>. Note that the <code>#&gt;</code> combinator is
        a symbolic alias for <code>as</code>, though as is now recommended.</p>
        <div class="callout info">
          <i class="icofont-laika info">&#xef4e;</i>
          <p>Note that, whilst <code>as</code> can be implemented using <code>map</code>, it is
          actually implemented with <code>~&gt;</code> and <code>pure</code>, which allows it to be better
          optimised: if a result is not needed, <code>parsley</code> will ensure it is not
          even generated to begin with.</p>
        </div>
        <p>The <code>span</code> combinator is special: it allows for the result of a parser to be discarded and instead the input consumed in the process of parsing is returned
        instead. This can be used to avoid constructing strings again after parsing.</p>
        
        <h3 id="composing-parsers" class="section"><a class="anchor-link left" href="#composing-parsers"><i class="icofont-laika link">&#xef71;</i></a>Composing Parsers</h3>
        <p>Some combinators allow for multiple parsers to be composed together to form
        a new one. This comes in two forms: sequencing them one after another and
        combining their results in some way, or combining them in parallel as two
        independent choices.</p>
        
        <h4 id="sequencing" class="section"><a class="anchor-link left" href="#sequencing"><i class="icofont-laika link">&#xef71;</i></a>Sequencing</h4>
        <p>The <code>zip</code> combinator is the most permissive way of combining two parsers together
        whilst retaining both of their results; <code>p zip q</code> will parse <code>p</code>, then <code>q</code> and
        then return a pair of their results. The symbolic version of <code>zip</code> is called <code>&lt;~&gt;</code>. When both results are not needed, <code>~&gt;</code> and <code>&lt;~</code> point towards a result to
        keep, and discard the other.</p>
        <p>Combinators like <code>&lt;*&gt;</code>, <code>&lt;**&gt;</code> and <code>&lt;::&gt;</code> perform a similar role to <code>zip</code>, but
        combine the two results depending on the specific subtypes of the arguments.
        Both <code>&lt;*&gt;</code> and <code>&lt;**&gt;</code> perform function application, and <code>&lt;::&gt;</code> adds the result
        of the first parser onto a list returned by the second. These are all more
        specific versions of the <code>parsley.lift._</code> combinators, but are often useful
        in practice.</p>
        <p>The <code>flatMap</code> combinator is another way of sequencing two parsers, but where
        the second depends on the result of the first. In <code>parsley</code>, this operation
        is <strong>very</strong> expensive, and it (and its derived <code>flatten</code> combinator) should
        be avoided. One way of avoiding the <code>flatMap</code> combinator is to use features
        found in <a href="state.html#context-sensitive-parsing-parsley-state"><code>parsley.state</code></a>,
        or to use <code>lift</code> combinators instead.</p>
        
        <h4 id="choice" class="section"><a class="anchor-link left" href="#choice"><i class="icofont-laika link">&#xef71;</i></a>Choice</h4>
        <p>When one of two parsers can be used at a specific point, the <code>|</code> combinator (also
        known as <code>orElse</code> or <code>&lt;|&gt;</code>) can be used to try one and then the other if the
        first failed. The result of the successful branch, if any, will be returned.</p>
        <div class="callout warning">
          <i class="icofont-laika warning">&#xf026;</i>
          <p>A parser <code>p | q</code> will <strong>only</strong> try <code>q</code> if the parser <code>p</code> failed having <strong>not</strong>
          consumed any input. If it does consume input, then the overall parser will fail.
          The <code>atomic</code> combinator can be used to prevent input consumption on failure,
          however.</p>
          <p>When <code>atomic</code> is used in this manner, it may cause error messages to be less
          effective, or increase the runtime or complexity of the parser. Backtracking
          in this way should be avoided if at all possible by factoring the grammar or
          employing techniques like <a href="generic.html#normalising-or-disambiguating-data"><em>Disambiguator Bridges</em></a>.</p>
        </div>
        
        <h3 id="filtering-results" class="section"><a class="anchor-link left" href="#filtering-results"><i class="icofont-laika link">&#xef71;</i></a>Filtering Results</h3>
        <p>When the results of the parser need to be verified or conditionally transformed,
        filtering combinators can be used. Largely, they will try and apply a function
        to the result of a parser: if the function returns <code>false</code> or is otherwise not defined, then the parser will fail, and otherwise, it may perform some
        transformation:</p>
        <ul>
          <li><code>filter</code> will check if the result of a parser matches some predicate, failing
          otherwise. If successful, result is returned unchanged</li>
          <li><code>collect</code> will attempt to apply a partial function to the result of the parser:
          if the function is defined on that input, it is applied and the new result
          returned; otherwise, the parser fails.</li>
          <li><code>filterMap</code> is similar to <code>collect</code>, but works with a function that returns
          <code>Option[B]</code>: if the function returns <code>None</code>, the parser fails; otherwise the
          value inside the <code>Some</code> is returned.</li>
        </ul>
        <p>Largely, these combinators are more useful in their more advanced formulations,
        those in <code>parsley.errors.combinator.ErrorMethods</code>, which produce detailed
        error messages about filtering failures.</p>
        
        <h3 id="reductions" class="section"><a class="anchor-link left" href="#reductions"><i class="icofont-laika link">&#xef71;</i></a>Reductions</h3>
        <p>There are a collection of methods that repeatedly perform a parser, and collapse
        the generated results into a single value - like regular folds. There are three classes of reductive combinators:</p>
        <ul>
          <li><code>foldLeft</code>, <code>foldRight</code>: these combine up the results of repeated parsing
          of a parser starting with an initial value and combining each result with
          the running value. When the name of the combinator has a <code>1</code> at the end, it
          means the parser must succeed at least once; otherwise the parser need not
          succeed and the combinator will return the initial value (so long as no input
          was consumed in the process).</li>
          <li><code>reduceLeft</code>, <code>reduceRight</code>: these combine one or more parses of a parser
          by a left or right reduction. As the parser will parse successfully at least
          once, there is no need for a default or initial value.</li>
          <li><code>reduceLeftOption</code>, <code>reduceRightOption</code>: like <code>reduceLeft</code> or <code>reduceRight</code>,
          but returns <code>None</code> if the parser could not successfully parse once, and wraps
          the result of reduction in a <code>Some</code> otherwise.</li>
        </ul>
        
        <h3 id="special-methods" class="section"><a class="anchor-link left" href="#special-methods"><i class="icofont-laika link">&#xef71;</i></a>Special Methods</h3>
        <p>The underlying implementation of <code>parsley</code> is more akin to a compiler than
        a regular parser combinator library. Some methods exist to help direct the
        internal compiler:</p>
        <ul>
          <li><code>force()</code>: this forces the compiler to optimise and compile the parser
          right now, as opposed to when the parser is first executed. This should be
          used on the top-level parser.</li>
          <li><code>impure</code>: this tells the optimiser to not touch the parser, which may
          be necessary when the parser deals with mutable objects. This is because
          the optimiser assumes purity, and may factor out or even remove results
          entirely, which would otherwise change the results. This can be used
          across the parser.</li>
          <li><code>overflows()</code>: this tells the compiler that the parser it is invoked on
          will stack overflow during compilation. As a result, the compiler will
          instead process the parser in a stack-safe trampoline. This should be
          used on the top-level parser.</li>
        </ul>
        
        <h2 id="object-parsley" class="section"><a class="anchor-link left" href="#object-parsley"><i class="icofont-laika link">&#xef71;</i></a>Object <code>Parsley</code></h2>
        <p>The <code>Parsley</code> object contains a collection of primitive combinators that help
        control a parser or its results. By far the most important ones are <code>pure</code> and
        <code>atomic</code>:</p>
        <ul>
          <li><code>pure</code> injects a value into the parsing world without having any other effect
          on the state of the parser.</li>
          <li><code>atomic</code> ensures that a parser either consumes all its input and succeeds, or
          none of it and fails. This is important because the <code>|</code> combinator will not
          parse its second argument if the first failed having consumed input - <code>atomic</code>
          helps by ensuring no input was consumed on failure.</li>
        </ul>
        <p>In addition to these, it also has <code>empty</code> and <code>empty(Int)</code>, which fail the parser
        immediately (but recoverably) and produces a given width of caret (and <code>0</code> in the case of <code>empty</code>); <code>lookAhead</code> and <code>notFollowedBy</code> for dealing with positive
        and negative lookahead; and <code>fresh</code>, which can be used like <code>pure</code> but evaluates
        its argument every time, which is useful in the presence of mutable values.</p>
        
        <h3 id="iterative-combinators" class="section"><a class="anchor-link left" href="#iterative-combinators"><i class="icofont-laika link">&#xef71;</i></a>Iterative Combinators</h3>
        <p>One of the main classes of combinator are the iterative combinators, which
        execute parsers multiple times until they cannot match any more; the results
        of these combinators vary. If the parser being repeated fails having consumed
        input, iterative combinators will fail; if no input was consumed on failure,
        the iteration will stop.</p>
        <p>The most commonly used of these are the <code>many</code> and <code>some</code> combinators, which
        return a list of the successful results:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">digit</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>.{</span><span class="identifier">many</span><span>, </span><span class="identifier">some</span><span>}

</span><span class="identifier">many</span><span>(</span><span class="identifier">digit</span><span>.</span><span class="identifier">zip</span><span>(</span><span class="identifier">digit</span><span>)).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;&quot;</span><span>)
</span><span class="comment">// res0: parsley.Result[String, List[(Char, Char)]] = Success(List())
</span><span class="identifier">many</span><span>(</span><span class="identifier">digit</span><span>.</span><span class="identifier">zip</span><span>(</span><span class="identifier">digit</span><span>)).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;1234&quot;</span><span>)
</span><span class="comment">// res1: parsley.Result[String, List[(Char, Char)]] = Success(List((1,2), (3,4)))
</span><span class="identifier">many</span><span>(</span><span class="identifier">digit</span><span>.</span><span class="identifier">zip</span><span>(</span><span class="identifier">digit</span><span>)).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;12345&quot;</span><span>)
</span><span class="comment">// res2: parsley.Result[String, List[(Char, Char)]] = Failure((line 1, column 6):
//   unexpected end of input
//   expected digit
//   &gt;12345
//         ^)
</span><span>
</span><span class="identifier">some</span><span>(</span><span class="identifier">digit</span><span>.</span><span class="identifier">zip</span><span>(</span><span class="identifier">digit</span><span>)).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;&quot;</span><span>)
</span><span class="comment">// res3: parsley.Result[String, List[(Char, Char)]] = Failure((line 1, column 1):
//   unexpected end of input
//   expected digit
//   &gt;
//    ^)
</span><span class="identifier">some</span><span>(</span><span class="identifier">digit</span><span>.</span><span class="identifier">zip</span><span>(</span><span class="identifier">digit</span><span>)).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;1234&quot;</span><span>)
</span><span class="comment">// res4: parsley.Result[String, List[(Char, Char)]] = Success(List((1,2), (3,4)))
</span><span class="identifier">some</span><span>(</span><span class="identifier">digit</span><span>.</span><span class="identifier">zip</span><span>(</span><span class="identifier">digit</span><span>)).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;12345&quot;</span><span>)
</span><span class="comment">// res5: parsley.Result[String, List[(Char, Char)]] = Failure((line 1, column 6):
//   unexpected end of input
//   expected digit
//   &gt;12345
//         ^)</span></code></pre>

        
<hr class="footer-rule"/>
<footer>
  Parsley is distributed under the <a href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a> license.
</footer>


      </main>

    </div>

  </body>

</html>