<!DOCTYPE html>
<html lang="en">
  
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Typelevel Laika + Parsley Theme" />
    
    <title>Interlude 1: Building a Parser for Haskell</title>
    
    
    <meta name="author" content="parsley contributors"/>
    
    
    <meta name="description" content="An in-depth look at optimising a parser for a sub-set of Haskell."/>
    
    
    
    <link rel="icon" sizes="32x32" type="image/svg+xml" href="../../icons/greenLeaf.svg"/>
    
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
    
    <link rel="stylesheet" type="text/css" href="../../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../../css/parsley-style.css" />
    <script src="../../helium/site/laika-helium.js"></script>
    <script src="../../helium/site/laika-versions.js"></script>
    <script>initVersions("../../", "/tutorial/interlude-1-haskell.html", "4.6", null);</script>
    
    <script> /* for avoiding page load transitions */ </script>
  </head>


  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    <div class="menu-container version-menu">
      <a class="text-link menu-toggle" href="#">Version 4.6.x</a>
      <nav class="menu-content">
        <ul class="nav-list">
        </ul>
      </nav>
    </div>
  </div>

  <a class="icon-link svg-link" href="../../"><span class="leaf" title="Home"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 128 128" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M101.39,86.21c-14.25-5.91-22.34-4.3-28.47-2.5c-6.5,1.91-12.31,8.58-12.31,8.58s-1.93-0.58-5.04-0.51 c-1.49,0.04-2.67,0.28-3.54,0.54c2.64-5.99,4.51-12.08,7.57-18.76c1.95-0.81,4.63-1.86,6.35-2.23c2.96-0.64,6.45-0.84,6.45-0.84 c0.82,0.64,2,1.39,3.69,2.23c9.56,4.78,21.5,2.16,27.35-0.16c8.13-3.23,20.21-12.95,20.21-13.69s-5.5-3.38-13.32-5.71 c-7.82-2.33-18.27-2.44-26.21,0.95c-7.28,3.11-10.67,8.58-12.54,11.86c0,0-2.9,0.46-5,0.82c-1.56,0.27-2.96,0.64-4.07,0.99 c0.22-0.4,0.45-0.81,0.68-1.21C67.77,58.61,72.83,52.5,77,48.2c5.87,0.55,17.89,0.35,27.62-8.46 c15.64-14.15,18.46-35.92,18.07-36.35S97.35,3.34,84.54,14.91c-12.19,11.01-11.97,25.4-11.4,30.69c-3.97,3.71-8.81,9.17-14.2,17.12 c-0.04-2.12-0.29-4.73-0.29-4.73s7.19-6.73,7.72-17.18c0.42-8.24-0.46-15.89-5-24.14c-3.56-6.43-6.53-8.03-7.06-7.93 c-0.93,0.19-5.33,7.06-8.03,13.63c-2.13,5.17-4.26,18.38-0.45,26.52s8.22,9.68,8.22,9.68s0.54,2.37,0.48,5.55 c-0.02,1.36-0.13,4.51-0.18,5.98c-3.57,6.32-5.96,12.07-8.23,17.22c-0.34-0.99-0.73-1.96-1.11-2.65c-1.16-2.11-1.59-2.85-1.59-2.85 s2.57-15.99-1.8-29.17C36.45,37,27.57,31.08,19.33,27.59C11.09,24.1,6.54,24.11,5.8,24.95c-1.08,1.23,1.37,4.33,1.59,11.31 c0.17,5.71,1.16,25.05,6.87,34.98s13.63,12.37,16.17,13.21c2.54,0.85,8.03,0.95,8.03,0.95s2.33,2.01,3.17,4.86 c0.39,1.31,0.78,2.92,1.09,4.27c-1.95,3.71-4.17,7-7.21,9.86c-5.01,4.71-13.09,7.94-13.09,7.94s-6.47-0.15-6.91,0.15 c-0.44,0.29-1.73,3.53,0.69,7.51c2,3.29,5.05,4.12,6.08,4.26c1.03,0.15,2.94-4.27,3.68-4.86c0.74-0.59,9.43-3.93,15.6-10.74 c2.83-3.13,5.02-6.16,6.81-9.17c1.65-1.01,4.07-2.17,6.72-2.31c2.64-0.15,4.94,1.12,4.94,1.12s2.22,9.16,12.15,13 c12.5,4.83,25.83,0.61,31.64-1.4c5.81-2,19.83-8.42,19.94-10.22C123.86,97.87,115.66,92.13,101.39,86.21z"/>
  </g>
</svg></span></a>

  <div class="row links">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.6.0/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.6.0/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../../downloads.html">Documentation Downloads</a></li>
    <li class="level1 nav-leaf"><a href="../../home.html">Home</a></li>
    <li class="level1 nav-leaf"><a href="../faq.html">FAQ</a></li>
    <li class="level1 nav-leaf"><a href="../cheatsheet.html">Cheatsheet</a></li>
    <li class="level1 nav-node"><a href="../api-guide/">Understanding the API</a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/Parsley.html"><code>parsley.Parsley</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/character.html"><code>parsley.character</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/combinator.html"><code>parsley.combinator</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/generic.html"><code>parsley.generic</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/syntax.html"><code>parsley.syntax</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/position.html"><code>parsley.position</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/state.html"><code>parsley.state</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/debug.html"><code>parsley.debug</code></a></li>
    <li class="level2 nav-header"><code>parsley.expr</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/chain.html"><code>chain</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/infix.html"><code>infix</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/precedence.html"><code>precedence</code></a></li>
    <li class="level2 nav-header"><code>parsley.token</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/Lexer.html"><code>Lexer</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/descriptions.html"><code>descriptions</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/errors.html"><code>errors</code></a></li>
    <li class="level2 nav-header"><code>parsley.errors</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/combinator.html"><code>combinator</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/patterns.html"><code>patterns</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/ErrorBuilder.html"><code>ErrorBuilder</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/tokenextractors.html"><code>tokenextractors</code></a></li>
    <li class="level1 nav-node"><a href="index.html">Parser Combinator Tutorial</a></li>
    <li class="level2 nav-leaf"><a href="basics-of-combinators.html">Basics of Combinators</a></li>
    <li class="level2 nav-leaf"><a href="building-expression-parsers.html">Building Expression Parsers</a></li>
    <li class="level2 nav-leaf"><a href="effective-whitespace-parsing.html">Effective Whitespace Parsing</a></li>
    <li class="level2 nav-leaf"><a href="effective-lexing.html">Effective Lexing</a></li>
    <li class="level2 nav-leaf"><a href="parser-bridge-pattern.html">The Parser Bridge Pattern</a></li>
    <li class="level2 active nav-leaf"><a href="#">Interlude 1: Building a Parser for Haskell</a></li>
    <li class="level2 nav-leaf"><a href="customising-error-messages.html">Customising Error Messages</a></li>
    <li class="level2 nav-leaf"><a href="advanced-error-messages.html">Advanced Error Messages</a></li>
    <li class="level1 nav-header">Related Projects</li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/parsley-cats">parsley-cats</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/gigaparsec">gigaparsec (Haskell)</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#">Interlude 1: Building a Parser for Haskell</a></p>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="#lexing"><span class="section-number">1 </span>Lexing</a></li>
    <li class="level1 nav-leaf"><a href="#the-ast-parser-bridge-pattern"><span class="section-number">2 </span>The AST + <em>Parser Bridge</em> Pattern</a></li>
    <li class="level1 nav-node"><a href="#parsing"><span class="section-number">3 </span>Parsing</a></li>
    <li class="level2 nav-leaf"><a href="#atoms-of-the-expression"><span class="section-number">3.1 </span>Atoms of the Expression</a></li>
    <li class="level2 nav-leaf"><a href="#expressions"><span class="section-number">3.2 </span>Expressions</a></li>
    <li class="level2 nav-leaf"><a href="#clauses"><span class="section-number">3.3 </span>Clauses</a></li>
    <li class="level2 nav-leaf"><a href="#types"><span class="section-number">3.4 </span>Types</a></li>
    <li class="level2 nav-leaf"><a href="#declarations-and-data"><span class="section-number">3.5 </span>Declarations and Data</a></li>
    <li class="level1 nav-node"><a href="#optimising-the-parser"><span class="section-number">4 </span>Optimising the Parser</a></li>
    <li class="level2 nav-leaf"><a href="#fixing-parentheses-backtracking"><span class="section-number">4.1 </span>Fixing Parentheses Backtracking</a></li>
    <li class="level1 nav-leaf"><a href="#concluding-thoughts"><span class="section-number">5 </span>Concluding Thoughts</a></li>
  </ul>

  <p class="footer"><a href="https://github.com/j-mie6/parsley/blob/master/docs/tutorial/interlude-1-haskell.md"><i class="icofont-laika edit" title="Edit">&#xef10;</i>Source for this page</a></p>
</nav>


      <main class="content">

        <h1 id="interlude-1-building-a-parser-for-haskell" class="title">Interlude 1: Building a Parser for Haskell</h1>
        <p>We&#39;ve covered a lot of ground in the series so far! I think it&#39;s time to take a medium-length
        break and implement a parser for a (somewhat) simplified Haskell from scratch. Haskell is a
        deceptively simple looking language, but is actually a minefield of ambiguous parses and the
        whitespace sensitivity in the language makes it even trickier. For now, I&#39;m going to make a
        couple of simplifications: firstly, I&#39;m disallowing multi-line <em>anything</em>. We are going to make
        a <code>\n</code> a significant character and not include it in the whitespace parsing (at least until
        part 3!). Furthermore, I&#39;m banning <code>where</code> clauses, more than one definition in a <code>let</code>, guards
        on a new line, and <code>case</code> statements <em>must</em> use <code>{}</code> (these are optional in Haskell, so long as
        the code is well-indented). I&#39;m also not going to deal with user defined operators, because the
        introduction of these during the parser does create a context-sensitive grammar, which I&#39;d
        prefer to avoid for now. With that being said, here&#39;s the grammar. I wouldn&#39;t recommend spending
        too much time looking at the grammar, and instead we&#39;ll get started with the fairly easy task of
        lexing.</p>
        <pre><code class="nohighlight"><span>&lt;</span><span class="identifier">program</span><span>&gt; ::= ((&lt;</span><span class="identifier">data</span><span>&gt; | &lt;</span><span class="identifier">declaration</span><span>&gt; | &lt;</span><span class="identifier">clause</span><span>&gt;) </span><span class="identifier">NEWLINE</span><span>)*

&lt;</span><span class="identifier">data</span><span>&gt;         ::= </span><span class="string-literal">&#39;data&#39;</span><span> &lt;</span><span class="identifier">con</span><span>-</span><span class="identifier">id</span><span>&gt; &lt;</span><span class="identifier">var</span><span>-</span><span class="identifier">id</span><span>&gt;* </span><span class="string-literal">&#39;=&#39;</span><span> &lt;</span><span class="identifier">constructors</span><span>&gt;
&lt;</span><span class="identifier">constructors</span><span>&gt; ::= &lt;</span><span class="identifier">constructor</span><span>&gt; [</span><span class="string-literal">&#39;|&#39;</span><span> &lt;</span><span class="identifier">constructors</span><span>&gt;]
&lt;</span><span class="identifier">constructor</span><span>&gt;  ::= &lt;</span><span class="identifier">con</span><span>-</span><span class="identifier">id</span><span>&gt; &lt;</span><span class="identifier">type</span><span>-</span><span class="identifier">atom</span><span>&gt;*

&lt;</span><span class="identifier">declaration</span><span>&gt; ::= &lt;</span><span class="identifier">var</span><span>-</span><span class="identifier">id</span><span>&gt; </span><span class="string-literal">&#39;::&#39;</span><span> &lt;</span><span class="identifier">type</span><span>&gt;

&lt;</span><span class="identifier">clause</span><span>&gt;     ::= &lt;</span><span class="identifier">var</span><span>-</span><span class="identifier">id</span><span>&gt; &lt;</span><span class="identifier">pat</span><span>-</span><span class="identifier">naked</span><span>&gt;* [&lt;</span><span class="identifier">guard</span><span>&gt;] </span><span class="string-literal">&#39;=&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt;
&lt;</span><span class="identifier">pat</span><span>-</span><span class="identifier">naked</span><span>&gt;  ::= &lt;</span><span class="identifier">var</span><span>-</span><span class="identifier">id</span><span>&gt; | &lt;</span><span class="identifier">pat</span><span>-</span><span class="identifier">con</span><span>&gt; | </span><span class="string-literal">&#39;()&#39;</span><span> | </span><span class="string-literal">&#39;[]&#39;</span><span> | &lt;</span><span class="identifier">literal</span><span>&gt; | </span><span class="string-literal">&#39;_&#39;</span><span>
               | </span><span class="string-literal">&#39;(&#39;</span><span> &lt;</span><span class="identifier">pat</span><span>&gt; </span><span class="string-literal">&#39;)&#39;</span><span>
               | </span><span class="string-literal">&#39;(&#39;</span><span> &lt;</span><span class="identifier">pat</span><span>&gt; [</span><span class="string-literal">&#39;,&#39;</span><span> &lt;</span><span class="identifier">pat</span><span>&gt;]+ </span><span class="string-literal">&#39;)&#39;</span><span>
               | </span><span class="string-literal">&#39;[&#39;</span><span> &lt;</span><span class="identifier">pat</span><span>&gt; [</span><span class="string-literal">&#39;,&#39;</span><span> &lt;</span><span class="identifier">pat</span><span>&gt;]* </span><span class="string-literal">&#39;]&#39;</span><span>
&lt;</span><span class="identifier">pat</span><span>&gt;        ::= &lt;</span><span class="identifier">pat</span><span>-</span><span class="identifier">paren</span><span>&gt; [</span><span class="string-literal">&#39;:&#39;</span><span> &lt;</span><span class="identifier">pat</span><span>&gt;]
&lt;</span><span class="identifier">pat</span><span>-</span><span class="identifier">paren</span><span>&gt;  ::= &lt;</span><span class="identifier">pat</span><span>-</span><span class="identifier">app</span><span>&gt; | &lt;</span><span class="identifier">pat</span><span>-</span><span class="identifier">naked</span><span>&gt;
&lt;</span><span class="identifier">pat</span><span>-</span><span class="identifier">app</span><span>&gt;    ::= &lt;</span><span class="identifier">pat</span><span>-</span><span class="identifier">con</span><span>&gt; &lt;</span><span class="identifier">pat</span><span>&gt;+
&lt;</span><span class="identifier">pat</span><span>-</span><span class="identifier">con</span><span>&gt;    ::= </span><span class="string-literal">&#39;(&#39;</span><span> </span><span class="string-literal">&#39;,&#39;</span><span>+ </span><span class="string-literal">&#39;)&#39;</span><span> | &lt;</span><span class="identifier">con</span><span>-</span><span class="identifier">id</span><span>&gt; | </span><span class="string-literal">&#39;(&#39;</span><span> </span><span class="string-literal">&#39;:&#39;</span><span> </span><span class="string-literal">&#39;)&#39;</span><span>

&lt;</span><span class="identifier">guard</span><span>&gt;     ::= </span><span class="string-literal">&#39;|&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt;

&lt;</span><span class="identifier">type</span><span>&gt;      ::= &lt;</span><span class="identifier">type</span><span>-</span><span class="identifier">app</span><span>&gt; [</span><span class="string-literal">&#39;-&gt;&#39;</span><span> &lt;</span><span class="identifier">type</span><span>&gt;]
&lt;</span><span class="identifier">type</span><span>-</span><span class="identifier">app</span><span>&gt;  ::= &lt;</span><span class="identifier">type</span><span>-</span><span class="identifier">atom</span><span>&gt;+
&lt;</span><span class="identifier">type</span><span>-</span><span class="identifier">atom</span><span>&gt; ::= &lt;</span><span class="identifier">type</span><span>-</span><span class="identifier">con</span><span>&gt; | &lt;</span><span class="identifier">var</span><span>-</span><span class="identifier">id</span><span>&gt; | </span><span class="string-literal">&#39;()&#39;</span><span>  | </span><span class="string-literal">&#39;[&#39;</span><span> &lt;</span><span class="identifier">type</span><span>&gt; </span><span class="string-literal">&#39;]&#39;</span><span>
              | </span><span class="string-literal">&#39;(&#39;</span><span> &lt;</span><span class="identifier">type</span><span>&gt; (</span><span class="string-literal">&#39;,&#39;</span><span> &lt;</span><span class="identifier">type</span><span>&gt; </span><span class="string-literal">&#39;)&#39;</span><span>)+ | </span><span class="string-literal">&#39;(&#39;</span><span> &lt;</span><span class="identifier">type</span><span>&gt; </span><span class="string-literal">&#39;)&#39;</span><span>
&lt;</span><span class="identifier">type</span><span>-</span><span class="identifier">con</span><span>&gt;  ::= &lt;</span><span class="identifier">con</span><span>-</span><span class="identifier">id</span><span>&gt; | </span><span class="string-literal">&#39;[]&#39;</span><span> | </span><span class="string-literal">&#39;(&#39;</span><span> </span><span class="string-literal">&#39;-&gt;&#39;</span><span> </span><span class="string-literal">&#39;)&#39;</span><span> | </span><span class="string-literal">&#39;(&#39;</span><span> </span><span class="string-literal">&#39;,&#39;</span><span>+ </span><span class="string-literal">&#39;)&#39;</span><span>

&lt;</span><span class="identifier">expr</span><span>&gt;    ::= [&lt;</span><span class="identifier">expr</span><span>&gt; </span><span class="string-literal">&#39;$&#39;</span><span>] &lt;</span><span class="identifier">expr</span><span>-1&gt;
&lt;</span><span class="identifier">expr</span><span>-1&gt;  ::= &lt;</span><span class="identifier">expr</span><span>-2&gt; [</span><span class="string-literal">&#39;||&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>-1&gt;]
&lt;</span><span class="identifier">expr</span><span>-2&gt;  ::= &lt;</span><span class="identifier">expr</span><span>-3&gt; [</span><span class="string-literal">&#39;&amp;&amp;&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>-2&gt;]
&lt;</span><span class="identifier">expr</span><span>-3&gt;  ::= &lt;</span><span class="identifier">expr</span><span>-4&gt; [(</span><span class="string-literal">&#39;&lt;&#39;</span><span> | </span><span class="string-literal">&#39;&lt;=&#39;</span><span> | </span><span class="string-literal">&#39;&gt;&#39;</span><span> | </span><span class="string-literal">&#39;&gt;=&#39;</span><span> | </span><span class="string-literal">&#39;==&#39;</span><span> | </span><span class="string-literal">&#39;/=&#39;</span><span>) &lt;</span><span class="identifier">expr</span><span>-4&gt;]
&lt;</span><span class="identifier">expr</span><span>-4&gt;  ::= &lt;</span><span class="identifier">expr</span><span>-5&gt; [(</span><span class="string-literal">&#39;:&#39;</span><span> | </span><span class="string-literal">&#39;++&#39;</span><span>) &lt;</span><span class="identifier">expr</span><span>-4&gt;]
&lt;</span><span class="identifier">expr</span><span>-5&gt;  ::= [&lt;</span><span class="identifier">expr</span><span>-5&gt; (</span><span class="string-literal">&#39;+&#39;</span><span> | </span><span class="string-literal">&#39;-&#39;</span><span>)] &lt;</span><span class="identifier">expr</span><span>-6&gt;
&lt;</span><span class="identifier">expr</span><span>-6&gt;  ::= </span><span class="string-literal">&#39;-&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>-6&gt; | &lt;</span><span class="identifier">expr</span><span>-7&gt;
&lt;</span><span class="identifier">expr</span><span>-7&gt;  ::= [&lt;</span><span class="identifier">expr</span><span>-7&gt; (</span><span class="string-literal">&#39;*&#39;</span><span> | </span><span class="string-literal">&#39;/&#39;</span><span>)] &lt;</span><span class="identifier">expr</span><span>-8&gt;
&lt;</span><span class="identifier">expr</span><span>-8&gt;  ::= &lt;</span><span class="identifier">expr</span><span>-9&gt; [</span><span class="string-literal">&#39;^&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>-8&gt;]
&lt;</span><span class="identifier">expr</span><span>-9&gt;  ::= &lt;</span><span class="identifier">expr</span><span>-10&gt; [</span><span class="string-literal">&#39;.&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>-9&gt;]
&lt;</span><span class="identifier">expr</span><span>-10&gt; ::= </span><span class="string-literal">&#39;\&#39;</span><span> &lt;</span><span class="identifier">pat</span><span>-</span><span class="identifier">naked</span><span>&gt;+ </span><span class="string-literal">&#39;-&gt;&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt;
            | </span><span class="string-literal">&#39;let&#39;</span><span> &lt;</span><span class="identifier">clause</span><span>&gt; </span><span class="string-literal">&#39;in&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt;
            | </span><span class="string-literal">&#39;if&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt; </span><span class="string-literal">&#39;then&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt; </span><span class="string-literal">&#39;else&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt;
            | </span><span class="string-literal">&#39;case&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt; </span><span class="string-literal">&#39;of&#39;</span><span> </span><span class="string-literal">&#39;{&#39;</span><span> &lt;</span><span class="identifier">alt</span><span>&gt; [(</span><span class="string-literal">&#39;;&#39;</span><span>|</span><span class="identifier">NEWLINE</span><span>) &lt;</span><span class="identifier">alt</span><span>&gt;]* </span><span class="string-literal">&#39;}&#39;</span><span>
            | &lt;</span><span class="identifier">func</span><span>-</span><span class="identifier">app</span><span>&gt;
&lt;</span><span class="identifier">alt</span><span>&gt; ::= &lt;</span><span class="identifier">pat</span><span>&gt; </span><span class="string-literal">&#39;-&gt;&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt;
&lt;</span><span class="identifier">func</span><span>-</span><span class="identifier">app</span><span>&gt; ::= &lt;</span><span class="identifier">term</span><span>&gt;+
&lt;</span><span class="identifier">term</span><span>&gt; ::= &lt;</span><span class="identifier">var</span><span>-</span><span class="identifier">id</span><span>&gt; | &lt;</span><span class="identifier">con</span><span>-</span><span class="identifier">id</span><span>&gt; | </span><span class="string-literal">&#39;()&#39;</span><span> | </span><span class="string-literal">&#39;(&#39;</span><span> </span><span class="string-literal">&#39;,&#39;</span><span>+ </span><span class="string-literal">&#39;)&#39;</span><span>
         | </span><span class="string-literal">&#39;(&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt; </span><span class="string-literal">&#39;)&#39;</span><span>
         | </span><span class="string-literal">&#39;(&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt; (</span><span class="string-literal">&#39;,&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt;)+) </span><span class="string-literal">&#39;)&#39;</span><span>
         | </span><span class="string-literal">&#39;[&#39;</span><span> [&lt;</span><span class="identifier">expr</span><span>&gt; (</span><span class="string-literal">&#39;,&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt;)*] </span><span class="string-literal">&#39;]&#39;</span><span>
         | &lt;</span><span class="identifier">literal</span><span>&gt;
&lt;</span><span class="identifier">literal</span><span>&gt; ::= </span><span class="identifier">FLOAT</span><span> | </span><span class="identifier">INTEGER</span><span> | </span><span class="identifier">STRING</span><span> | </span><span class="identifier">CHAR</span><span>
&lt;</span><span class="identifier">var</span><span>-</span><span class="identifier">id</span><span>&gt; ::= </span><span class="identifier">VAR</span><span>-</span><span class="identifier">ID</span><span>
&lt;</span><span class="identifier">con</span><span>-</span><span class="identifier">id</span><span>&gt; ::= </span><span class="identifier">CON</span><span>-</span><span class="identifier">ID</span></code></pre>
        
        <h2 id="lexing" class="section"><a class="anchor-link left" href="#lexing"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">1 </span>Lexing</h2>
        <p>As it turns out, lexing Haskell in Parsley is particularly easy: the <code>Lexer</code> class is compliant
        with the Haskell specification!</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>

</span><span class="keyword">object</span><span> </span><span class="identifier">lexer</span><span> {
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">token</span><span>.</span><span class="type-name">Lexer</span><span>
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">token</span><span>.</span><span class="identifier">descriptions</span><span>.{</span><span class="type-name">LexicalDesc</span><span>, </span><span class="type-name">NameDesc</span><span>, </span><span class="type-name">SymbolDesc</span><span>, </span><span class="type-name">SpaceDesc</span><span>,
                                       </span><span class="identifier">numeric</span><span>, </span><span class="identifier">text</span><span>}
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">token</span><span>.</span><span class="identifier">predicate</span><span>.{</span><span class="type-name">Unicode</span><span>, </span><span class="type-name">Basic</span><span>}
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">newline</span><span>
    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">haskellDesc</span><span> = </span><span class="type-name">LexicalDesc</span><span>(
        </span><span class="type-name">NameDesc</span><span>.</span><span class="identifier">plain</span><span>.</span><span class="identifier">copy</span><span>(
            </span><span class="identifier">identifierStart</span><span> = </span><span class="type-name">Unicode</span><span>(</span><span class="identifier">c</span><span> =&gt; </span><span class="type-name">Character</span><span>.</span><span class="identifier">isLetter</span><span>(</span><span class="identifier">c</span><span>) || </span><span class="identifier">c</span><span> == </span><span class="char-literal">&#39;_&#39;</span><span>),
            </span><span class="identifier">identifierLetter</span><span> =
                </span><span class="type-name">Unicode</span><span>(</span><span class="identifier">c</span><span> =&gt; </span><span class="type-name">Character</span><span>.</span><span class="identifier">isLetterOrDigit</span><span>(</span><span class="identifier">c</span><span>) || </span><span class="identifier">c</span><span> == </span><span class="char-literal">&#39;_&#39;</span><span> || </span><span class="identifier">c</span><span> == </span><span class="char-literal">&#39;</span><span class="escape-sequence">\&#39;</span><span class="char-literal">&#39;</span><span>),
        ),
        </span><span class="type-name">SymbolDesc</span><span>.</span><span class="identifier">plain</span><span>.</span><span class="identifier">copy</span><span>(
            </span><span class="identifier">hardKeywords</span><span> = </span><span class="type-name">Set</span><span>(</span><span class="string-literal">&quot;if&quot;</span><span>, </span><span class="string-literal">&quot;then&quot;</span><span>, </span><span class="string-literal">&quot;else&quot;</span><span>, </span><span class="string-literal">&quot;data&quot;</span><span>, </span><span class="string-literal">&quot;where&quot;</span><span>,
                                </span><span class="string-literal">&quot;let&quot;</span><span>, </span><span class="string-literal">&quot;in&quot;</span><span>, </span><span class="string-literal">&quot;case&quot;</span><span>, </span><span class="string-literal">&quot;of&quot;</span><span>),
            </span><span class="identifier">hardOperators</span><span> = </span><span class="type-name">Set</span><span>(</span><span class="string-literal">&quot;$&quot;</span><span>, </span><span class="string-literal">&quot;||&quot;</span><span>, </span><span class="string-literal">&quot;&amp;&amp;&quot;</span><span>, </span><span class="string-literal">&quot;&lt;&quot;</span><span>, </span><span class="string-literal">&quot;&lt;=&quot;</span><span>, </span><span class="string-literal">&quot;&gt;&quot;</span><span>, </span><span class="string-literal">&quot;&gt;=&quot;</span><span>, </span><span class="string-literal">&quot;==&quot;</span><span>, </span><span class="string-literal">&quot;/=&quot;</span><span>, </span><span class="string-literal">&quot;:&quot;</span><span>,
                                </span><span class="string-literal">&quot;++&quot;</span><span>, </span><span class="string-literal">&quot;+&quot;</span><span>, </span><span class="string-literal">&quot;-&quot;</span><span>, </span><span class="string-literal">&quot;*&quot;</span><span>, </span><span class="string-literal">&quot;/&quot;</span><span>, </span><span class="string-literal">&quot;^&quot;</span><span>, </span><span class="string-literal">&quot;.&quot;</span><span>),
        ),
        </span><span class="identifier">numeric</span><span>.</span><span class="type-name">NumericDesc</span><span>.</span><span class="identifier">plain</span><span>.</span><span class="identifier">copy</span><span>(
            </span><span class="identifier">octalExponentDesc</span><span> = </span><span class="identifier">numeric</span><span>.</span><span class="type-name">ExponentDesc</span><span>.</span><span class="type-name">NoExponents</span><span>,
            </span><span class="identifier">binaryExponentDesc</span><span> = </span><span class="identifier">numeric</span><span>.</span><span class="type-name">ExponentDesc</span><span>.</span><span class="type-name">NoExponents</span><span>,
        ),
        </span><span class="identifier">text</span><span>.</span><span class="type-name">TextDesc</span><span>.</span><span class="identifier">plain</span><span>.</span><span class="identifier">copy</span><span>(
            </span><span class="identifier">escapeSequences</span><span> = </span><span class="identifier">text</span><span>.</span><span class="type-name">EscapeDesc</span><span>.</span><span class="identifier">haskell</span><span>,
        ),
        </span><span class="type-name">SpaceDesc</span><span>.</span><span class="identifier">plain</span><span>.</span><span class="identifier">copy</span><span>(
            </span><span class="identifier">commentStart</span><span> = </span><span class="string-literal">&quot;{-&quot;</span><span>,
            </span><span class="identifier">commentEnd</span><span> = </span><span class="string-literal">&quot;-}&quot;</span><span>,
            </span><span class="identifier">commentLine</span><span> = </span><span class="string-literal">&quot;--&quot;</span><span>,
            </span><span class="identifier">nestedComments</span><span> = </span><span class="boolean-literal">true</span><span>,
            </span><span class="identifier">space</span><span> = </span><span class="type-name">Basic</span><span>(</span><span class="identifier">c</span><span> =&gt; </span><span class="identifier">c</span><span> == </span><span class="char-literal">&#39; &#39;</span><span> || </span><span class="identifier">c</span><span> == </span><span class="char-literal">&#39;</span><span class="escape-sequence">\t</span><span class="char-literal">&#39;</span><span>),
        )
    )

    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">lexer</span><span> = </span><span class="keyword">new</span><span> </span><span class="type-name">Lexer</span><span>(</span><span class="identifier">haskellDesc</span><span>)

    </span><span class="keyword">val</span><span> </span><span class="type-name">CON_ID</span><span> = </span><span class="identifier">lexer</span><span>.</span><span class="identifier">lexeme</span><span>.</span><span class="identifier">names</span><span>.</span><span class="identifier">identifier</span><span>(</span><span class="type-name">Basic</span><span>(</span><span class="identifier">_</span><span>.</span><span class="identifier">isUpper</span><span>))
    </span><span class="keyword">val</span><span> </span><span class="type-name">VAR_ID</span><span> = </span><span class="identifier">lexer</span><span>.</span><span class="identifier">lexeme</span><span>.</span><span class="identifier">names</span><span>.</span><span class="identifier">identifier</span><span>(</span><span class="type-name">Basic</span><span>(</span><span class="identifier">_</span><span>.</span><span class="identifier">isLower</span><span>))
    </span><span class="keyword">val</span><span> </span><span class="type-name">INTEGER</span><span> = </span><span class="identifier">lexer</span><span>.</span><span class="identifier">lexeme</span><span>.</span><span class="identifier">natural</span><span>.</span><span class="identifier">number</span><span>
    </span><span class="keyword">val</span><span> </span><span class="type-name">FLOAT</span><span> = </span><span class="identifier">lexer</span><span>.</span><span class="identifier">lexeme</span><span>.</span><span class="identifier">floating</span><span>.</span><span class="identifier">number</span><span>
    </span><span class="keyword">val</span><span> </span><span class="type-name">INT_OR_FLOAT</span><span> = </span><span class="identifier">lexer</span><span>.</span><span class="identifier">lexeme</span><span>.</span><span class="identifier">unsignedCombined</span><span>.</span><span class="identifier">number</span><span>
    </span><span class="comment">// Strictly speaking, Haskell files are probably encoded as UTF-8, but this
</span><span>    </span><span class="comment">// is not supported by Parsley _yet_
</span><span>    </span><span class="keyword">val</span><span> </span><span class="type-name">STRING</span><span> = </span><span class="identifier">lexer</span><span>.</span><span class="identifier">lexeme</span><span>.</span><span class="identifier">string</span><span>.</span><span class="identifier">fullUtf16</span><span>
    </span><span class="keyword">val</span><span> </span><span class="type-name">CHAR</span><span> = </span><span class="identifier">lexer</span><span>.</span><span class="identifier">lexeme</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">fullUtf16</span><span>

    </span><span class="keyword">val</span><span> </span><span class="type-name">NEWLINE</span><span> = </span><span class="identifier">lexer</span><span>.</span><span class="identifier">lexeme</span><span>(</span><span class="identifier">newline</span><span>).</span><span class="identifier">void</span><span>

    </span><span class="keyword">def</span><span> </span><span class="declaration-name">fully</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">p</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]) = </span><span class="identifier">lexer</span><span>.</span><span class="identifier">fully</span><span>(</span><span class="identifier">p</span><span>)

    </span><span class="keyword">val</span><span> </span><span class="identifier">implicits</span><span> = </span><span class="identifier">lexer</span><span>.</span><span class="identifier">lexeme</span><span>.</span><span class="identifier">symbol</span><span>.</span><span class="identifier">implicits</span><span>
}</span></code></pre>
        <p>The only tricky bit here is identifiers. Ideally, we can make a distinction between so-called
        constructor ids and variable ids: this is done by using the <code>identifier</code> combinator, which
        refines what the first letter of the identifier is allowed to be. I&#39;ve exposed <code>INT_OR_FLOAT</code> to our interface here, since it prevents any backtracking required by <code>INTEGER | FLOAT</code>. Also seen here, is the <code>NEWLINE</code> token, which we will use in the parser to deliberate delimit newlines, but still
        ensure it consumes whitespace! The reason I have picked the shouty-case names is to mimic how tokens sometimes look in grammars. This is purely stylistic, but will help us distinguish between parts of our parser and the primitives of our lexer.</p>
        
        <h2 id="the-ast-parser-bridge-pattern" class="section"><a class="anchor-link left" href="#the-ast-parser-bridge-pattern"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">2 </span>The AST + <em>Parser Bridge</em> Pattern</h2>
        <p>Now it&#39;s time to build the AST for our Haskell Parser to return. Since we&#39;ll be using the
        <em>Parser Bridge</em> pattern anyway, I get a choice about whether or not I want position tracking for each
        node in the tree. Just to keep the AST looking simple, I&#39;ll not track anything. Of course, if I
        did change my mind, I could do it here by changing which generic bridge trait is used. More
        interesting will be what bridge constructor shapes I pick for each of the AST nodes. Let&#39;s start by
        just outlining the datatypes themselves and why they are how they are:</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="identifier">ast</span><span> {
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">generic</span><span>.</span><span class="identifier">_</span><span>

    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">HaskellProgram</span><span>(</span><span class="identifier">lines</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">ProgramUnit</span><span>])
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">ProgramUnit</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Data</span><span>(</span><span class="identifier">id</span><span>: </span><span class="type-name">ConId</span><span>, </span><span class="identifier">tys</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">VarId</span><span>], </span><span class="identifier">cons</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Con</span><span>]) </span><span class="keyword">extends</span><span> </span><span class="type-name">ProgramUnit</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Con</span><span>(</span><span class="identifier">id</span><span>: </span><span class="type-name">ConId</span><span>, </span><span class="identifier">tys</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">TyAtom</span><span>])

    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Decl</span><span>(</span><span class="identifier">id</span><span>: </span><span class="type-name">VarId</span><span>, </span><span class="identifier">ty</span><span>: </span><span class="type-name">Type</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">ProgramUnit</span><span>

    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Clause</span><span>(</span><span class="identifier">id</span><span>: </span><span class="type-name">VarId</span><span>, </span><span class="identifier">pats</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">PatNaked</span><span>], </span><span class="identifier">guard</span><span>: </span><span class="type-name">Option</span><span>[</span><span class="type-name">Expr</span><span>], </span><span class="identifier">rhs</span><span>: </span><span class="type-name">Expr</span><span>)
        </span><span class="keyword">extends</span><span> </span><span class="type-name">ProgramUnit</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Pat</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">PatCons</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">PatParen</span><span>, </span><span class="identifier">xs</span><span>: </span><span class="type-name">Pat</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Pat</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">PatParen</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Pat</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">PatApp</span><span>(</span><span class="identifier">con</span><span>: </span><span class="type-name">PatCon</span><span>, </span><span class="identifier">args</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">PatNaked</span><span>]) </span><span class="keyword">extends</span><span> </span><span class="type-name">PatParen</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">PatNaked</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">PatParen</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">object</span><span> </span><span class="type-name">NilCon</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">PatNaked</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">ParserBridge0</span><span>[</span><span class="type-name">PatNaked</span><span>]
    </span><span class="keyword">case</span><span> </span><span class="keyword">object</span><span> </span><span class="type-name">Wild</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">PatNaked</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">ParserBridge0</span><span>[</span><span class="type-name">PatNaked</span><span>]
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">NestedPat</span><span>(</span><span class="identifier">pat</span><span>: </span><span class="type-name">Pat</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">PatNaked</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">PatTuple</span><span>(</span><span class="identifier">xs</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Pat</span><span>]) </span><span class="keyword">extends</span><span> </span><span class="type-name">PatNaked</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">PatList</span><span>(</span><span class="identifier">xs</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Pat</span><span>]) </span><span class="keyword">extends</span><span> </span><span class="type-name">PatNaked</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">PatCon</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">PatNaked</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">object</span><span> </span><span class="type-name">ConsCon</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">PatCon</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">ParserBridge0</span><span>[</span><span class="type-name">PatCon</span><span>]

    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Type</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">FunTy</span><span>(</span><span class="identifier">argTy</span><span>: </span><span class="type-name">Type_</span><span>, </span><span class="identifier">resTy</span><span>: </span><span class="type-name">Type</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Type</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Type_</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Type</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">TyApp</span><span>(</span><span class="identifier">tyF</span><span>: </span><span class="type-name">Type_</span><span>, </span><span class="identifier">tyX</span><span>: </span><span class="type-name">TyAtom</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Type_</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">TyAtom</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Type_</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">object</span><span> </span><span class="type-name">UnitTy</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">TyAtom</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">ParserBridge0</span><span>[</span><span class="type-name">TyAtom</span><span>]
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">ListTy</span><span>(</span><span class="identifier">ty</span><span>: </span><span class="type-name">Type</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">TyAtom</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">TupleTy</span><span>(</span><span class="identifier">tys</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Type</span><span>]) </span><span class="keyword">extends</span><span> </span><span class="type-name">TyAtom</span><span>
    </span><span class="comment">// This is needed if we want to maximise the well-typedness of the parser
</span><span>    </span><span class="comment">// For a parser as big as this one, it&#39;s definitely desirable: we can always
</span><span>    </span><span class="comment">// weaken the types later if we want to!
</span><span>    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">ParenTy</span><span>(</span><span class="identifier">ty</span><span>: </span><span class="type-name">Type</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">TyAtom</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">object</span><span> </span><span class="type-name">ListConTy</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">TyAtom</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">ParserBridge0</span><span>[</span><span class="type-name">TyAtom</span><span>]
    </span><span class="keyword">case</span><span> </span><span class="keyword">object</span><span> </span><span class="type-name">FunConTy</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">TyAtom</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">ParserBridge0</span><span>[</span><span class="type-name">TyAtom</span><span>]
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">TupleConTy</span><span>(</span><span class="identifier">arity</span><span>: </span><span class="type-name">Int</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">TyAtom</span><span>

    </span><span class="comment">// We&#39;ll model this layer by layer, to maximise the flexiblity whilst maintaining
</span><span>    </span><span class="comment">// The type safety: by using subtyping, we can avoid useless wrapper constructors
</span><span>    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">WeakApp</span><span>(</span><span class="identifier">f</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">arg</span><span>: </span><span class="type-name">Expr1</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr1</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Or</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr2</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr1</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr1</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr2</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr1</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">And</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr3</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr2</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr2</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr3</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr2</span><span>
    </span><span class="comment">// We could certainly compress this by factoring out the op!
</span><span>    </span><span class="comment">// Notice that these operators have Expr4 on both sides: this implies they are
</span><span>    </span><span class="comment">// not left _or_ right associative! x &lt; y &lt; z is not legal in Haskell
</span><span>    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Less</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr4</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr4</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr3</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">LessEqual</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr4</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr4</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr3</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Greater</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr4</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr4</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr3</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">GreaterEqual</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr4</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr4</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr3</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Equal</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr4</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr4</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr3</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">NotEqual</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr4</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr4</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr3</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr4</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr3</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Cons</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr5</span><span>, </span><span class="identifier">xs</span><span>: </span><span class="type-name">Expr4</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr4</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Append</span><span>(</span><span class="identifier">xs</span><span>: </span><span class="type-name">Expr5</span><span>, </span><span class="identifier">ys</span><span>: </span><span class="type-name">Expr4</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr4</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr5</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr4</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Add</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr5</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr6</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr5</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Sub</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr5</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr6</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr5</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr6</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr5</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Negate</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr6</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr6</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr7</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr6</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Mul</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr7</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr8</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr7</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Div</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr7</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr8</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr7</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr8</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr7</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Exp</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr9</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr8</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr8</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr9</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr8</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Comp</span><span>(</span><span class="identifier">f</span><span>: </span><span class="type-name">Expr10</span><span>, </span><span class="identifier">g</span><span>: </span><span class="type-name">Expr9</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr9</span><span>
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr10</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr9</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Lam</span><span>(</span><span class="identifier">args</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Pat</span><span>], </span><span class="identifier">body</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr10</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Let</span><span>(</span><span class="identifier">binding</span><span>: </span><span class="type-name">Clause</span><span>, </span><span class="identifier">in</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr10</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">If</span><span>(</span><span class="identifier">cond</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">thenExpr</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">elseExpr</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr10</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Case</span><span>(</span><span class="identifier">scrutinee</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">cases</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Alt</span><span>]) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr10</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Alt</span><span>(</span><span class="identifier">pat</span><span>: </span><span class="type-name">Pat</span><span>, </span><span class="identifier">body</span><span>: </span><span class="type-name">Expr</span><span>)
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr10_</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr10</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">StrongApp</span><span>(</span><span class="identifier">f</span><span>: </span><span class="type-name">Expr10_</span><span>, </span><span class="identifier">arg</span><span>: </span><span class="type-name">Term</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr10_</span><span>

    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Term</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr10_</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">ConId</span><span>(</span><span class="identifier">v</span><span>: </span><span class="type-name">String</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Term</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">PatCon</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">TyAtom</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">VarId</span><span>(</span><span class="identifier">v</span><span>: </span><span class="type-name">String</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Term</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">PatNaked</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">TyAtom</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">object</span><span> </span><span class="type-name">UnitCon</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Term</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">PatNaked</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">ParserBridge0</span><span>[</span><span class="type-name">Term</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">PatNaked</span><span>]
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">arity</span><span>: </span><span class="type-name">Int</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Term</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">PatCon</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">ParensVal</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Term</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">TupleLit</span><span>(</span><span class="identifier">xs</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Expr</span><span>]) </span><span class="keyword">extends</span><span> </span><span class="type-name">Term</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">ListLit</span><span>(</span><span class="identifier">xs</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Expr</span><span>]) </span><span class="keyword">extends</span><span> </span><span class="type-name">Term</span><span>

    </span><span class="keyword">trait</span><span> </span><span class="type-name">Literal</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Term</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">PatNaked</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">HsInt</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">BigInt</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Literal</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">HsString</span><span>(</span><span class="identifier">s</span><span>: </span><span class="type-name">String</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Literal</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">HsChar</span><span>(</span><span class="identifier">c</span><span>: </span><span class="type-name">Int</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Literal</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">HsDouble</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">BigDecimal</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Literal</span><span>

    </span><span class="keyword">object</span><span> </span><span class="type-name">WeakApp</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr</span><span>, </span><span class="type-name">Expr1</span><span>, </span><span class="type-name">Expr</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Or</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr2</span><span>, </span><span class="type-name">Expr1</span><span>, </span><span class="type-name">Expr1</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">And</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr3</span><span>, </span><span class="type-name">Expr2</span><span>, </span><span class="type-name">Expr2</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Less</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr4</span><span>, </span><span class="type-name">Expr4</span><span>, </span><span class="type-name">Expr3</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">LessEqual</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr4</span><span>, </span><span class="type-name">Expr4</span><span>, </span><span class="type-name">Expr3</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Greater</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr4</span><span>, </span><span class="type-name">Expr4</span><span>, </span><span class="type-name">Expr3</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">GreaterEqual</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr4</span><span>, </span><span class="type-name">Expr4</span><span>, </span><span class="type-name">Expr3</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Equal</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr4</span><span>, </span><span class="type-name">Expr4</span><span>, </span><span class="type-name">Expr3</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">NotEqual</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr4</span><span>, </span><span class="type-name">Expr4</span><span>, </span><span class="type-name">Expr3</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Cons</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr5</span><span>, </span><span class="type-name">Expr4</span><span>, </span><span class="type-name">Expr4</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Append</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr5</span><span>, </span><span class="type-name">Expr4</span><span>, </span><span class="type-name">Expr4</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Add</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr5</span><span>, </span><span class="type-name">Expr6</span><span>, </span><span class="type-name">Expr5</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Sub</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr5</span><span>, </span><span class="type-name">Expr6</span><span>, </span><span class="type-name">Expr5</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Negate</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">Expr6</span><span>, </span><span class="type-name">Expr6</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Mul</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr7</span><span>, </span><span class="type-name">Expr8</span><span>, </span><span class="type-name">Expr7</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Div</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr7</span><span>, </span><span class="type-name">Expr8</span><span>, </span><span class="type-name">Expr7</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Exp</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr9</span><span>, </span><span class="type-name">Expr8</span><span>, </span><span class="type-name">Expr8</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Comp</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr10</span><span>, </span><span class="type-name">Expr9</span><span>, </span><span class="type-name">Expr9</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">FunTy</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Type_</span><span>, </span><span class="type-name">Type</span><span>, </span><span class="type-name">Type</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Lam</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Pat</span><span>], </span><span class="type-name">Expr</span><span>, </span><span class="type-name">Lam</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Let</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Clause</span><span>, </span><span class="type-name">Expr</span><span>, </span><span class="type-name">Let</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">If</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge3</span><span>[</span><span class="type-name">Expr</span><span>, </span><span class="type-name">Expr</span><span>, </span><span class="type-name">Expr</span><span>, </span><span class="type-name">If</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Case</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Expr</span><span>, </span><span class="type-name">List</span><span>[</span><span class="type-name">Alt</span><span>], </span><span class="type-name">Case</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Alt</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Pat</span><span>, </span><span class="type-name">Expr</span><span>, </span><span class="type-name">Alt</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">ConId</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">String</span><span>, </span><span class="type-name">ConId</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">VarId</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">String</span><span>, </span><span class="type-name">VarId</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">TupleCon</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">Int</span><span>, </span><span class="type-name">TupleCon</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">ParensVal</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">Expr</span><span>, </span><span class="type-name">ParensVal</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">TupleLit</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Expr</span><span>], </span><span class="type-name">TupleLit</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">ListLit</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Expr</span><span>], </span><span class="type-name">ListLit</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">HsInt</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">BigInt</span><span>, </span><span class="type-name">HsInt</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">HsString</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">String</span><span>, </span><span class="type-name">HsString</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">HsChar</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">Int</span><span>, </span><span class="type-name">HsChar</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">HsDouble</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">BigDecimal</span><span>, </span><span class="type-name">HsDouble</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Data</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge3</span><span>[</span><span class="type-name">ConId</span><span>, </span><span class="type-name">List</span><span>[</span><span class="type-name">VarId</span><span>], </span><span class="type-name">List</span><span>[</span><span class="type-name">Con</span><span>], </span><span class="type-name">Data</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Con</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">ConId</span><span>, </span><span class="type-name">List</span><span>[</span><span class="type-name">TyAtom</span><span>], </span><span class="type-name">Con</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Decl</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">VarId</span><span>, </span><span class="type-name">Type</span><span>, </span><span class="type-name">Decl</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Clause</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge4</span><span>[</span><span class="type-name">VarId</span><span>, </span><span class="type-name">List</span><span>[</span><span class="type-name">PatNaked</span><span>], </span><span class="type-name">Option</span><span>[</span><span class="type-name">Expr</span><span>], </span><span class="type-name">Expr</span><span>, </span><span class="type-name">Clause</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">PatCons</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">PatParen</span><span>, </span><span class="type-name">Pat</span><span>, </span><span class="type-name">Pat</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">PatApp</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">PatCon</span><span>, </span><span class="type-name">List</span><span>[</span><span class="type-name">PatNaked</span><span>], </span><span class="type-name">PatApp</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">NestedPat</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">Pat</span><span>, </span><span class="type-name">NestedPat</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">PatTuple</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Pat</span><span>], </span><span class="type-name">PatTuple</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">PatList</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Pat</span><span>], </span><span class="type-name">PatList</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">TupleConTy</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">Int</span><span>, </span><span class="type-name">TupleConTy</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">ParenTy</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">Type</span><span>, </span><span class="type-name">ParenTy</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">TupleTy</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Type</span><span>], </span><span class="type-name">TupleTy</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">ListTy</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">Type</span><span>, </span><span class="type-name">ListTy</span><span>]
}</span></code></pre>
        <p>There is a lot of constructors here, but that&#39;s because the grammar is quite big. Notice that
        the shape of the AST roughly follows the shape of the grammar (down to the naming). Subtyping
        has been used where the same rule can appear in multiple places (<code>ConId</code> or <code>VarId</code> for
        instance). This helps keep the parser simple whilst still providing a level of type safety. We
        know, for instance, the associativity of the operators purely based on their types alone. By
        generalising, we can see that left-associative types are shaped like <code>(B, A) =&gt; B</code>, right
        associative ones as <code>(A, B) =&gt; B</code> and non-associative ones as <code>(A, A) =&gt; B</code>. This is a helpful
        guide for us, and in fact it will also ensure that we can&#39;t get the precedence table &quot;wrong&quot;. A
        consequence, as we&#39;ll see later, is we will be forced to use <code>SOps</code> instead of <code>Ops</code> in the
        precedence tables.</p>
        <p>The bridges have all also been defined above as well, including those marked
        with <code>ParserBridge0</code>, which is done on the object itself.</p>
        <p>Notably though, there are two AST nodes I&#39;m <em>not</em> going to give bridge constructors to: <code>StrongApp</code>, <code>TyApp</code>. If you look at
        the grammar, you&#39;ll see that the two relevant rules are both just <code>many</code>-like. Another option for
        these datatypes would have been to have taken a <code>List</code> of the sub-parses. But, morally, Haskell
        function applications are done one at a time so I&#39;ve not flattened the structure, and as we&#39;ll see,
        we&#39;ll use a <code>reduce</code> to handle these cases. In reality, providing a position to either of these two
        nodes is quite difficult, because they are actually both delimited by <code>&#39; &#39;</code>, so there really isn&#39;t a
        sensible position to latch on to.</p>
        
        <h2 id="parsing" class="section"><a class="anchor-link left" href="#parsing"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3 </span>Parsing</h2>
        <p>Now it&#39;s finally time to tackle the parser itself. Remember, our lexer handles all whitespace
        (except newlines) for us, and our bridge constructors would handle position information for us. The
        type of the AST is going to help us make sure that the parsers are constructed in the right way. One
        concern we need to be aware of is notice areas of the grammar where ambiguity lies, and make sure
        we resolve it properly with <code>atomic</code> (and only when needed!). Let&#39;s start at the bottom and work
        our way up: this means tackling, in order, atoms, expressions, patterns, clauses, types,
        declarations, and then finally data.</p>
        
        <h3 id="atoms-of-the-expression" class="section"><a class="anchor-link left" href="#atoms-of-the-expression"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3.1 </span>Atoms of the Expression</h3>
        <p>Let&#39;s make a start with <code>&lt;term&gt;</code>. There is nothing particular special about this, but we will need
        to be careful to handle the difference between tupled expressions and parenthesised expressions.
        There are a couple of ways we can try and tackle this: the first is to write both cases out and be
        sure to <code>atomic</code> one of them, so we can back out if required. The second is to parse them as one
        case together and then disambiguate which of the constructors should be used in a bridge! I&#39;m
        going to take the first approach for now, and then we can revisit later. Now for the <code>&lt;term&gt;</code>
        parser:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>.</span><span class="identifier">atomic</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">combinator</span><span>.{</span><span class="identifier">sepBy</span><span>, </span><span class="identifier">sepBy1</span><span>, </span><span class="identifier">countSome</span><span>}

</span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">implicits</span><span>.</span><span class="identifier">implicitSymbol</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">ast</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;literal&gt;`</span><span> = </span><span class="identifier">atomic</span><span>(</span><span class="type-name">HsDouble</span><span>(</span><span class="type-name">FLOAT</span><span>)) | </span><span class="type-name">HsInt</span><span>(</span><span class="type-name">INTEGER</span><span>) | </span><span class="type-name">HsString</span><span>(</span><span class="type-name">STRING</span><span>) | </span><span class="type-name">HsChar</span><span>(</span><span class="type-name">CHAR</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;var-id&gt;`</span><span> = </span><span class="type-name">VarId</span><span>(</span><span class="type-name">VAR_ID</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;con-id&gt;`</span><span> = </span><span class="type-name">ConId</span><span>(</span><span class="type-name">CON_ID</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;expr&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Expr</span><span>] = /???/

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;term&gt;`</span><span> = ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">`&lt;con-id&gt;`</span><span> | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
               | </span><span class="identifier">atomic</span><span>(</span><span class="type-name">TupleCon</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>))
               | </span><span class="identifier">atomic</span><span>(</span><span class="type-name">ParensVal</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;expr&gt;`</span><span> &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>))
               | </span><span class="type-name">TupleLit</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
               | </span><span class="type-name">ListLit</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
               | </span><span class="identifier">`&lt;literal&gt;`</span><span>
               )</span></code></pre>
        <p>Here, I&#39;ve followed the structure of the grammar quite closely. I&#39;m even making sure to follow the
        same order that the grammar uses: this means that I use <code>lazy val</code> for any parser which forward
        references another grammar rule (this is why I didn&#39;t need the laziness in the bridges). I&#39;m making
        use of the <code>sepBy</code> and <code>sepBy1</code> combinators to handle the comma separated values and parse them into
        a list. Notice that there are three instances of backtracking <em>alone</em> in this parser. Tuple
        constructions (like <code>(,,,)</code>), parenthesised values, and tuple literals all share the <code>(</code> token. That
        being said, so does <code>()</code>, but there it&#39;s been treated as a single atomic token by our
        <code>implicitSymbol</code>, so no backtracking required at the branching level. As I said, this could get
        expensive, so we will re-visit it later. The same crops up with <code>FLOAT</code> and <code>INTEGER</code>, which may
        also overlap with each other: again, we will re-visit this later and use the <code>FLOAT_OR_INT</code> token
        instead. To deal with the number of <code>,</code> representing the arity of a tuple constructor operator, I&#39;ve
        also drafted up a <code>countSome</code> combinator, which will parse its given parser one or more times, counting
        the number of successes. You&#39;ll also notice that, in Scala, anything goes between backticks! For
        this parser, I&#39;ll go with this notation to make it match a little more closely with the grammar
        itself (and for variety): it&#39;s up to you whether or not you like this notation. One thing that&#39;s
        nice about it is that it clearly distinguishes between our combinators and the grammar rules
        themselves.</p>
        
        <h3 id="expressions" class="section"><a class="anchor-link left" href="#expressions"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3.2 </span>Expressions</h3>
        <p>Next we&#39;ll tackle up to <code>&lt;expr&gt;</code>. By now, we should know that the correct tool to reach for is
        <code>precedence</code>. While <code>&lt;expr-10&gt;</code> can be considered to have operators in it, they do not fit with
        any associativity in Haskell so I will split them out for digestibility. Without further ado, let&#39;s get going:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.{</span><span class="identifier">precedence</span><span>, </span><span class="type-name">SOps</span><span>, </span><span class="type-name">InfixL</span><span>, </span><span class="type-name">InfixR</span><span>, </span><span class="type-name">InfixN</span><span>, </span><span class="type-name">Prefix</span><span>, </span><span class="type-name">Atoms</span><span>}

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;expr&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Expr</span><span>] = </span><span class="identifier">precedence</span><span> {
    </span><span class="type-name">SOps</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="type-name">WeakApp</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;$&quot;</span><span>) +:
    </span><span class="type-name">SOps</span><span>(</span><span class="type-name">InfixR</span><span>)(</span><span class="type-name">Or</span><span>      </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;||&quot;</span><span>) +:
    </span><span class="type-name">SOps</span><span>(</span><span class="type-name">InfixR</span><span>)(</span><span class="type-name">And</span><span>     </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;&amp;&amp;&quot;</span><span>) +:
    </span><span class="type-name">SOps</span><span>(</span><span class="type-name">InfixN</span><span>)(</span><span class="type-name">Less</span><span>    </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;&lt;&quot;</span><span>,  </span><span class="type-name">LessEqual</span><span>    </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;&lt;=&quot;</span><span>,
                 </span><span class="type-name">Greater</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;&gt;&quot;</span><span>,  </span><span class="type-name">GreaterEqual</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;&gt;=&quot;</span><span>,
                 </span><span class="type-name">Equal</span><span>   </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;==&quot;</span><span>, </span><span class="type-name">NotEqual</span><span>     </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;/=&quot;</span><span>) +:
    </span><span class="type-name">SOps</span><span>(</span><span class="type-name">InfixR</span><span>)(</span><span class="type-name">Cons</span><span>    </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>,  </span><span class="type-name">Append</span><span>       </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;++&quot;</span><span>) +:
    </span><span class="type-name">SOps</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="type-name">Add</span><span>     </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;+&quot;</span><span>,  </span><span class="type-name">Sub</span><span>          </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;-&quot;</span><span>) +:
    </span><span class="type-name">SOps</span><span>(</span><span class="type-name">Prefix</span><span>)(</span><span class="type-name">Negate</span><span>  </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;-&quot;</span><span>) +:
    </span><span class="type-name">SOps</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="type-name">Mul</span><span>     </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;*&quot;</span><span>,  </span><span class="type-name">Div</span><span>          </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;/&quot;</span><span>) +:
    </span><span class="type-name">SOps</span><span>(</span><span class="type-name">InfixR</span><span>)(</span><span class="type-name">Exp</span><span>     </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;^&quot;</span><span>) +:
    </span><span class="type-name">SOps</span><span>(</span><span class="type-name">InfixR</span><span>)(</span><span class="type-name">Comp</span><span>    </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;.&quot;</span><span>) +:
    </span><span class="identifier">`&lt;expr-10&gt;`</span><span>
}
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;expr-10&gt;`</span><span> = </span><span class="type-name">Atoms</span><span>(/???/)</span></code></pre>
        <p>Here we can see a whole bunch of interesting things! Firstly, up to this point we&#39;ve been used to
        seeing <code>Ops</code> in our precedence, where here we are using <code>SOps</code> and the <code>Levels</code> list. This is
        important, because our AST is far more strongly typed. If we made each layer of the tree the same
        <code>(Expr, Expr) =&gt; Expr</code> shape, then we could use <code>Ops</code> as we&#39;ve been used to in other pages.
        However, sine I opted to make a more strongly typed tree using subtyping, we have to use the more
        complex and general <code>SOps</code> precedence architecture. This has some really nice consequences:</p>
        <p>1) if, say, I removed <code>SOps(InfixR)(Exp &lt;# &quot;^&quot;)</code> from the list, it would no longer compile
        2) if, say, I accidentally said <code>SOps(InfixL)(Exp &lt;# &quot;^&quot;)</code>, then it would no longer compile
        3) if, say, I reordered the lines in the list, then it would no longer compile
        4) by using subtyping, we don&#39;t need to provide any explicit wrapper constructors</p>
        <p>Next up is the remaining three rules: <code>&lt;expr-10&gt;</code>, <code>&lt;alt&gt;</code>, and <code>&lt;func-app&gt;</code>.</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>.{</span><span class="identifier">some</span><span>, </span><span class="identifier">many</span><span>}

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;clause&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Clause</span><span>] = /???/
</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-naked&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">PatNaked</span><span>] = /???/
</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Pat</span><span>] = /???/

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;alt&gt;`</span><span> = </span><span class="type-name">Alt</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;-&gt;&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;expr&gt;`</span><span>)
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;func-app&gt;`</span><span> = </span><span class="identifier">`&lt;term&gt;`</span><span>.</span><span class="identifier">reduceLeft</span><span>(</span><span class="type-name">StrongApp</span><span>)
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;expr-10&gt;`</span><span> = </span><span class="type-name">Atoms</span><span>(
    </span><span class="type-name">Lam</span><span>(</span><span class="string-literal">&quot;</span><span class="escape-sequence">\\</span><span class="string-literal">&quot;</span><span> ~&gt; </span><span class="identifier">some</span><span>(</span><span class="identifier">`&lt;pat-naked&gt;`</span><span>), </span><span class="string-literal">&quot;-&gt;&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;expr&gt;`</span><span>),
    </span><span class="type-name">Let</span><span>(</span><span class="string-literal">&quot;let&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;clause&gt;`</span><span>, </span><span class="string-literal">&quot;in&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;expr&gt;`</span><span>),
    </span><span class="type-name">If</span><span>(</span><span class="string-literal">&quot;if&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;then&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;else&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;expr&gt;`</span><span>),
    </span><span class="type-name">Case</span><span>(</span><span class="string-literal">&quot;case&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;expr&gt;`</span><span>,
         </span><span class="string-literal">&quot;of&quot;</span><span> ~&gt; </span><span class="string-literal">&quot;{&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;alt&gt;`</span><span>, (</span><span class="string-literal">&quot;;&quot;</span><span> | </span><span class="type-name">NEWLINE</span><span>) &lt;~ </span><span class="identifier">many</span><span>(</span><span class="type-name">NEWLINE</span><span>)) &lt;~ </span><span class="string-literal">&quot;}&quot;</span><span>),
    </span><span class="identifier">`&lt;func-app&gt;`</span><span>)</span></code></pre>
        <p>This section of the parser is much more straightforward: we are using the regular shape of the
        grammar in conjunction with our bridge constructors. Notice here we are explicitly making use of
        <code>NEWLINE</code>, so that we can make multi-line <code>case</code> statements. This is ok because we have explicit
        curly braces to delimit the start and end of the <code>case</code>. Note here that the <code>&quot;\\&quot;</code> is just parsing a
        <code>\</code>, but the backslash much be escaped to fit within the Scala string! The <code>&lt;func-app&gt;</code> rule is
        interesting, because it is the same as <code>some(`&lt;term&gt;`).map(_.reduceLeft(StrongApp))</code>, but is
        more efficient, not having to have to construct an intermediate list. It&#39;s always a good idea to
        check out <code>parsley</code>&#39;s API to see if you can find any hidden gems like this one!</p>
        <p>Now we have tackled everything from <code>&lt;expr&gt;</code> down, we are now in a position to deal with <code>&lt;clause&gt;</code>
        and its sub grammars.</p>
        
        <h3 id="clauses" class="section"><a class="anchor-link left" href="#clauses"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3.3 </span>Clauses</h3>
        <p>These set of parsers are similar to what we saw with <code>&lt;term&gt;</code>. There are going to be elements of
        ambiguity in the grammar that need to be resolved with <code>atomic</code>, specifically those involving
        parentheses. But other than that there isn&#39;t anything really new here.</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>.</span><span class="identifier">many</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">option</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.</span><span class="identifier">infix</span><span>

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;clause&gt;`</span><span> =
    </span><span class="type-name">Clause</span><span>(</span><span class="identifier">`&lt;var-id&gt;`</span><span>, </span><span class="identifier">many</span><span>(</span><span class="identifier">`&lt;pat-naked&gt;`</span><span>), </span><span class="identifier">option</span><span>(</span><span class="identifier">`&lt;guard&gt;`</span><span>), </span><span class="string-literal">&quot;=&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;expr&gt;`</span><span>)
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-naked&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">PatNaked</span><span>] =
    ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>)
    | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>) | (</span><span class="type-name">NilCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>) | </span><span class="identifier">`&lt;literal&gt;`</span><span> | (</span><span class="type-name">Wild</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;_&quot;</span><span>)
    | </span><span class="identifier">atomic</span><span>(</span><span class="type-name">NestedPat</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;pat&gt;`</span><span> &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>))
    | </span><span class="type-name">PatTuple</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
    | </span><span class="type-name">PatList</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
    )
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat&gt;`</span><span> = </span><span class="identifier">infix</span><span>.</span><span class="identifier">right1</span><span>(</span><span class="identifier">`&lt;pat-paren&gt;`</span><span>, </span><span class="type-name">PatCons</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>)
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-paren&gt;`</span><span> = </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-app&gt;`</span><span>) | </span><span class="identifier">`&lt;pat-naked&gt;`</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-app&gt;`</span><span> = </span><span class="type-name">PatApp</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>, </span><span class="identifier">some</span><span>(</span><span class="identifier">`&lt;pat-naked&gt;`</span><span>))
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-con&gt;`</span><span> = ( </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; (</span><span class="type-name">ConsCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                       | </span><span class="type-name">TupleCon</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                       | </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                       )

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;guard&gt;`</span><span> = </span><span class="string-literal">&quot;|&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;expr&gt;`</span></code></pre>
        <p>Like I said, nothing too interesting here. Notice, however, that for <code>&lt;pat&gt;</code> I have used a
        <code>infix.right1</code>: we&#39;ve been used to using <code>precedence</code>, but in cases like these the <code>chain</code>s are just
        so much more simple. Don&#39;t be afraid to make use of them! There are plenty of  <code>atomic</code>s here that we
        will come back and eliminate later on: notably, the <code>atomic</code> in <code>&lt;pat-paren&gt;</code> is used to guard
        against a <code>&lt;pat-con&gt;</code> being parsed without any <code>&lt;pat-naked&gt;</code> - this needs to be parsed again in
        <code>&lt;pat-naked&gt;</code> itself.</p>
        
        <h3 id="types" class="section"><a class="anchor-link left" href="#types"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3.4 </span>Types</h3>
        <p>Again, here we can just see more examples of the same concepts we&#39;ve already been working with.
        There is a sense in which we&#39;ve really reached the limit of stuff we need for our practical common
        cases: there isn&#39;t much more to say until we try and deal with much more complex grammatical
        features.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Type</span><span>] = </span><span class="identifier">infix</span><span>.</span><span class="identifier">right1</span><span>(</span><span class="identifier">`&lt;type-app&gt;`</span><span>, </span><span class="type-name">FunTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;-&gt;&quot;</span><span>)
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type-app&gt;`</span><span> = </span><span class="identifier">`&lt;type-atom&gt;`</span><span>.</span><span class="identifier">reduceLeft</span><span>(</span><span class="type-name">TyApp</span><span>)
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type-atom&gt;`</span><span> = ( </span><span class="identifier">`&lt;type-con&gt;`</span><span> | </span><span class="identifier">`&lt;var-id&gt;`</span><span> | (</span><span class="type-name">UnitTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
                         | </span><span class="type-name">ListTy</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;type&gt;`</span><span> &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
                         | </span><span class="identifier">atomic</span><span>(</span><span class="type-name">ParenTy</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;type&gt;`</span><span> &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>))
                         | </span><span class="type-name">TupleTy</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;type&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                         )
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type-con&gt;`</span><span> = ( </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                        | (</span><span class="type-name">ListConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>)
                        | </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; (</span><span class="type-name">FunConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;-&gt;&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                        | </span><span class="identifier">atomic</span><span>(</span><span class="type-name">TupleConTy</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>))
                        )</span></code></pre>
        <p>We can see another instance of <code>infix.right1</code> out in the wild here, as well as the other <code>reduceLeft</code>
        used for type application. Yet again, there is some ambiguity evidenced by the <code>atomic</code> here, and
        just like in the other instances, it&#39;s to do with parentheses. The second <code>atomic</code> in <code>&lt;type-con&gt;</code> is
        interesting: it&#39;s not clear from the rule itself why it is there. In fact, it&#39;s there because we
        need to be able to backtrack out of <code>&lt;type-con&gt;</code> during <code>&lt;type-atom&gt;</code>; however, since the ambiguity
        only arises from the tuple constructor (the function constructor doesn&#39;t cause ambiguity in this case,
        because of the existing <code>atomic</code>), we don&#39;t need to enable backtracking on the <em>entire</em> rule.
        Finally we can move onto the top level parsers and start tackling the performance gotchas: this is
        the more challenging aspect of managing a parser of this size and complexity.</p>
        
        <h3 id="declarations-and-data" class="section"><a class="anchor-link left" href="#declarations-and-data"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3.5 </span>Declarations and Data</h3>
        <p>Here is a nice easy finish. These last rules are really just book-keeping. I&#39;m also going to
        introduce a way of running the parser directly.</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>.</span><span class="identifier">some</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">sepEndBy</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">errors</span><span>.</span><span class="type-name">ErrorBuilder</span><span>

</span><span class="keyword">def</span><span> </span><span class="declaration-name">parse</span><span>[</span><span class="type-name">Err</span><span>: </span><span class="type-name">ErrorBuilder</span><span>](</span><span class="identifier">input</span><span>: </span><span class="type-name">String</span><span>) = </span><span class="identifier">`&lt;program&gt;`</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="identifier">input</span><span>)

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;program&gt;`</span><span> =
    </span><span class="identifier">fully</span><span>(</span><span class="identifier">sepEndBy</span><span>(</span><span class="identifier">`&lt;data&gt;`</span><span> | </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;declaration&gt;`</span><span>) | </span><span class="identifier">`&lt;clause&gt;`</span><span>, </span><span class="identifier">some</span><span>(</span><span class="type-name">NEWLINE</span><span>)))

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;data&gt;`</span><span> = </span><span class="type-name">Data</span><span>(</span><span class="string-literal">&quot;data&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;con-id&gt;`</span><span>, </span><span class="identifier">many</span><span>(</span><span class="identifier">`&lt;var-id&gt;`</span><span>), </span><span class="string-literal">&quot;=&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;constructors&gt;`</span><span>)
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;constructors&gt;`</span><span> = </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;constructor&gt;`</span><span>, </span><span class="string-literal">&quot;|&quot;</span><span>)
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;constructor&gt;`</span><span> = </span><span class="type-name">Con</span><span>(</span><span class="identifier">`&lt;con-id&gt;`</span><span>, </span><span class="identifier">many</span><span>(</span><span class="identifier">`&lt;type-atom&gt;`</span><span>))

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;declaration&gt;`</span><span> = </span><span class="type-name">Decl</span><span>(</span><span class="identifier">`&lt;var-id&gt;`</span><span>, </span><span class="string-literal">&quot;::&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;type&gt;`</span><span>)</span></code></pre>
        <p>We do have to be careful here, there is some overlap between <code>&lt;declaration&gt;</code> and <code>&lt;clause&gt;</code>. This,
        unfortunately, is unavoidable without more involved work, but the overlap is just a single variable
        name, so it&#39;s fairly minor. That being said, really, the scope on that <code>atomic</code> is too big: once we&#39;ve
        seen the <code>&quot;::&quot;</code>, we <em>know</em> for sure that everything that follows (good or bad) is a type. At the
        moment, if something bad happens in the type, it can backtrack all the way out and try reading a
        clause instead. This isn&#39;t too much of a problem for us here, since the clause will also fail and
        the declaration&#39;s error message got further (and so takes precedence), but suppose the backtracking
        allowed the parser to succeed somehow (perhaps it was <code>many(`&lt;declaration&gt;`)</code>) then the error
        will for sure be in the wrong place!</p>
        <p>The <code>parse</code> method is our hook to the outside world. I&#39;ve written it &quot;properly&quot;
        here so that it is parameterised by an instance of the <code>ErrorBuilder</code> typeclass. We could omit this,
        but then we&#39;d always have to run it with the <code>ErrorBuilder</code> in scope for whatever concrete <code>Err</code> we
        choose (in most cases, <code>String</code>). It&#39;s useful to do this in case your unit tests want to test for
        the correctness of error messages!</p>
        
        <h2 id="optimising-the-parser" class="section"><a class="anchor-link left" href="#optimising-the-parser"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">4 </span>Optimising the Parser</h2>
        
        <h3 id="fixing-parentheses-backtracking" class="section"><a class="anchor-link left" href="#fixing-parentheses-backtracking"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">4.1 </span>Fixing Parentheses Backtracking</h3>
        <p>Before we finish up this page, and move onto learning about error messages, let&#39;s deal with the last
        remaining warts in this version of our parser. There are several instances of backtracking: some are
        very avoidable, and others are potentially expensive. We will progress through them, in some cases
        making incremental changes. As I&#39;ve said before, dealing with backtracking in an effective way is in
        most cases the trickiest part of actually writing a parser. Make sure you understand how the parser
        has been built up so far and convince yourself about why each instance of <code>atomic</code> in the previous
        parsers has been necessary before continuing.</p>
        
        <h4 id="pat-con-type-con-and-term" class="section"><a class="anchor-link left" href="#pat-con-type-con-and-term"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">4.1.1 </span><code>&lt;pat-con&gt;</code>, <code>&lt;type-con&gt;</code>, and <code>&lt;term&gt;</code></h4>
        <p>These three grammar rules are very straightforward to factor out and remove the backtracking for,
        so we will start with them first. Let&#39;s remind ourselves of the three rules in question and identify
        the parts we can handle:</p>
        <pre><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-con&gt;`</span><span> = ( </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; (</span><span class="type-name">ConsCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                       | </span><span class="type-name">TupleCon</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                       | </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                       )

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type-con&gt;`</span><span> = ( </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                   | (</span><span class="type-name">ListConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>)
                   | </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; (</span><span class="type-name">FunConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;-&gt;&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                   | </span><span class="identifier">atomic</span><span>(</span><span class="type-name">TupleConTy</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>))
                   )

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;term&gt;`</span><span> = ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">`&lt;con-id&gt;`</span><span> | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
               | </span><span class="identifier">atomic</span><span>(</span><span class="type-name">TupleCon</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>))
               | </span><span class="identifier">atomic</span><span>(</span><span class="type-name">ParensVal</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;expr&gt;`</span><span> &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>))
               | </span><span class="type-name">TupleLit</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
               | </span><span class="type-name">ListLit</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
               | </span><span class="identifier">`&lt;literal&gt;`</span><span>
               )</span></code></pre>
        <p>Now, with <code>&lt;pat-con&gt;</code> and <code>&lt;type-con&gt;</code>, they both contain backtracking because there are two portions
        of the parser which lie within parentheses. You can see the same thing in the <code>&lt;term&gt;</code> parser,
        however, as we&#39;ll see, <code>&lt;term&gt;</code> will require a bit more extra work to fix the second instance of
        backtracking. Thankfully, these are all relatively easy to fix: we just need to distribute the
        parentheses through the rules that contain them on the <em>inside</em>. This is a nice warm-up exercise:</p>
        <pre><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-con&gt;`</span><span> = ( </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; (</span><span class="type-name">ConsCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                       | </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>)) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
                       | </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                       )

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type-con&gt;`</span><span> = ( </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                   | (</span><span class="type-name">ListConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>)
                   | </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; (</span><span class="type-name">FunConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;-&gt;&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                   | </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="type-name">TupleConTy</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>)) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                   )

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;term&gt;`</span><span> = ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">`&lt;con-id&gt;`</span><span> | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
               | </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>)) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
               | </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="type-name">ParensVal</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
               | </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="type-name">TupleLit</span><span>(</span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>)) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
               | </span><span class="type-name">ListLit</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
               | </span><span class="identifier">`&lt;literal&gt;`</span><span>
               )</span></code></pre>
        <p>With the parentheses distributed, we can see that they are easily factored out (on both the left-
        and the right-hand sides):</p>
        <pre><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-con&gt;`</span><span> = ( </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ((</span><span class="type-name">ConsCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>) | </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
                       | </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                       )

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type-con&gt;`</span><span> = ( </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                   | (</span><span class="type-name">ListConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>)
                   | </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ((</span><span class="type-name">FunConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;-&gt;&quot;</span><span>) | </span><span class="type-name">TupleConTy</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                   )

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;term&gt;`</span><span> = ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">`&lt;con-id&gt;`</span><span> | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
               | </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ( </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))
                        | </span><span class="identifier">atomic</span><span>(</span><span class="type-name">ParensVal</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>))
                        | </span><span class="type-name">TupleLit</span><span>(</span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>))
                        ) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
               | </span><span class="type-name">ListLit</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
               | </span><span class="identifier">`&lt;literal&gt;`</span><span>
               )</span></code></pre>
        <p>This has immediately eliminated three of the <code>atomic</code>s, but one persists inside <code>&lt;term&gt;</code>: this is
        because <code>ParensVal</code> and <code>TupleLit</code> both share an <code>&lt;expr&gt;</code>. This is a bit trickier to eliminate, but
        let&#39;s move on to tackling these. Note that the other <code>atomic</code> in <code>&lt;type-con&gt;</code> is due to a conflict
        in the wider grammar, we can look at that in part 4.</p>
        
        <h4 id="pat-naked-type-atom-and-term-again" class="section"><a class="anchor-link left" href="#pat-naked-type-atom-and-term-again"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">4.1.2 </span><code>&lt;pat-naked&gt;</code>, <code>&lt;type-atom&gt;</code>, and <code>&lt;term&gt;</code> (again)</h4>
        <p>The next three grammar rules contain similar patterns to the last three, but solving the backtracking
        is less obvious. Let&#39;s start by recapping what the three rules are:</p>
        <pre><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-naked&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">PatNaked</span><span>] =
    ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>)
    | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>) | (</span><span class="type-name">NilCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>) | </span><span class="identifier">`&lt;literal&gt;`</span><span> | (</span><span class="type-name">Wild</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;_&quot;</span><span>)
    | </span><span class="identifier">atomic</span><span>(</span><span class="type-name">NestedPat</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;pat&gt;`</span><span> &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>))
    | </span><span class="type-name">PatTuple</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
    | </span><span class="type-name">PatList</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
    )

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type-atom&gt;`</span><span> = ( </span><span class="identifier">`&lt;type-con&gt;`</span><span> | </span><span class="identifier">`&lt;var-id&gt;`</span><span> | (</span><span class="type-name">UnitTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
                         | </span><span class="type-name">ListTy</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;type&gt;`</span><span> &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
                         | </span><span class="identifier">atomic</span><span>(</span><span class="type-name">ParenTy</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;type&gt;`</span><span> &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>))
                         | </span><span class="type-name">TupleTy</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;type&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                         )

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;term&gt;`</span><span> = ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">`&lt;con-id&gt;`</span><span> | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
               | </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ( </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))
                        | </span><span class="identifier">atomic</span><span>(</span><span class="type-name">ParensVal</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>))
                        | </span><span class="type-name">TupleLit</span><span>(</span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>))
                        ) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
               | </span><span class="type-name">ListLit</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
               | </span><span class="identifier">`&lt;literal&gt;`</span><span>
               )</span></code></pre>
        <p>First, let&#39;s do what we did to <code>&lt;term&gt;</code> to <code>&lt;pat-naked&gt;</code> and <code>&lt;type-atom&gt;</code>:</p>
        <pre><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-naked&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">PatNaked</span><span>] =
    ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>)
    | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>) | (</span><span class="type-name">NilCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>) | </span><span class="identifier">`&lt;literal&gt;`</span><span> | (</span><span class="type-name">Wild</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;_&quot;</span><span>)
    | </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ( </span><span class="identifier">atomic</span><span>(</span><span class="type-name">NestedPat</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>))
             | </span><span class="type-name">PatTuple</span><span>(</span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>))
             ) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
    | </span><span class="type-name">PatList</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
    )

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type-atom&gt;`</span><span> = ( </span><span class="identifier">`&lt;type-con&gt;`</span><span> | </span><span class="identifier">`&lt;var-id&gt;`</span><span> | (</span><span class="type-name">UnitTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
                         | </span><span class="type-name">ListTy</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;type&gt;`</span><span> &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
                         | </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ( </span><span class="identifier">atomic</span><span>(</span><span class="type-name">ParenTy</span><span>(</span><span class="identifier">`&lt;type&gt;`</span><span>))
                                  | </span><span class="type-name">TupleTy</span><span>(</span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;type&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>))
                                  ) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
                         )

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;term&gt;`</span><span> = ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">`&lt;con-id&gt;`</span><span> | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
               | </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ( </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))
                        | </span><span class="identifier">atomic</span><span>(</span><span class="type-name">ParensVal</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>))
                        | </span><span class="type-name">TupleLit</span><span>(</span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>))
                        ) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
               | </span><span class="type-name">ListLit</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
               | </span><span class="identifier">`&lt;literal&gt;`</span><span>
               )</span></code></pre>
        <p>Hopefully you can see that all three rules are similar to each other: they all have an <code>atomic</code>
        <em>inside</em> the factored parentheses. The problem is that they use different bridge constructors and the
        <code>sepBy1</code> does not allow for easy factoring. That being said, we could deal with this by creating... a
        new <strong><em>disambiguator bridge</em></strong>! Let&#39;s take a look at them:</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">NestedPatOrPatTuple</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Pat</span><span>], </span><span class="type-name">PatNaked</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">ps</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Pat</span><span>]): </span><span class="type-name">PatNaked</span><span> = </span><span class="identifier">ps</span><span> </span><span class="keyword">match</span><span> {
        </span><span class="keyword">case</span><span> </span><span class="type-name">List</span><span>(</span><span class="identifier">p</span><span>) =&gt; </span><span class="type-name">NestedPat</span><span>(</span><span class="identifier">p</span><span>)
        </span><span class="keyword">case</span><span> </span><span class="identifier">ps</span><span> =&gt; </span><span class="type-name">PatTuple</span><span>(</span><span class="identifier">ps</span><span>)
    }
}

</span><span class="keyword">object</span><span> </span><span class="type-name">ParenTyOrTupleTy</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Type</span><span>], </span><span class="type-name">TyAtom</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">tys</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Type</span><span>]): </span><span class="type-name">TyAtom</span><span> = </span><span class="identifier">tys</span><span> </span><span class="keyword">match</span><span> {
        </span><span class="keyword">case</span><span> </span><span class="type-name">List</span><span>(</span><span class="identifier">ty</span><span>) =&gt; </span><span class="type-name">ParenTy</span><span>(</span><span class="identifier">ty</span><span>)
        </span><span class="keyword">case</span><span> </span><span class="identifier">tys</span><span> =&gt; </span><span class="type-name">TupleTy</span><span>(</span><span class="identifier">tys</span><span>)
    }
}

</span><span class="keyword">object</span><span> </span><span class="type-name">TupleLitOrParensVal</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Expr</span><span>], </span><span class="type-name">Term</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">xs</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Expr</span><span>]): </span><span class="type-name">Term</span><span> = </span><span class="identifier">xs</span><span> </span><span class="keyword">match</span><span> {
        </span><span class="keyword">case</span><span> </span><span class="type-name">List</span><span>(</span><span class="identifier">x</span><span>) =&gt; </span><span class="type-name">ParensVal</span><span>(</span><span class="identifier">x</span><span>)
        </span><span class="keyword">case</span><span> </span><span class="identifier">xs</span><span> =&gt; </span><span class="type-name">TupleLit</span><span>(</span><span class="identifier">xs</span><span>)
    }
}</span></code></pre>
        <p>Compared with <em><strong>bridge constructors</strong></em>, <em><strong>disambiguator bridges</strong></em> are used to arbitrate between
        several possible instantiations dependending on the data that is fed to them. These bridges each
        encapsulate both of the overlapping cases. If the list of results only has one element, then it
        indicates we should not be creating a tuple. With these new bridges replacing the old ones, we can
        adjust our parsers:</p>
        <pre><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-naked&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">PatNaked</span><span>] =
    ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>)
    | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>) | (</span><span class="type-name">NilCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>) | </span><span class="identifier">`&lt;literal&gt;`</span><span> | (</span><span class="type-name">Wild</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;_&quot;</span><span>)
    | </span><span class="type-name">NestedPatOrPatTuple</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
    | </span><span class="type-name">PatList</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
    )

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type-atom&gt;`</span><span> = ( </span><span class="identifier">`&lt;type-con&gt;`</span><span> | </span><span class="identifier">`&lt;var-id&gt;`</span><span> | (</span><span class="type-name">UnitTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
                         | </span><span class="type-name">ListTy</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;type&gt;`</span><span> &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
                         | </span><span class="type-name">ParenTyOrTupleTy</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;type&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                         )

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;term&gt;`</span><span> = ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">`&lt;con-id&gt;`</span><span> | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
               | </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ( </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))
                        | </span><span class="type-name">TupleLitOrParensVal</span><span>(</span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>))
                        ) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
               | </span><span class="type-name">ListLit</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;expr&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
               | </span><span class="identifier">`&lt;literal&gt;`</span><span>
               )</span></code></pre>
        <p>By making use of our special disambiguators bridge, we&#39;ve eliminated the pesky <code>atomic</code>s. I&#39;ve put the
        parentheses back inside the bridge call for the <code>&lt;pat-naked&gt;</code> and <code>&lt;type-atom&gt;</code> rules, because, in my opinion, it looks a bit cleaner.</p>
        
        <h4 id="numbers-in-literal" class="section"><a class="anchor-link left" href="#numbers-in-literal"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">4.1.3 </span>Numbers in <code>&lt;literal&gt;</code></h4>
        <p>With the tools we&#39;ve already developed so far, this one is easy. Let&#39;s remind ourselves of the rule
        first:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">/*
val INTEGER = lexer.lexeme.numeric.natural.number
val FLOAT = lexer.lexeme.numeric.floating.number
val INT_OR_FLOAT = lexer.lexeme.numeric.unsignedCombined.number
*/</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;literal&gt;`</span><span> = </span><span class="identifier">atomic</span><span>(</span><span class="type-name">HsDouble</span><span>(</span><span class="type-name">FLOAT</span><span>)) | </span><span class="type-name">HsInt</span><span>(</span><span class="type-name">INTEGER</span><span>) | </span><span class="type-name">HsString</span><span>(</span><span class="type-name">STRING</span><span>) | </span><span class="type-name">HsChar</span><span>(</span><span class="type-name">CHAR</span><span>)</span></code></pre>
        <p>The problem here is that floats and ints share a common leading prefix: the whole number part. When
        we defined the <code>lexer</code>, I mentioned that it supports a <code>INT_OR_FLOAT</code> token. Now it&#39;s time to make
        use of it to remove this <code>atomic</code>. Our first thought might be to make a disambiguator bridge that can accommodate either of them, and that would be a fine idea:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">HsIntOrDouble</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">Either</span><span>[</span><span class="type-name">BigInt</span><span>, </span><span class="type-name">BigDecimal</span><span>], </span><span class="type-name">Literal</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Either</span><span>[</span><span class="type-name">BigInt</span><span>, </span><span class="type-name">BigDecimal</span><span>]): </span><span class="type-name">Literal</span><span> = </span><span class="identifier">x</span><span>.</span><span class="identifier">fold</span><span>(</span><span class="type-name">HsInt</span><span>(</span><span class="identifier">_</span><span>), </span><span class="type-name">HsDouble</span><span>(</span><span class="identifier">_</span><span>))
}

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;literal&gt;`</span><span> = </span><span class="type-name">HsIntOrDouble</span><span>(</span><span class="type-name">INT_OR_FLOAT</span><span>) | </span><span class="type-name">HsString</span><span>(</span><span class="type-name">STRING</span><span>) | </span><span class="type-name">HsChar</span><span>(</span><span class="type-name">CHAR</span><span>)</span></code></pre>
        <p>And this works fine!</p>
        
        <h4 id="loose-ends" class="section"><a class="anchor-link left" href="#loose-ends"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">4.1.4 </span>Loose ends</h4>
        <p>At this point, there are four <code>atomic</code>s left in the entire parser: one in <code>&lt;type-con&gt;</code>, one in
        <code>&lt;pat-paren&gt;</code>, one in <code>&lt;pat-naked&gt;</code>, and, finally, one in <code>&lt;program&gt;</code>. At this point it gets much
        harder to remove them without altering the grammar substantially. Let&#39;s see how much more we can do
        to remove them and explore some of the more dramatic changes it entails to the parser. We&#39;ll start
        with the <code>atomic</code> in <code>&lt;type-con&gt;</code>.</p>
        <p>The reason for this <code>atomic</code> is more obvious when we compare it with <code>&lt;type-atom&gt;</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type-con&gt;`</span><span> = ( </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                   | (</span><span class="type-name">ListConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>)
                   | </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ((</span><span class="type-name">FunConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;-&gt;&quot;</span><span>) | </span><span class="type-name">TupleConTy</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                   )
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type-atom&gt;`</span><span> = ( </span><span class="identifier">`&lt;type-con&gt;`</span><span> | </span><span class="identifier">`&lt;var-id&gt;`</span><span> | (</span><span class="type-name">UnitTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
                         | </span><span class="type-name">ListTy</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;type&gt;`</span><span> &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
                         | </span><span class="type-name">ParenTyOrTupleTy</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;type&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                         )</span></code></pre>
        <p>The <code>atomic</code> in <code>&lt;type-con&gt;</code> is used to backtrack out of the parentheses, since <code>ParenTyOrTupleTy</code>
        will also consume them if we didn&#39;t see a <code>-&gt;</code> or a <code>,</code>. Thankfully, <code>&lt;type-con&gt;</code> is used in one
        place in the parser, and we are looking at it! To fix this <code>atomic</code> we just need to be destructive
        and stop following the grammar as rigidly as we have been. Let&#39;s inline <code>&lt;type-con&gt;</code> into <code>&lt;type-atom&gt;</code>
        to start with:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type-atom&gt;`</span><span> = ( </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                         | (</span><span class="type-name">ListConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>)
                         | </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ( (</span><span class="type-name">FunConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;-&gt;&quot;</span><span>)
                                         | </span><span class="type-name">TupleConTy</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))
                                         ) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                         | </span><span class="identifier">`&lt;var-id&gt;`</span><span> | (</span><span class="type-name">UnitTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
                         | </span><span class="type-name">ListTy</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;type&gt;`</span><span> &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
                         | </span><span class="type-name">ParenTyOrTupleTy</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;type&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                         )</span></code></pre>
        <p>Right, now that they have been put together, we can see the problem more clearly. Let&#39;s now
        reorganise the parser so that the problematic parentheses appear next to each other: it&#39;s worth
        mentioning that, for parsers without backtracking, we can always reorder the branches without
        consequence; the restriction is that backtracking parsers cannot move ahead of their paired up branch.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type-atom&gt;`</span><span> = ( </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                         | (</span><span class="type-name">ListConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>)
                         | </span><span class="identifier">`&lt;var-id&gt;`</span><span> | (</span><span class="type-name">UnitTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
                         | </span><span class="type-name">ListTy</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;type&gt;`</span><span> &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
                         | </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ( (</span><span class="type-name">FunConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;-&gt;&quot;</span><span>)
                                         | </span><span class="type-name">TupleConTy</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))
                                         ) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                         | </span><span class="type-name">ParenTyOrTupleTy</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;type&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                         )</span></code></pre>
        <p>This parser is a bit neater, and now we can apply our favourite tricks from part 1 to resolve this
        <code>atomic</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;type-atom&gt;`</span><span> = ( </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                         | (</span><span class="type-name">ListConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>)
                         | </span><span class="identifier">`&lt;var-id&gt;`</span><span> | (</span><span class="type-name">UnitTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>)
                         | </span><span class="type-name">ListTy</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;type&gt;`</span><span> &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
                         | </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ( (</span><span class="type-name">FunConTy</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;-&gt;&quot;</span><span>)
                                  | </span><span class="type-name">TupleConTy</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))
                                  | </span><span class="type-name">ParenTyOrTupleTy</span><span>(</span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;type&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>))
                                  ) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
                         )</span></code></pre>
        <p>Nice! One down, three to go. Let&#39;s have a look at the two involving patterns together:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-naked&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">PatNaked</span><span>] =
    ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>)
    | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>) | (</span><span class="type-name">NilCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>) | </span><span class="identifier">`&lt;literal&gt;`</span><span> | (</span><span class="type-name">Wild</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;_&quot;</span><span>)
    | </span><span class="type-name">NestedPatOrPatTuple</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
    | </span><span class="type-name">PatList</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
    )
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-paren&gt;`</span><span> = </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-app&gt;`</span><span>) | </span><span class="identifier">`&lt;pat-naked&gt;`</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-app&gt;`</span><span> = </span><span class="type-name">PatApp</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>, </span><span class="identifier">some</span><span>(</span><span class="identifier">`&lt;pat-naked&gt;`</span><span>))
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-con&gt;`</span><span> = ( </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ((</span><span class="type-name">ConsCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>) | </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
                       | </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                       )</span></code></pre>
        <p>I&#39;ve omitted the <code>&lt;pat&gt;</code> rule here, since it&#39;s not relevant. Right, so the interaction of these rules
        is quite intricate! The <code>atomic</code> in <code>&lt;pat-paren&gt;</code> is there because <code>&lt;pat-app&gt;</code> reads a <code>&lt;pat-con&gt;</code>
        and <code>&lt;pat-naked&gt;</code> can also read one of those. Additionally, within <code>&lt;pat-naked&gt;</code>, the <code>atomic</code> is
        guarding against yet more parentheses ambiguity caused by <code>ConsCon</code>, <code>TupleCon</code>, and
        <code>NestedPatOrPatTuple</code>. Now, our first thought might be that we can eliminate the <code>atomic</code> within
        <code>&lt;pat-naked&gt;</code> with the same strategy we used for <code>&lt;type-con&gt;</code>; we certainly could, but <code>&lt;pat-con&gt;</code>
        is used in <em>two</em> places, so doing so will cause duplication in the parser. This is a trade-off:
        inlining <code>&lt;pat-con&gt;</code> will eliminate backtracking and make the parser more efficient, but that comes
        at the cost of increased code size; in this case, in fact, the backtracking is limited to a single
        character, which is relatively cheap, <em>and</em> the size of the rule is small, so inlining it will not
        increase the code size significantly. It doesn&#39;t really matter either way what we do, so let&#39;s
        reinforce our factoring skills and duplicate the code to eliminate the <code>atomic</code>!</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-naked&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">PatNaked</span><span>] =
    ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">`&lt;con-id&gt;`</span><span>
    | </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ((</span><span class="type-name">ConsCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>) | </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
    | </span><span class="type-name">NestedPatOrPatTuple</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
    | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>) | (</span><span class="type-name">NilCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>) | </span><span class="identifier">`&lt;literal&gt;`</span><span> | (</span><span class="type-name">Wild</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;_&quot;</span><span>)
    | </span><span class="type-name">PatList</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
    )
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-paren&gt;`</span><span> = </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-app&gt;`</span><span>) | </span><span class="identifier">`&lt;pat-naked&gt;`</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-app&gt;`</span><span> = </span><span class="type-name">PatApp</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>, </span><span class="identifier">some</span><span>(</span><span class="identifier">`&lt;pat-naked&gt;`</span><span>))
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-con&gt;`</span><span> = ( </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ((</span><span class="type-name">ConsCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>) | </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
                       | </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                       )</span></code></pre>
        <p>In the above parser, I inlined the parser and reorganised it to bring the offending sub-rules together.
        We know the drill by this point, let&#39;s factor that out:</p>
        <pre><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-naked&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">PatNaked</span><span>] =
    ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">`&lt;con-id&gt;`</span><span>
    | </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ( (</span><span class="type-name">ConsCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>)
             | </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))
             | </span><span class="type-name">NestedPatOrPatTuple</span><span>(</span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>))
             ) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
    | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>) | (</span><span class="type-name">NilCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>) | </span><span class="identifier">`&lt;literal&gt;`</span><span> | (</span><span class="type-name">Wild</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;_&quot;</span><span>)
    | </span><span class="type-name">PatList</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
    )
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-paren&gt;`</span><span> = </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-app&gt;`</span><span>) | </span><span class="identifier">`&lt;pat-naked&gt;`</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-app&gt;`</span><span> = </span><span class="type-name">PatApp</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>, </span><span class="identifier">some</span><span>(</span><span class="identifier">`&lt;pat-naked&gt;`</span><span>))
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-con&gt;`</span><span> = ( </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ((</span><span class="type-name">ConsCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>) | </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
                       | </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                       )</span></code></pre>
        <p>Nice, another <code>atomic</code> down! Now, what about the <code>atomic</code> in <code>&lt;pat-paren&gt;</code>? Well, it turns out
        that, by eliminating the first <code>atomic</code>, we&#39;ve stopped ourselves from being able to deal with this one!
        The reason is that we&#39;ve cannibalised the common <code>&lt;pat-con&gt;</code> structure into our factored parentheses
        in <code>&lt;pat-naked&gt;</code>: oops! This <code>atomic</code> is actually worse than the other one, since it can backtrack
        out of an entire <code>&lt;pat-con&gt;</code> as opposed to just a single <code>(</code>. So, could we undo what we&#39;ve just done
        and fix this one instead? We certainly could; but this transformation is very violent since
        <code>&lt;pat-naked&gt;</code> appears in other places in the parser. That being said, lets do it!</p>
        <p>The first step is to return to our old parser:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-naked&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">PatNaked</span><span>] =
    ( </span><span class="identifier">`&lt;var-id&gt;`</span><span> | </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>)
    | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>) | (</span><span class="type-name">NilCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>) | </span><span class="identifier">`&lt;literal&gt;`</span><span> | (</span><span class="type-name">Wild</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;_&quot;</span><span>)
    | </span><span class="type-name">NestedPatOrPatTuple</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
    | </span><span class="type-name">PatList</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
    )
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-paren&gt;`</span><span> = </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-app&gt;`</span><span>) | </span><span class="identifier">`&lt;pat-naked&gt;`</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-app&gt;`</span><span> = </span><span class="type-name">PatApp</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>, </span><span class="identifier">some</span><span>(</span><span class="identifier">`&lt;pat-naked&gt;`</span><span>))
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-con&gt;`</span><span> = ( </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ((</span><span class="type-name">ConsCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>) | </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
                       | </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                       )</span></code></pre>
        <p>Now, we know that the <code>&lt;pat-con&gt;</code> is the problematic bit here, so let&#39;s break the <code>&lt;pat-naked&gt;</code> into
        two rules:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-naked&gt;`</span><span> = </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>) | </span><span class="identifier">`&lt;pat-naked&#39;&gt;`</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-naked&#39;&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">PatNaked</span><span>] =
    ( </span><span class="identifier">`&lt;var-id&gt;`</span><span>
    | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>) | (</span><span class="type-name">NilCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>) | </span><span class="identifier">`&lt;literal&gt;`</span><span> | (</span><span class="type-name">Wild</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;_&quot;</span><span>)
    | </span><span class="type-name">NestedPatOrPatTuple</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
    | </span><span class="type-name">PatList</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
    )
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-paren&gt;`</span><span> = </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-app&gt;`</span><span>) | </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>) | </span><span class="identifier">`&lt;pat-naked&#39;&gt;`</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-app&gt;`</span><span> = </span><span class="type-name">PatApp</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>, </span><span class="identifier">some</span><span>(</span><span class="identifier">`&lt;pat-naked&gt;`</span><span>))
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-con&gt;`</span><span> = ( </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ((</span><span class="type-name">ConsCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>) | </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
                       | </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                       )</span></code></pre>
        <p>Now, notice that I&#39;ve inlined <code>&lt;pat-naked&gt;</code> into <code>&lt;pat-paren&gt;</code>. The reason I did this is to make it
        clear that the part we are trying to factor is the <code>&lt;pat-con&gt;</code>. In fact, let&#39;s do a little bit of
        shuffling and move it into <code>&lt;pat-app&gt;</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-paren&gt;`</span><span> = </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-app&gt;`</span><span>) | </span><span class="identifier">`&lt;pat-naked&#39;&gt;`</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-app&gt;`</span><span> = </span><span class="identifier">atomic</span><span>(</span><span class="type-name">PatApp</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>, </span><span class="identifier">some</span><span>(</span><span class="identifier">`&lt;pat-naked&gt;`</span><span>))) | </span><span class="identifier">`&lt;pat-con&gt;`</span></code></pre>
        <p>Now, the aim here is to smash those <code>&lt;pat-con&gt;</code>s together! We can introduce a new disambiguator bridge to
        handle this, and switch <code>some</code> for <code>many</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">PatAppIfNonEmpty</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">PatCon</span><span>, </span><span class="type-name">List</span><span>[</span><span class="type-name">PatNaked</span><span>], </span><span class="type-name">PatParen</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">con</span><span>: </span><span class="type-name">PatCon</span><span>, </span><span class="identifier">args</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">PatNaked</span><span>]): </span><span class="type-name">PatParen</span><span> = </span><span class="identifier">args</span><span> </span><span class="keyword">match</span><span> {
        </span><span class="keyword">case</span><span> </span><span class="type-name">Nil</span><span> =&gt; </span><span class="identifier">con</span><span>
        </span><span class="keyword">case</span><span> </span><span class="identifier">args</span><span> =&gt; </span><span class="type-name">PatApp</span><span>(</span><span class="identifier">con</span><span>, </span><span class="identifier">args</span><span>)
    }
}</span></code></pre>
        <p>Now, compared to the original <code>PatApp</code> bridge constructor, this one returns a <code>PatParen</code> instead of a
        <code>PatApp</code>. This is because that is the common supertype of <code>PatApp</code> and <code>PatCon</code>. Let&#39;s see what the
        parser looks like now:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-paren&gt;`</span><span> = </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;pat-app&gt;`</span><span>) | </span><span class="identifier">`&lt;pat-naked&#39;&gt;`</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-app&gt;`</span><span> = </span><span class="type-name">PatAppIfNonEmpty</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>, </span><span class="identifier">many</span><span>(</span><span class="identifier">`&lt;pat-naked&gt;`</span><span>))</span></code></pre>
        <p>Now, since we&#39;ve switched to a <code>many</code>, we can actually push both of our <code>atomic</code>s down into the
        <code>&lt;pat-con&gt;</code> and leave it at that:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-naked&gt;`</span><span> = </span><span class="identifier">`&lt;pat-con&gt;`</span><span> | </span><span class="identifier">`&lt;pat-naked&#39;&gt;`</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-naked&#39;&gt;`</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">PatNaked</span><span>] =
    ( </span><span class="identifier">`&lt;var-id&gt;`</span><span>
    | (</span><span class="type-name">UnitCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;()&quot;</span><span>) | (</span><span class="type-name">NilCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;[]&quot;</span><span>) | </span><span class="identifier">`&lt;literal&gt;`</span><span> | (</span><span class="type-name">Wild</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;_&quot;</span><span>)
    | </span><span class="type-name">NestedPatOrPatTuple</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
    | </span><span class="type-name">PatList</span><span>(</span><span class="string-literal">&quot;[&quot;</span><span> ~&gt; </span><span class="identifier">sepBy</span><span>(</span><span class="identifier">`&lt;pat&gt;`</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;]&quot;</span><span>)
    )
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-paren&gt;`</span><span> = </span><span class="identifier">`&lt;pat-app&gt;`</span><span> | </span><span class="identifier">`&lt;pat-naked&#39;&gt;`</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-app&gt;`</span><span> = </span><span class="type-name">PatAppIfNonEmpty</span><span>(</span><span class="identifier">`&lt;pat-con&gt;`</span><span>, </span><span class="identifier">many</span><span>(</span><span class="identifier">`&lt;pat-naked&gt;`</span><span>))
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-con&gt;`</span><span> = ( </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ((</span><span class="type-name">ConsCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>) | </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>))) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
                       | </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                       )</span></code></pre>
        <p>So, can we remove that last <code>atomic</code>? No. At least not without a collosal amount of very destructive
        refactoring of the grammar. What we can do, however, is make its scope ever so slightly smaller:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;pat-con&gt;`</span><span> = ( </span><span class="identifier">atomic</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; ((</span><span class="type-name">ConsCon</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;:&quot;</span><span>) | </span><span class="type-name">TupleCon</span><span>(</span><span class="identifier">countSome</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>)))) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>
                       | </span><span class="identifier">`&lt;con-id&gt;`</span><span>
                       )</span></code></pre>
        <p>All I&#39;ve done there is move it one parser to the left, that way, we commit to the branch as soon as
        we&#39;ve seen either a <code>,</code> or a <code>:</code> and can&#39;t backtrack out of the closing bracket. That&#39;s as good as
        we&#39;re going to get. A little unsatisfying, perhaps, but it&#39;s really such a minor point.</p>
        <p>So, now what? Well, we have one final <code>atomic</code> we can look at. And it&#39;s trickier than it looks.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">`&lt;declaration&gt;`</span><span> = </span><span class="type-name">Decl</span><span>(</span><span class="identifier">`&lt;var-id&gt;`</span><span>, </span><span class="string-literal">&quot;::&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;type&gt;`</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;clause&gt;`</span><span> =
    </span><span class="type-name">Clause</span><span>(</span><span class="identifier">`&lt;var-id&gt;`</span><span>, </span><span class="identifier">many</span><span>(</span><span class="identifier">`&lt;pat-naked&gt;`</span><span>), </span><span class="identifier">option</span><span>(</span><span class="identifier">`&lt;guard&gt;`</span><span>), </span><span class="string-literal">&quot;=&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;expr&gt;`</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;program&gt;`</span><span> =
    </span><span class="identifier">fully</span><span>(</span><span class="identifier">sepEndBy</span><span>(</span><span class="identifier">`&lt;data&gt;`</span><span> | </span><span class="identifier">atomic</span><span>(</span><span class="identifier">`&lt;declaration&gt;`</span><span>) | </span><span class="identifier">`&lt;clause&gt;`</span><span>, </span><span class="identifier">some</span><span>(</span><span class="type-name">NEWLINE</span><span>)))</span></code></pre>
        <p>I&#39;ve skipped out the irrelevant <code>&lt;data&gt;</code> parser here. So, from the outset, this <code>atomic</code> doesn&#39;t
        look so bad: both <code>&lt;declaration&gt;</code> and <code>&lt;clause&gt;</code> share a <code>&lt;var-id&gt;</code>. This, in theory, should be easy
        to factor out. The problem is the bridges: when we factor out <code>&lt;var-id&gt;</code> we no longer have the right
        shape to use their bridges. You might think that the solution is to introduce an <code>Either</code>, like we
        did with the <code>INT_OR_FLOAT</code> lexeme. This would work out ok, but is a little clunky. The new bridge
        factory would be dealing with <code>Either[Type, (List[PatNaked], Option[Expr], Expr)])]</code>. Let&#39;s start with
        this approach first, and then see an alternative that keeps the two bridges separate and avoids the
        tuple.</p>
        <pre><code class="nohighlight"><span class="comment">// These make use of `ast.Clause` because they are defined outside of `ast` (in this .md file)
</span><span class="keyword">type</span><span> </span><span class="type-name">PartialClause</span><span> = (</span><span class="type-name">List</span><span>[</span><span class="type-name">PatNaked</span><span>], </span><span class="type-name">Option</span><span>[</span><span class="type-name">Expr</span><span>], </span><span class="type-name">Expr</span><span>)
</span><span class="keyword">object</span><span> </span><span class="type-name">DeclOrClause</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">VarId</span><span>, </span><span class="type-name">Either</span><span>[</span><span class="type-name">Type</span><span>, </span><span class="type-name">PartialClause</span><span>], </span><span class="type-name">ProgramUnit</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">id</span><span>: </span><span class="type-name">VarId</span><span>, </span><span class="identifier">declOrClause</span><span>: </span><span class="type-name">Either</span><span>[</span><span class="type-name">Type</span><span>, </span><span class="type-name">PartialClause</span><span>]): </span><span class="type-name">ProgramUnit</span><span> =
        </span><span class="identifier">declOrClause</span><span> </span><span class="keyword">match</span><span> {
            </span><span class="keyword">case</span><span> </span><span class="type-name">Left</span><span>(</span><span class="identifier">ty</span><span>) =&gt; </span><span class="type-name">Decl</span><span>(</span><span class="identifier">id</span><span>, </span><span class="identifier">ty</span><span>)
            </span><span class="keyword">case</span><span> </span><span class="type-name">Right</span><span>((</span><span class="identifier">args</span><span>, </span><span class="identifier">guard</span><span>, </span><span class="identifier">body</span><span>)) =&gt; </span><span class="identifier">ast</span><span>.</span><span class="type-name">Clause</span><span>(</span><span class="identifier">id</span><span>, </span><span class="identifier">args</span><span>, </span><span class="identifier">guard</span><span>, </span><span class="identifier">body</span><span>)
        }
}

</span><span class="keyword">object</span><span> </span><span class="type-name">Clause</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">VarId</span><span>, </span><span class="type-name">PartialClause</span><span>, </span><span class="type-name">Clause</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">id</span><span>: </span><span class="type-name">VarId</span><span>, </span><span class="identifier">partialClause</span><span>: </span><span class="type-name">PartialClause</span><span>): </span><span class="type-name">Clause</span><span> = {
        </span><span class="keyword">val</span><span> (</span><span class="identifier">args</span><span>, </span><span class="identifier">guard</span><span>, </span><span class="identifier">body</span><span>) = </span><span class="identifier">partialClause</span><span>
        </span><span class="identifier">ast</span><span>.</span><span class="type-name">Clause</span><span>(</span><span class="identifier">id</span><span>, </span><span class="identifier">args</span><span>, </span><span class="identifier">guard</span><span>, </span><span class="identifier">body</span><span>)
    }
}</span></code></pre>
        <p>Now, to make this work nicely, I&#39;m going to make use of the <code>&lt;+&gt;</code> combinator: pronounced &quot;sum&quot;, this parser works like <code>|</code> except it returns its result into a co-product (<code>Either</code>). Using
        this, we can define the factored <code>&lt;program&gt;</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">zipped</span><span>.</span><span class="type-name">Zipped3</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;declaration&gt;`</span><span> = </span><span class="string-literal">&quot;::&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;type&gt;`</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;partial-clause&gt;`</span><span> = (</span><span class="identifier">many</span><span>(</span><span class="identifier">`&lt;pat-naked&gt;`</span><span>), </span><span class="identifier">option</span><span>(</span><span class="identifier">`&lt;guard&gt;`</span><span>), </span><span class="string-literal">&quot;=&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;expr&gt;`</span><span>).</span><span class="identifier">zipped</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;clause&gt;`</span><span> = </span><span class="type-name">Clause</span><span>(</span><span class="identifier">`&lt;var-id&gt;`</span><span>, </span><span class="identifier">`&lt;partial-clause&gt;`</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;decl-or-clause&gt;`</span><span> = </span><span class="type-name">DeclOrClause</span><span>(</span><span class="identifier">`&lt;var-id&gt;`</span><span>, </span><span class="identifier">`&lt;declaration&gt;`</span><span> &lt;+&gt; </span><span class="identifier">`&lt;partial-clause&gt;`</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;program&gt;`</span><span> =
    </span><span class="identifier">fully</span><span>(</span><span class="identifier">sepEndBy</span><span>(</span><span class="identifier">`&lt;data&gt;`</span><span> | </span><span class="identifier">`&lt;decl-or-clause&gt;`</span><span>, </span><span class="identifier">some</span><span>(</span><span class="type-name">NEWLINE</span><span>)))</span></code></pre>
        <p>Why have we got two <code>&lt;clause&gt;</code>s? Well, we also need a <code>&lt;clause&gt;</code> for the <code>let</code>-expressions further
        down the parser. Now, there isn&#39;t anything wrong with this parser, and its a perfectly reasonable
        approach.</p>
        <p>Let&#39;s also take a look at the other way we could have done this. This time, we&#39;ll change
        the two original bridge constructors, but won&#39;t introduce a third:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">// These make use of `ast.Clause` because they are defined outside of `ast` (in this .md file)
</span><span class="keyword">object</span><span> </span><span class="type-name">Decl</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">Type</span><span>, </span><span class="type-name">VarId</span><span> =&gt; </span><span class="identifier">ast</span><span>.</span><span class="type-name">Decl</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">ty</span><span>: </span><span class="type-name">Type</span><span>): </span><span class="type-name">VarId</span><span> =&gt; </span><span class="identifier">ast</span><span>.</span><span class="type-name">Decl</span><span> = </span><span class="identifier">ast</span><span>.</span><span class="type-name">Decl</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">ty</span><span>)
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Clause</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge3</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">PatNaked</span><span>], </span><span class="type-name">Option</span><span>[</span><span class="type-name">Expr</span><span>], </span><span class="type-name">Expr</span><span>, </span><span class="type-name">VarId</span><span> =&gt; </span><span class="identifier">ast</span><span>.</span><span class="type-name">Clause</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">pats</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">PatNaked</span><span>], </span><span class="identifier">guard</span><span>: </span><span class="type-name">Option</span><span>[</span><span class="type-name">Expr</span><span>], </span><span class="identifier">rhs</span><span>: </span><span class="type-name">Expr</span><span>): </span><span class="type-name">VarId</span><span> =&gt; </span><span class="identifier">ast</span><span>.</span><span class="type-name">Clause</span><span> =
        </span><span class="identifier">ast</span><span>.</span><span class="type-name">Clause</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">pats</span><span>, </span><span class="identifier">guard</span><span>, </span><span class="identifier">rhs</span><span>)
}</span></code></pre>
        <p>This time, the two bridge constructors return functions that take the factored <code>VarId</code>. How does this
        change the parser?</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">`&lt;declaration&gt;`</span><span> = </span><span class="type-name">Decl</span><span>(</span><span class="string-literal">&quot;::&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;type&gt;`</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;partial-clause&gt;`</span><span> = </span><span class="type-name">Clause</span><span>(</span><span class="identifier">many</span><span>(</span><span class="identifier">`&lt;pat-naked&gt;`</span><span>), </span><span class="identifier">option</span><span>(</span><span class="identifier">`&lt;guard&gt;`</span><span>), </span><span class="string-literal">&quot;=&quot;</span><span> ~&gt; </span><span class="identifier">`&lt;expr&gt;`</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;clause&gt;`</span><span> = </span><span class="identifier">`&lt;var-id&gt;`</span><span> &lt;**&gt; </span><span class="identifier">`&lt;partial-clause&gt;`</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;decl-or-clause&gt;`</span><span> = </span><span class="identifier">`&lt;var-id&gt;`</span><span> &lt;**&gt; (</span><span class="identifier">`&lt;declaration&gt;`</span><span> | </span><span class="identifier">`&lt;partial-clause&gt;`</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">`&lt;program&gt;`</span><span> =
    </span><span class="identifier">fully</span><span>(</span><span class="identifier">sepEndBy</span><span>(</span><span class="identifier">`&lt;data&gt;`</span><span> | </span><span class="identifier">`&lt;decl-or-clause&gt;`</span><span>, </span><span class="identifier">some</span><span>(</span><span class="type-name">NEWLINE</span><span>)))</span></code></pre>
        <p>This also works completely fine. This time, we use <code>&lt;**&gt;</code> to apply the <code>&lt;var-id&gt;</code> to the partially
        built AST nodes. The advantage of this style is that it&#39;s a little more concise, and involves less
        unnecessary object construction. <em>However</em>, this version has a subtle flaw: suppose we wanted to
        add position information to the AST, then where would the <code>pos</code> go? The position information would
        be in the <code>var-id&gt;</code>, and we&#39;d have to extract it out in our bridges, for example:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">Decl</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">Type</span><span>, </span><span class="type-name">VarId</span><span> =&gt; </span><span class="type-name">Decl</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">ty</span><span>: </span><span class="type-name">Type</span><span>): </span><span class="type-name">VarId</span><span> =&gt; </span><span class="type-name">Decl</span><span> = </span><span class="identifier">v</span><span> =&gt; </span><span class="type-name">Decl</span><span>(</span><span class="identifier">v</span><span>, </span><span class="identifier">ty</span><span>)(</span><span class="identifier">v</span><span>.</span><span class="identifier">pos</span><span>)
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Clause</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge3</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">PatNaked</span><span>], </span><span class="type-name">Option</span><span>[</span><span class="type-name">Expr</span><span>], </span><span class="type-name">Expr</span><span>, </span><span class="type-name">VarId</span><span> =&gt; </span><span class="type-name">Clause</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">pats</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">PatNaked</span><span>], </span><span class="identifier">guard</span><span>: </span><span class="type-name">Option</span><span>[</span><span class="type-name">Expr</span><span>], </span><span class="identifier">rhs</span><span>: </span><span class="type-name">Expr</span><span>): </span><span class="type-name">VarId</span><span> =&gt; </span><span class="type-name">Clause</span><span> =
        </span><span class="identifier">v</span><span> =&gt; </span><span class="type-name">Clause</span><span>(</span><span class="identifier">v</span><span>, </span><span class="identifier">pats</span><span>, </span><span class="identifier">guard</span><span>, </span><span class="identifier">rhs</span><span>)(</span><span class="identifier">v</span><span>.</span><span class="identifier">pos</span><span>)
}</span></code></pre>
        <p>This is really brittle: it is relying on the <code>VarId</code> type having <em>and exposing</em> its position
        information. In contrast, here&#39;s how our other bridge factory would be transformed:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">DeclOrClause</span><span>
    </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos2</span><span>[</span><span class="type-name">VarId</span><span>, </span><span class="type-name">Either</span><span>[</span><span class="type-name">Type</span><span>, </span><span class="type-name">PartialClause</span><span>], </span><span class="type-name">ProgramUnit</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">id</span><span>: </span><span class="type-name">VarId</span><span>, </span><span class="identifier">declOrClause</span><span>: </span><span class="type-name">Either</span><span>[</span><span class="type-name">Type</span><span>, </span><span class="type-name">PartialClause</span><span>])
             (</span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)): </span><span class="type-name">ProgramUnit</span><span> = </span><span class="identifier">declOrClause</span><span> </span><span class="keyword">match</span><span> {
        </span><span class="keyword">case</span><span> </span><span class="type-name">Left</span><span>(</span><span class="identifier">ty</span><span>) =&gt; </span><span class="type-name">Decl</span><span>(</span><span class="identifier">id</span><span>, </span><span class="identifier">ty</span><span>)(</span><span class="identifier">pos</span><span>)
        </span><span class="keyword">case</span><span> </span><span class="type-name">Right</span><span>((</span><span class="identifier">args</span><span>, </span><span class="identifier">guard</span><span>, </span><span class="identifier">body</span><span>)) =&gt; </span><span class="type-name">Clause</span><span>(</span><span class="identifier">id</span><span>, </span><span class="identifier">args</span><span>, </span><span class="identifier">guard</span><span>, </span><span class="identifier">body</span><span>)(</span><span class="identifier">pos</span><span>)
    }
}</span></code></pre>
        <p>Much more straightforward, with no effect on any other bridge! This is worth considering if you do
        find yourself in this sort of position (no pun intended). That being said, the <code>&lt;**&gt;</code>-based version
        is slightly cleaner and a <em>tiny</em> bit more efficient. Regardless of which method we pick, however,
        that pesky <code>atomic</code> is gone! That leaves us in a final state with a <em>single</em> <code>atomic</code> which has a
        maximum backtrack of one character. In other words, this parser runs in linear-time. Excellent!</p>
        
        <h2 id="concluding-thoughts" class="section"><a class="anchor-link left" href="#concluding-thoughts"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">5 </span>Concluding Thoughts</h2>
        <p>In this (rather long) page, we&#39;ve explored the implementation of an entire parser for a subset of
        Haskell from <em>scratch</em>. We&#39;ve also seen a few techniques for factoring out common branches of the
        parser and applied everything we&#39;ve learnt so far to a real example. We are going to come back to
        this parser later in the series: we&#39;ve got to add better error messages, and deal with Haskell&#39;s
        indentation-sensitive off-side rule!</p>

        
<hr class="footer-rule"/>
<footer>
  Parsley is distributed under the <a href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a> license.
</footer>


      </main>

    </div>

  </body>

</html>