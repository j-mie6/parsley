<!DOCTYPE html>
<html lang="en">
  
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Typelevel Laika + Parsley Theme" />
    
    <title>The Parser Bridge Pattern</title>
    
    
    <meta name="author" content="parsley contributors"/>
    
    
    <meta name="description" content="How to abstract away result construction from parsing."/>
    
    
    
    <link rel="icon" sizes="32x32" type="image/svg+xml" href="../../icons/greenLeaf.svg"/>
    
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
    
    <link rel="stylesheet" type="text/css" href="../../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../../css/parsley-style.css" />
    <script src="../../helium/site/laika-helium.js"></script>
    <script src="../../helium/site/laika-versions.js"></script>
    <script>initVersions("../../", "/tutorial/parser-bridge-pattern.html", "4.6", null);</script>
    
    <script> /* for avoiding page load transitions */ </script>
  </head>


  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    <div class="menu-container version-menu">
      <a class="text-link menu-toggle" href="#">Version 4.6.x</a>
      <nav class="menu-content">
        <ul class="nav-list">
        </ul>
      </nav>
    </div>
  </div>

  <a class="icon-link svg-link" href="../../"><span class="leaf" title="Home"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 128 128" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M101.39,86.21c-14.25-5.91-22.34-4.3-28.47-2.5c-6.5,1.91-12.31,8.58-12.31,8.58s-1.93-0.58-5.04-0.51 c-1.49,0.04-2.67,0.28-3.54,0.54c2.64-5.99,4.51-12.08,7.57-18.76c1.95-0.81,4.63-1.86,6.35-2.23c2.96-0.64,6.45-0.84,6.45-0.84 c0.82,0.64,2,1.39,3.69,2.23c9.56,4.78,21.5,2.16,27.35-0.16c8.13-3.23,20.21-12.95,20.21-13.69s-5.5-3.38-13.32-5.71 c-7.82-2.33-18.27-2.44-26.21,0.95c-7.28,3.11-10.67,8.58-12.54,11.86c0,0-2.9,0.46-5,0.82c-1.56,0.27-2.96,0.64-4.07,0.99 c0.22-0.4,0.45-0.81,0.68-1.21C67.77,58.61,72.83,52.5,77,48.2c5.87,0.55,17.89,0.35,27.62-8.46 c15.64-14.15,18.46-35.92,18.07-36.35S97.35,3.34,84.54,14.91c-12.19,11.01-11.97,25.4-11.4,30.69c-3.97,3.71-8.81,9.17-14.2,17.12 c-0.04-2.12-0.29-4.73-0.29-4.73s7.19-6.73,7.72-17.18c0.42-8.24-0.46-15.89-5-24.14c-3.56-6.43-6.53-8.03-7.06-7.93 c-0.93,0.19-5.33,7.06-8.03,13.63c-2.13,5.17-4.26,18.38-0.45,26.52s8.22,9.68,8.22,9.68s0.54,2.37,0.48,5.55 c-0.02,1.36-0.13,4.51-0.18,5.98c-3.57,6.32-5.96,12.07-8.23,17.22c-0.34-0.99-0.73-1.96-1.11-2.65c-1.16-2.11-1.59-2.85-1.59-2.85 s2.57-15.99-1.8-29.17C36.45,37,27.57,31.08,19.33,27.59C11.09,24.1,6.54,24.11,5.8,24.95c-1.08,1.23,1.37,4.33,1.59,11.31 c0.17,5.71,1.16,25.05,6.87,34.98s13.63,12.37,16.17,13.21c2.54,0.85,8.03,0.95,8.03,0.95s2.33,2.01,3.17,4.86 c0.39,1.31,0.78,2.92,1.09,4.27c-1.95,3.71-4.17,7-7.21,9.86c-5.01,4.71-13.09,7.94-13.09,7.94s-6.47-0.15-6.91,0.15 c-0.44,0.29-1.73,3.53,0.69,7.51c2,3.29,5.05,4.12,6.08,4.26c1.03,0.15,2.94-4.27,3.68-4.86c0.74-0.59,9.43-3.93,15.6-10.74 c2.83-3.13,5.02-6.16,6.81-9.17c1.65-1.01,4.07-2.17,6.72-2.31c2.64-0.15,4.94,1.12,4.94,1.12s2.22,9.16,12.15,13 c12.5,4.83,25.83,0.61,31.64-1.4c5.81-2,19.83-8.42,19.94-10.22C123.86,97.87,115.66,92.13,101.39,86.21z"/>
  </g>
</svg></span></a>

  <div class="row links">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.6.1/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.6.1/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../../downloads.html">Documentation Downloads</a></li>
    <li class="level1 nav-leaf"><a href="../../home.html">Home</a></li>
    <li class="level1 nav-leaf"><a href="../faq.html">FAQ</a></li>
    <li class="level1 nav-leaf"><a href="../cheatsheet.html">Cheatsheet</a></li>
    <li class="level1 nav-node"><a href="../api-guide/">Understanding the API</a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/Parsley.html"><code>parsley.Parsley</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/character.html"><code>parsley.character</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/combinator.html"><code>parsley.combinator</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/generic.html"><code>parsley.generic</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/syntax.html"><code>parsley.syntax</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/position.html"><code>parsley.position</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/state.html"><code>parsley.state</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/debug.html"><code>parsley.debug</code></a></li>
    <li class="level2 nav-header"><code>parsley.expr</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/chain.html"><code>chain</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/infix.html"><code>infix</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/precedence.html"><code>precedence</code></a></li>
    <li class="level2 nav-header"><code>parsley.token</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/Lexer.html"><code>Lexer</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/descriptions.html"><code>descriptions</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/errors.html"><code>errors</code></a></li>
    <li class="level2 nav-header"><code>parsley.errors</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/combinator.html"><code>combinator</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/patterns.html"><code>patterns</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/ErrorBuilder.html"><code>ErrorBuilder</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/tokenextractors.html"><code>tokenextractors</code></a></li>
    <li class="level1 nav-node"><a href="index.html">Parser Combinator Tutorial</a></li>
    <li class="level2 nav-leaf"><a href="basics-of-combinators.html">Basics of Combinators</a></li>
    <li class="level2 nav-leaf"><a href="building-expression-parsers.html">Building Expression Parsers</a></li>
    <li class="level2 nav-leaf"><a href="effective-whitespace-parsing.html">Effective Whitespace Parsing</a></li>
    <li class="level2 nav-leaf"><a href="effective-lexing.html">Effective Lexing</a></li>
    <li class="level2 active nav-leaf"><a href="#">The Parser Bridge Pattern</a></li>
    <li class="level2 nav-leaf"><a href="interlude-1-haskell.html">Interlude 1: Building a Parser for Haskell</a></li>
    <li class="level2 nav-leaf"><a href="customising-error-messages.html">Customising Error Messages</a></li>
    <li class="level2 nav-leaf"><a href="advanced-error-messages.html">Advanced Error Messages</a></li>
    <li class="level1 nav-header">Related Projects</li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/parsley-cats">parsley-cats</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/gigaparsec">gigaparsec (Haskell)</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#">The Parser Bridge Pattern</a></p>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="#the-parser-bridge-pattern-2"><span class="section-number">1 </span>The <em>Parser Bridge</em> Pattern</a></li>
    <li class="level1 nav-leaf"><a href="#reducing-boilerplate-with-generic-bridge-traits"><span class="section-number">2 </span>Reducing Boilerplate with <em><strong>Generic Bridge Traits</strong></em></a></li>
    <li class="level1 nav-node"><a href="#singleton-bridge-for-precedence-ops"><span class="section-number">3 </span><em>Singleton Bridge</em> for Precedence Ops</a></li>
    <li class="level2 nav-leaf"><a href="#abstracting-one-more-time"><span class="section-number">3.1 </span>Abstracting One More Time</a></li>
    <li class="level1 nav-leaf"><a href="#the-final-parser"><span class="section-number">4 </span>The Final Parser</a></li>
  </ul>

  <p class="footer"><a href="https://github.com/j-mie6/parsley/blob/master/docs/tutorial/parser-bridge-pattern.md"><i class="icofont-laika edit" title="Edit">&#xef10;</i>Source for this page</a></p>
</nav>


      <main class="content">

        <h1 id="the-parser-bridge-pattern-1" class="title">The Parser Bridge Pattern</h1>
        <div class="callout info">
          <i class="icofont-laika info">&#xef4e;</i>
          <p>The first part of this page helps to motivate the <em>Parser Bridge</em> pattern, and
          the second part shows how to implement it from scratch. This is useful to know,
          but the API Guide <a href="../api-guide/generic.html">Generic Bridges</a> page can get you
          started with the technique faster. The latter parts of this page can be helpful
          when the generic bridges no longer suffice.</p>
        </div>
        <p>By this point, we&#39;ve seen how to effectively build expression parsers, lexers, and how to handle
        whitespace in a clean way. However, something we&#39;ve not touched on yet is how to encode the position
        information into any data-types produced by our parsers. In fact, the way we can build our results
        from our parsers can be greatly improved. We&#39;ll focus on expanding the same parser from the previous
         pages, since in its current form it has a variety of different types of constructors. What I will
         do, however it expand it with some basic <code>let</code>-binding expressions. We&#39;ll use the same <code>lexer</code>
         object as before, but I will add the keywords <code>let</code> and <code>in</code> to the keyword set. Previously, the
         grammar we were working with would have been:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span>&lt;</span><span class="identifier">number</span><span>&gt;     ::= ...
&lt;</span><span class="identifier">identifier</span><span>&gt; ::= ...
&lt;</span><span class="identifier">atom</span><span>&gt;       ::= </span><span class="string-literal">&#39;(&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt; </span><span class="string-literal">&#39;)&#39;</span><span> | &lt;</span><span class="identifier">number</span><span>&gt; | &lt;</span><span class="identifier">identifier</span><span>&gt;
&lt;</span><span class="identifier">negated</span><span>&gt;    ::= </span><span class="string-literal">&#39;negate&#39;</span><span> &lt;</span><span class="identifier">negated</span><span>&gt; | &lt;</span><span class="identifier">atom</span><span>&gt;
&lt;</span><span class="identifier">term</span><span>&gt;       ::= &lt;</span><span class="identifier">term</span><span>&gt; </span><span class="string-literal">&#39;*&#39;</span><span> &lt;</span><span class="identifier">atom</span><span>&gt; | &lt;</span><span class="identifier">atom</span><span>&gt;
&lt;</span><span class="identifier">expr</span><span>&gt;       ::= &lt;</span><span class="identifier">expr</span><span>&gt; (</span><span class="string-literal">&#39;+&#39;</span><span> | </span><span class="string-literal">&#39;-&#39;</span><span>) &lt;</span><span class="identifier">term</span><span>&gt; | &lt;</span><span class="identifier">term</span><span>&gt;</span></code></pre>
        <p>We&#39;ll extend this to include a let syntax as follows:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span>&lt;</span><span class="identifier">let</span><span>-</span><span class="identifier">binding</span><span>&gt; ::= </span><span class="string-literal">&#39;let&#39;</span><span> &lt;</span><span class="identifier">bindings</span><span>&gt; </span><span class="string-literal">&#39;in&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt; | &lt;</span><span class="identifier">expr</span><span>&gt;
&lt;</span><span class="identifier">bindings</span><span>&gt;    ::= &lt;</span><span class="identifier">binding</span><span>&gt; [</span><span class="string-literal">&#39;;&#39;</span><span> [&lt;</span><span class="identifier">bindings</span><span>&gt;]]
&lt;</span><span class="identifier">binding</span><span>&gt;     ::= &lt;</span><span class="identifier">identifier</span><span>&gt; </span><span class="string-literal">&#39;=&#39;</span><span> &lt;</span><span class="identifier">let</span><span>-</span><span class="identifier">binding</span><span>&gt;</span></code></pre>
        <p>This will allow us to write programs like:</p>
        <pre><code>let x = 10;
    y = let z = x + 4 in z * z;
in x * y</code></pre>
        <p>Now let&#39;s see how this changes the parser:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>

</span><span class="keyword">object</span><span> </span><span class="identifier">ast</span><span> {
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">LetExpr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Let</span><span>(</span><span class="identifier">bindings</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Binding</span><span>], </span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">LetExpr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Binding</span><span>(</span><span class="identifier">v</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">x</span><span>: </span><span class="type-name">LetExpr</span><span>)

    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">LetExpr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Add</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Mul</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Sub</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Neg</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Num</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">BigInt</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Var</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">String</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
}

</span><span class="keyword">object</span><span> </span><span class="identifier">expressions</span><span> {
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.{</span><span class="identifier">precedence</span><span>, </span><span class="type-name">Ops</span><span>, </span><span class="type-name">InfixL</span><span>, </span><span class="type-name">Prefix</span><span>}
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">sepEndBy1</span><span>
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">lift</span><span>.</span><span class="type-name">Lift2</span><span>

    </span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">implicitSymbol</span><span>
    </span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.{</span><span class="identifier">number</span><span>, </span><span class="identifier">fully</span><span>, </span><span class="identifier">identifier</span><span>}
    </span><span class="keyword">import</span><span> </span><span class="identifier">ast</span><span>.</span><span class="identifier">_</span><span>

    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">atom</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Expr</span><span>] =
        </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">expr</span><span> &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span> | </span><span class="identifier">number</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Num</span><span>) | </span><span class="identifier">identifier</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Var</span><span>)
    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span> = </span><span class="identifier">precedence</span><span>[</span><span class="type-name">Expr</span><span>](</span><span class="identifier">atom</span><span>)(
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">Prefix</span><span>)(</span><span class="string-literal">&quot;negate&quot;</span><span> </span><span class="identifier">as</span><span> </span><span class="type-name">Neg</span><span>),
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="string-literal">&quot;*&quot;</span><span> </span><span class="identifier">as</span><span> </span><span class="type-name">Mul</span><span>),
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="string-literal">&quot;+&quot;</span><span> </span><span class="identifier">as</span><span> </span><span class="type-name">Add</span><span>, </span><span class="string-literal">&quot;-&quot;</span><span> </span><span class="identifier">as</span><span> </span><span class="type-name">Sub</span><span>))

    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">binding</span><span> = </span><span class="type-name">Binding</span><span>.</span><span class="identifier">lift</span><span>(</span><span class="identifier">identifier</span><span>, </span><span class="string-literal">&quot;=&quot;</span><span> ~&gt; </span><span class="identifier">letExpr</span><span>)
    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">bindings</span><span> = </span><span class="identifier">sepEndBy1</span><span>(</span><span class="identifier">binding</span><span>, </span><span class="string-literal">&quot;;&quot;</span><span>)
    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">letExpr</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">LetExpr</span><span>] =
      </span><span class="type-name">Let</span><span>.</span><span class="identifier">lift</span><span>(</span><span class="string-literal">&quot;let&quot;</span><span> ~&gt; </span><span class="identifier">bindings</span><span>, </span><span class="string-literal">&quot;in&quot;</span><span> ~&gt; </span><span class="identifier">expr</span><span>) | </span><span class="identifier">expr</span><span>

    </span><span class="keyword">val</span><span> </span><span class="identifier">parser</span><span> = </span><span class="identifier">fully</span><span>(</span><span class="identifier">letExpr</span><span>)
}</span></code></pre>
        <p>So far, so good. I&#39;ve added a couple of now nodes to the AST, and three extra parser
        definitions. The only new thing here is the helpful <code>sepEndBy1</code> combinator, which is
        particularly good (along with its cousins, <code>sepBy1</code> and <code>endBy1</code>) at dealing with things like
        commas and semi-colons. However, if I now said that we need to encode position information into
        our language&#39;s AST then things are going to need to change.</p>
        <p>Let&#39;s start by adding the information into the AST. There is a trick to this depending on
        whether or not we want the information to be visible during pattern matches or not. Essentially,
        in Scala, if a second (or third etc) set of arguments is added to a <code>case class</code>, these
        arguments will not appear in the pattern match, but <em>are</em> required to build an instance. So
        we&#39;re going to add an extra argument to each constructor containing the position information
        like so:</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="identifier">ast</span><span> {
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">LetExpr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Let</span><span>(</span><span class="identifier">bindings</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Binding</span><span>], </span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">LetExpr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Binding</span><span>(</span><span class="identifier">v</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">x</span><span>: </span><span class="type-name">LetExpr</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>))

    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">LetExpr</span><span>
    </span><span class="comment">// We will add the position information to these nodes later
</span><span>    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Add</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Mul</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Sub</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Neg</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="comment">// But we can do these ones now
</span><span>    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Num</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">BigInt</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Var</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">String</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
}</span></code></pre>
        <p>Urgh. This isn&#39;t ideal, but realistically it&#39;s the best Scala has got. The real wart here is how
        this affects our parsers. Let&#39;s just take a look at a single parser and see what damage this
        will do:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">binding</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Binding</span><span>] = </span><span class="type-name">Binding</span><span>.</span><span class="identifier">lift</span><span>(</span><span class="identifier">identifier</span><span>, </span><span class="string-literal">&quot;=&quot;</span><span> ~&gt; </span><span class="identifier">letExpr</span><span>)</span></code></pre>
        <p>This no longer compiles for <em>several</em> reasons. The first is that <code>Binding.lift</code> doesn&#39;t work
        anymore, because <code>Binding</code> does not have the shape <code>(A, B) =&gt; C</code>. Instead it has the shape
        <code>(A, B) =&gt; C =&gt; D</code>, and Scala will be reluctant to make the translation. The second is that,
        even if we suppose that wasn&#39;t a problem, the type is going to be
        <code>Parsley[(Int, Int) =&gt; Binding]</code> instead of the desired <code>Parsley[Binding]</code>. If that wasn&#39;t already
        enough, there is the issue of having not dealt with the position anywhere either: what a mess!</p>
        <p>We&#39;ll keep pretending that the <code>Binding.lift</code> notation works for a second, and consider how to
        get that position information in and get it &quot;working&quot; again. The combinators for extracting
        position information are:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">position</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">line</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>]
</span><span class="keyword">val</span><span> </span><span class="identifier">col</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>]
</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: </span><span class="type-name">Parsley</span><span>[(</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)] = </span><span class="identifier">line</span><span>.</span><span class="identifier">zip</span><span>(</span><span class="identifier">col</span><span>)</span></code></pre>
        <p>So in this case, <code>pos</code> is what we are after, our first instinct might be to just add it as an
        extra parameter to the lift: <code>Binding.lift(identifier, &quot;=&quot; ~&gt; letExpr, pos)</code>, but <code>Binding</code> is
        curried, and lift takes an uncurried function. Instead, we can use <code>&lt;*&gt;</code> to apply a parser
        returning a function to its next argument:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">binding</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Binding</span><span>] = </span><span class="type-name">Binding</span><span>.</span><span class="identifier">lift</span><span>(</span><span class="identifier">identifier</span><span>, </span><span class="string-literal">&quot;=&quot;</span><span> ~&gt; </span><span class="identifier">letExpr</span><span>) &lt;*&gt; </span><span class="identifier">pos</span></code></pre>
        <p>Again, assuming that <code>Binding.lift</code> compiles with this snippet, this would compile fine.
        However, it&#39;s faulty, because the position of the binding will point <em>after</em> the binding itself
        is finished! Instead we need to swap it round so that the position is read <em>before</em> we start
        reading anything to do with the binding. This is a great reason why we always read trailing
        whitespace and not leading whitespace, as it keeps the position as close to the token as
        possible. To do the position first and binding second, we can use <code>&lt;**&gt;</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">binding</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Binding</span><span>] = </span><span class="identifier">pos</span><span> &lt;**&gt; </span><span class="type-name">Binding</span><span>.</span><span class="identifier">lift</span><span>(</span><span class="identifier">identifier</span><span>, </span><span class="string-literal">&quot;=&quot;</span><span> *&gt; </span><span class="identifier">letExpr</span><span>)</span></code></pre>
        <p>Now, to get it properly compiling again, we&#39;ll need to lean on the <code>zipped</code> notation instead, to
        help Scala&#39;s type inference figure out what we want.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">zipped</span><span>.</span><span class="type-name">Zipped2</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">binding</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Binding</span><span>] =
    </span><span class="identifier">pos</span><span> &lt;**&gt; (</span><span class="identifier">identifier</span><span>, </span><span class="string-literal">&quot;=&quot;</span><span> ~&gt; </span><span class="identifier">letExpr</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="type-name">Binding</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)</span></code></pre>
        <p>This <em>finally</em> compiles and works as intended. The <code>Binding(_, _) _</code> is desugared as follows:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="type-name">Binding</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span> = ((</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>) =&gt; </span><span class="type-name">Binding</span><span>(</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>)(</span><span class="identifier">_</span><span>))
                = ((</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>) =&gt; </span><span class="identifier">z</span><span> =&gt; </span><span class="type-name">Binding</span><span>(</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>)(</span><span class="identifier">z</span><span>))</span></code></pre>
        <p>This isn&#39;t particularly intuitive, but it might help to recognise that the similar <code>Binding(_, _)(_)</code>
        is actually equivalent to <code>(x, y, z) =&gt; Binding(x, y)(z)</code>, which is not what we want. At this
        point though, we can see what a pain this would be if we put this into the parser in all the
        places, especially in a bigger parser, it&#39;s very noisy and the <code>.zipped</code> notation is (in my
        opinion) slightly harder to read than the <code>.lift</code> notation: it is, however, required to get Scala
        to correctly annotate the types of our anonymous function for us, which would otherwise make the
        size of the code even <em>worse</em>.</p>
        
        <h2 id="the-parser-bridge-pattern-2" class="section"><a class="anchor-link left" href="#the-parser-bridge-pattern-2"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">1 </span>The <em>Parser Bridge</em> Pattern</h2>
        <p>The work we&#39;ve done is unavoidable, but that doesn&#39;t mean we can&#39;t move it somewhere more
        sensible and, at the same time, get a nice new syntax to abstract the way that AST nodes are
        constructed. I call this technique the <em>Parser Bridge</em> pattern, and it takes many shapes depending on
        how the AST nodes are made.</p>
        <p>The <em>Bridge</em> pattern is one of the classic &quot;Gang of Four&quot; structural design patterns. Its
        description is as follows:</p>
        <blockquote>Decouple an abstraction from its implementation so that the two can vary independently.</blockquote>
        <p>This is roughly the intent of the <em>Parser Bridge</em> pattern, which is defined as:</p>
        <blockquote>Separate the construction of an AST node and metadata collection by using bridge constructors
        in the parser.</blockquote>
        <p>In practice though, this can be used for more general decoupling of the AST from the parser, which
        we will also see examples of (especially in the Haskell interlude!). We&#39;ll start exploring this
        pattern, and the associated terminology, with the let binding, <code>Num</code> and <code>Var</code> cases to get a
        feel for it, before figuring out how to adapt it for the operators.</p>
        <p>The general idea behind the pattern is to leverage Scala&#39;s syntactic sugar for <code>apply</code> methods.
        If you&#39;re unaware, <code>apply</code> methods get sugared into &quot;function call&quot; syntax. It is, in fact, how
        <code>case class</code>es don&#39;t require you to write a <code>new</code> keyword to build them: instead, the compiler
        has generated an <code>apply</code> method on each class&#39; <em>companion object</em> (more on this later!). Basically,
        we are going to follow suit, but tailor our <code>apply</code> method to work on parsers instead of values!
        These <code>apply</code> methods are referred to as <strong><em>bridge constructors</em></strong>. Let&#39;s get working within the
        <code>ast</code> object:</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="identifier">ast</span><span> {
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">position</span><span>.</span><span class="identifier">pos</span><span>
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">zipped</span><span>.</span><span class="type-name">Zipped2</span><span>

    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">LetExpr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Let</span><span>(</span><span class="identifier">bindings</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Binding</span><span>], </span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">LetExpr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Binding</span><span>(</span><span class="identifier">v</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">x</span><span>: </span><span class="type-name">LetExpr</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>))

    </span><span class="comment">// New code here!
</span><span>    </span><span class="keyword">object</span><span> </span><span class="type-name">Let</span><span> {
        </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">bindings</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Binding</span><span>]], </span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Expr</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Let</span><span>] =
            </span><span class="identifier">pos</span><span> &lt;**&gt; (</span><span class="identifier">bindings</span><span>, </span><span class="identifier">x</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="type-name">Let</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
    }
    </span><span class="keyword">object</span><span> </span><span class="type-name">Binding</span><span> {
        </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">v</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">String</span><span>], </span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">LetExpr</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Binding</span><span>] =
            </span><span class="identifier">pos</span><span> &lt;**&gt; (</span><span class="identifier">v</span><span>, </span><span class="identifier">x</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="type-name">Binding</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
    }

    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">LetExpr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Add</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Mul</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Sub</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Neg</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Num</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">BigInt</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Var</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">String</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>

    </span><span class="comment">// New code here!
</span><span>    </span><span class="keyword">object</span><span> </span><span class="type-name">Num</span><span> {
        </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">BigInt</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Num</span><span>] = </span><span class="identifier">pos</span><span> &lt;**&gt; </span><span class="identifier">x</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Num</span><span>(</span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
    }
    </span><span class="keyword">object</span><span> </span><span class="type-name">Var</span><span> {
        </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">String</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Var</span><span>] = </span><span class="identifier">pos</span><span> &lt;**&gt; </span><span class="identifier">x</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Var</span><span>(</span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
    }
}</span></code></pre>
        <p>Notice how the structure of the new <code>apply</code> bridge constructors mirror the shape and type of the
        companion class&#39; constructor: where <code>Binding</code> requires a <code>String</code>, a <code>LetExpr</code> and a position,
        <code>Binding.apply</code> requires a <code>Parsley[String]</code> and a <code>Parsley[LetExpr]</code>. Notice that the position is
        absent from the builder: this is the entire point! If we need to remove the position (or add a
        position to an existing node), we only need to make the change in the bridge constructor:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">pos</span><span> &lt;**&gt; (</span><span class="identifier">v</span><span>, </span><span class="identifier">x</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="type-name">Binding</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>) ===&gt; (</span><span class="identifier">v</span><span>, </span><span class="identifier">x</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="type-name">Binding</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>))</span></code></pre>
        <p>This makes it really easy to change!</p>
        <p>Now we can just use the bridge constructors in the main parser, and leave the
        work of building the data to the <code>apply</code> itself. The advantage, as I alluded to above, is that
        whether or not a position is required for a given node is not <em>at all</em> visible to the parser that
        uses its bridge: the bridge is the only place where this needs to be handled. The main parser
        itself now looks like this:</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="identifier">expressions</span><span> {
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.{</span><span class="identifier">precedence</span><span>, </span><span class="type-name">Ops</span><span>, </span><span class="type-name">InfixL</span><span>, </span><span class="type-name">Prefix</span><span>}
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">sepEndBy1</span><span>

    </span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">implicitSymbol</span><span>
    </span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.{</span><span class="identifier">number</span><span>, </span><span class="identifier">fully</span><span>, </span><span class="identifier">identifier</span><span>}
    </span><span class="keyword">import</span><span> </span><span class="identifier">ast</span><span>.</span><span class="identifier">_</span><span>

    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">atom</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Expr</span><span>] =
        </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">expr</span><span> &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span> | </span><span class="type-name">Num</span><span>(</span><span class="identifier">number</span><span>) | </span><span class="type-name">Var</span><span>(</span><span class="identifier">identifier</span><span>)
    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span> = </span><span class="identifier">precedence</span><span>[</span><span class="type-name">Expr</span><span>](</span><span class="identifier">atom</span><span>)(
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">Prefix</span><span>)(</span><span class="string-literal">&quot;negate&quot;</span><span> </span><span class="identifier">as</span><span> </span><span class="type-name">Neg</span><span>),
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="string-literal">&quot;*&quot;</span><span> </span><span class="identifier">as</span><span> </span><span class="type-name">Mul</span><span>),
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="string-literal">&quot;+&quot;</span><span> </span><span class="identifier">as</span><span> </span><span class="type-name">Add</span><span>, </span><span class="string-literal">&quot;-&quot;</span><span> </span><span class="identifier">as</span><span> </span><span class="type-name">Sub</span><span>))

    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">binding</span><span> = </span><span class="type-name">Binding</span><span>(</span><span class="identifier">identifier</span><span>, </span><span class="string-literal">&quot;=&quot;</span><span> ~&gt; </span><span class="identifier">letExpr</span><span>)
    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">bindings</span><span> = </span><span class="identifier">sepEndBy1</span><span>(</span><span class="identifier">binding</span><span>, </span><span class="string-literal">&quot;;&quot;</span><span>)
    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">letExpr</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">LetExpr</span><span>] =
      </span><span class="type-name">Let</span><span>(</span><span class="string-literal">&quot;let&quot;</span><span> ~&gt; </span><span class="identifier">bindings</span><span>, </span><span class="string-literal">&quot;in&quot;</span><span> ~&gt; </span><span class="identifier">expr</span><span>) | </span><span class="identifier">expr</span><span>

    </span><span class="keyword">val</span><span> </span><span class="identifier">parser</span><span> = </span><span class="identifier">fully</span><span>(</span><span class="identifier">letExpr</span><span>)
}</span></code></pre>
        <p>As you can see, <em>very</em> little has changed. In fact, it&#39;s actually gotten slightly <em>nicer</em>. We no
        longer need to worry about <code>map</code> or <code>lift</code> inside this parser, and can focus more on the
        structure itself. Just to make it <strong>very</strong> clear: if we change our requirements for which nodes do
        and do not require positions, this parser will <strong>not change</strong> in the slightest. There is still some
        work left to do however: first it would be nice if the boilerplate introduced by each bridge
        could be reduced; and position information needs to be added to <code>Add</code>, <code>Mul</code>, <code>Sub</code>, and <code>Neg</code>.</p>
        
        <h2 id="reducing-boilerplate-with-generic-bridge-traits" class="section"><a class="anchor-link left" href="#reducing-boilerplate-with-generic-bridge-traits"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">2 </span>Reducing Boilerplate with <em><strong>Generic Bridge Traits</strong></em></h2>
        <p>So far, we&#39;ve constructed four bridge constructors:</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">Let</span><span> {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">bindings</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Binding</span><span>]], </span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Expr</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Let</span><span>] =
        </span><span class="identifier">pos</span><span> &lt;**&gt; (</span><span class="identifier">bindings</span><span>, </span><span class="identifier">x</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="type-name">Let</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Binding</span><span> {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">v</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">String</span><span>], </span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">LetExpr</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Binding</span><span>] =
        </span><span class="identifier">pos</span><span> &lt;**&gt; (</span><span class="identifier">v</span><span>, </span><span class="identifier">x</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="type-name">Binding</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Num</span><span> {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">BigInt</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Num</span><span>] = </span><span class="identifier">pos</span><span> &lt;**&gt; </span><span class="identifier">x</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Num</span><span>(</span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Var</span><span> {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">String</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Var</span><span>] = </span><span class="identifier">pos</span><span> &lt;**&gt; </span><span class="identifier">x</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Var</span><span>(</span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
}</span></code></pre>
        <p>As the number of AST nodes increase, it becomes more tedious to continue to define bridge
        constructors and functions by hand. This can be improved by so-called <strong><em>generic bridge traits</em></strong>.
        This idea leverages the common structure between each of the bridge constructors and tries to build
        a recipe for eliminating the boilerplate. This leverages another classic OOP design pattern, called
        the <em>Template Method</em> pattern:</p>
        <blockquote>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. <em>Template
        Method</em> lets subclassses redefine certain steps of an algorithm (called hooks) without changing
        the algorithm&#39;s structure.</blockquote>
        <p>Let&#39;s first desuguar these four objects a little to make the shared structure between <code>Let</code> and
        <code>Binding</code> as well as between <code>Num</code> and <code>Var</code> more apparent:</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">Let</span><span> {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">bindings</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Binding</span><span>]], </span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Expr</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Let</span><span>] =
        </span><span class="identifier">pos</span><span> &lt;**&gt; (</span><span class="identifier">bindings</span><span>, </span><span class="identifier">x</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="type-name">Let</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Binding</span><span> {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">v</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">String</span><span>], </span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">LetExpr</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Binding</span><span>] =
        </span><span class="identifier">pos</span><span> &lt;**&gt; (</span><span class="identifier">v</span><span>, </span><span class="identifier">x</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="type-name">Binding</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Num</span><span> {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">BigInt</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Num</span><span>] = </span><span class="identifier">pos</span><span> &lt;**&gt; </span><span class="identifier">x</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Num</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Var</span><span> {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">String</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Var</span><span>] = </span><span class="identifier">pos</span><span> &lt;**&gt; </span><span class="identifier">x</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Var</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
}</span></code></pre>
        <p>This exposes the fact that <code>Let()</code> is just sugar for <code>Let.apply()</code>, which is automatically
        generated by the compiler into companion objects. Now simplify the scoping of these <code>apply</code> calls:</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">Let</span><span> {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">bindings</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Binding</span><span>]], </span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Expr</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Let</span><span>] =
        </span><span class="identifier">pos</span><span> &lt;**&gt; (</span><span class="identifier">bindings</span><span>, </span><span class="identifier">x</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Binding</span><span> {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">v</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">String</span><span>], </span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">LetExpr</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Binding</span><span>] =
        </span><span class="identifier">pos</span><span> &lt;**&gt; (</span><span class="identifier">v</span><span>, </span><span class="identifier">x</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Num</span><span> {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">BigInt</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Num</span><span>] = </span><span class="identifier">pos</span><span> &lt;**&gt; </span><span class="identifier">x</span><span>.</span><span class="identifier">map</span><span>(</span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
}
</span><span class="keyword">object</span><span> </span><span class="type-name">Var</span><span> {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">String</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Var</span><span>] = </span><span class="identifier">pos</span><span> &lt;**&gt; </span><span class="identifier">x</span><span>.</span><span class="identifier">map</span><span>(</span><span class="keyword">this</span><span> .</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
}</span></code></pre>
        <p>Now, the shared structure of each of these bridge constructors should hopefully be much clearer.
        That doesn&#39;t mean they are all identical, indeed, the types vary, as do the arities of the
        constructors themselves. But there is enough structure here to extract some shiny new bridge
        template traits:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">ParserBridgePos1</span><span>[-</span><span class="type-name">A</span><span>, +</span><span class="type-name">B</span><span>] {
    </span><span class="comment">// this is called the &quot;hook&quot;: it&#39;s the hole in the template that must be implemented
</span><span>    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>)(</span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)): </span><span class="type-name">B</span><span>
    </span><span class="comment">// this is the template method, in this case the template for the bridge constructor
</span><span>    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">B</span><span>] = </span><span class="identifier">pos</span><span> &lt;**&gt; </span><span class="identifier">x</span><span>.</span><span class="identifier">map</span><span>(</span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
}

</span><span class="keyword">trait</span><span> </span><span class="type-name">ParserBridgePos2</span><span>[-</span><span class="type-name">A</span><span>, -</span><span class="type-name">B</span><span>, +</span><span class="type-name">C</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">B</span><span>)(</span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)): </span><span class="type-name">C</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>], </span><span class="identifier">y</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">B</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">C</span><span>] =
        </span><span class="identifier">pos</span><span> &lt;**&gt; (</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
}</span></code></pre>
        <p>These are the two generic bridge traits that provide the implementations of our bridge constructors.
        Obviously, there are many many more possible such traits. At the very least, it is also useful to
        have &quot;plain&quot; versions that do not interact with positions at all also (these are provided by <code>parsley</code>
        within <code>parsley.generic</code>):</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">ParserBridge1</span><span>[-</span><span class="type-name">A</span><span>, +</span><span class="type-name">B</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>): </span><span class="type-name">B</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">B</span><span>] = </span><span class="identifier">x</span><span>.</span><span class="identifier">map</span><span>(</span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>))
}

</span><span class="keyword">trait</span><span> </span><span class="type-name">ParserBridge2</span><span>[-</span><span class="type-name">A</span><span>, -</span><span class="type-name">B</span><span>, +</span><span class="type-name">C</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">B</span><span>): </span><span class="type-name">C</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>], </span><span class="identifier">y</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">B</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">C</span><span>] =
        (</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>))
}</span></code></pre>
        <p>So, how are these used to help remove the boilerplate? Well, the companion objects for each of the
        AST nodes will simply extend one of the generic bridge traits as appropriate:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">Let</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos2</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Binding</span><span>], </span><span class="type-name">Expr</span><span>, </span><span class="type-name">LetExpr</span><span>]
</span><span class="keyword">object</span><span> </span><span class="type-name">Binding</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos2</span><span>[</span><span class="type-name">String</span><span>, </span><span class="type-name">LetExpr</span><span>, </span><span class="type-name">Binding</span><span>]
</span><span class="keyword">object</span><span> </span><span class="type-name">Num</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos1</span><span>[</span><span class="type-name">BigInt</span><span>, </span><span class="type-name">Num</span><span>]
</span><span class="keyword">object</span><span> </span><span class="type-name">Var</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos1</span><span>[</span><span class="type-name">String</span><span>, </span><span class="type-name">Var</span><span>]</span></code></pre>
        <p>Ahhhhh, much better! If position information was removed from say <code>Num</code>, then it would just have
        to extend <code>ParserBridge1</code> instead, and no more changes need to be made!</p>
        
        <h2 id="singleton-bridge-for-precedence-ops" class="section"><a class="anchor-link left" href="#singleton-bridge-for-precedence-ops"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3 </span><em>Singleton Bridge</em> for Precedence Ops</h2>
        <p>With the basics of bridge constructors (as well as generic bridge traits) under our belt, let&#39;s
        explore how we might add position information to the arithmetic operators, which are used within
        the <code>precedence</code> combinator. The problem with these is that the arguments to the bridge constructors
        are not &quot;immediately&quot; available when we use them: it&#39;s the <code>precedence</code> combinator that provides
        the arguments internally. This means we can&#39;t use the same shape of bridge here. That said, there
        are a couple of different ways we can implement a bridge constructor for the operators:</p>
        <p>1) Treat them just the same as <code>Num</code>, <code>Var</code>, <code>Let</code>, and <code>Binding</code> and create a bridge constructor
           that looks like <code>Neg(&quot;negate&quot;)</code>, <code>Mul(&quot;*&quot;)</code>, etc. This is the easiest, and they&#39;ll differ because
           of the type they return (they need to be parsers that return functions).
        2) Build a special combinator <code>from</code> (or <code>&lt;#</code>) that can transform the bridges for these operators into just
           looking like they do now. It would look like: <code>Neg from &quot;negate&quot;</code>, <code>Mul from &quot;*&quot;</code>, etc. This is
           slightly more effort to do, however I think it is more faithful to how these operators
           usually behave. The <em>Parser Bridge</em> pattern treats arguments to the builder as arguments to the
           data-type, but the argument to <code>Neg</code> isn&#39;t the <code>()</code> returned by <code>&quot;negate&quot;: Parsley[Unit]</code>, so
           <em>personally</em> I think it&#39;s a bit jarring to use (1).</p>
        <p>So that you can make the choice about which style you prefer, we&#39;ll go ahead and implement both,
        with <code>Mul</code> using style (1) and the rest using style (2).</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Mul</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>

</span><span class="keyword">object</span><span> </span><span class="type-name">Mul</span><span> {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">op</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Unit</span><span>]): </span><span class="type-name">Parsley</span><span>[(</span><span class="type-name">Expr</span><span>, </span><span class="type-name">Expr</span><span>) =&gt; </span><span class="type-name">Mul</span><span>] =
        </span><span class="identifier">pos</span><span>.</span><span class="identifier">map</span><span>[(</span><span class="type-name">Expr</span><span>, </span><span class="type-name">Expr</span><span>) =&gt; </span><span class="type-name">Mul</span><span>](</span><span class="identifier">p</span><span> =&gt; </span><span class="type-name">Mul</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>)(</span><span class="identifier">p</span><span>)) &lt;~ </span><span class="identifier">op</span><span>
}

</span><span class="comment">// or, alternatively, we can explicitly provide a new hook for our generic bridge trait:
</span><span class="keyword">object</span><span> </span><span class="type-name">Mul</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos1</span><span>[</span><span class="type-name">Unit</span><span>, (</span><span class="type-name">Expr</span><span>, </span><span class="type-name">Expr</span><span>) =&gt; </span><span class="type-name">Mul</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Unit</span><span>)(</span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)): (</span><span class="type-name">Expr</span><span>, </span><span class="type-name">Expr</span><span>) =&gt; </span><span class="type-name">Mul</span><span> = </span><span class="type-name">Mul</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>)(</span><span class="identifier">pos</span><span>)
}</span></code></pre>
        <p>Firstly, we can see this is a bit more effort than the previous bridge constructors. This is because
        there is nothing for scala&#39;s inference to &quot;latch&quot; onto, since we are returning a function and not
        providing the arguments here. While this is annoying, there isn&#39;t much we can do about it for this
        style. Interestingly, here we can also see an example of where the <code>apply</code> hook method can be
        overriden explicitly to adapt our existing bridge behaviour to a type that is <strong>not</strong> consistent
        with the AST nodes type itself: this can be useful!</p>
        <p>Let&#39;s see how style (2) compares. To accomplish this, we can think of the new <code>from</code> combinator as
        being another template method provided by our generic bridge traits:</p>
        <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">ParserBridgePos1</span><span>[-</span><span class="type-name">A</span><span>, +</span><span class="type-name">B</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>)(</span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)): </span><span class="type-name">B</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">B</span><span>] = </span><span class="identifier">pos</span><span> &lt;**&gt; </span><span class="identifier">x</span><span>.</span><span class="identifier">map</span><span>(</span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">from</span><span>(</span><span class="identifier">op</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="identifier">_</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>] =
        </span><span class="identifier">pos</span><span>.</span><span class="identifier">map</span><span>[</span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>](</span><span class="identifier">p</span><span> =&gt; </span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>)(</span><span class="identifier">p</span><span>)) &lt;~ </span><span class="identifier">op</span><span>
    </span><span class="keyword">final</span><span> </span><span class="keyword">def</span><span> &lt;#(</span><span class="identifier">op</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="identifier">_</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>] = </span><span class="keyword">this</span><span> </span><span class="identifier">from</span><span> </span><span class="identifier">op</span><span>
}

</span><span class="keyword">trait</span><span> </span><span class="type-name">ParserBridgePos2</span><span>[-</span><span class="type-name">A</span><span>, -</span><span class="type-name">B</span><span>, +</span><span class="type-name">C</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">B</span><span>)(</span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)): </span><span class="type-name">C</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>], </span><span class="identifier">y</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">B</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">C</span><span>] =
        </span><span class="identifier">pos</span><span> &lt;**&gt; (</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">from</span><span>(</span><span class="identifier">op</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="identifier">_</span><span>]): </span><span class="type-name">Parsley</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>) =&gt; </span><span class="type-name">C</span><span>] =
        </span><span class="identifier">pos</span><span>.</span><span class="identifier">map</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>) =&gt; </span><span class="type-name">C</span><span>](</span><span class="identifier">p</span><span> =&gt; </span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>)(</span><span class="identifier">p</span><span>)) &lt;* </span><span class="identifier">op</span><span>
    </span><span class="keyword">final</span><span> </span><span class="keyword">def</span><span> &lt;#(</span><span class="identifier">op</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="identifier">_</span><span>]): </span><span class="type-name">Parsley</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>) =&gt; </span><span class="type-name">C</span><span>] = </span><span class="keyword">this</span><span> </span><span class="identifier">from</span><span> </span><span class="identifier">op</span><span>
}</span></code></pre>
        <p>Now, by mixing in one of the generic bridge traits, we get two ways of using bridge constructors:
        the first, <code>apply</code>, allows for fully-saturated application of a constructor to its parser arguments;
        and the second, <code>from</code>, allows for fully-unsaturated application of a constructor to its arguments,
        whilst still handling the position tracking. You can imagine that partially-saturated bridge
        constructors can also be templated in a similar way, perhaps to fit some unconventional use-cases.
        In this case, here are the definitions of the companion objects for <code>Add</code>, <code>Sub</code> and <code>Neg</code> now:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Add</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Sub</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Neg</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>

</span><span class="keyword">object</span><span> </span><span class="type-name">Add</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos2</span><span>[</span><span class="type-name">Expr</span><span>, </span><span class="type-name">Expr</span><span>, </span><span class="type-name">Add</span><span>]
</span><span class="keyword">object</span><span> </span><span class="type-name">Sub</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos2</span><span>[</span><span class="type-name">Expr</span><span>, </span><span class="type-name">Expr</span><span>, </span><span class="type-name">Sub</span><span>]
</span><span class="keyword">object</span><span> </span><span class="type-name">Neg</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos1</span><span>[</span><span class="type-name">Expr</span><span>, </span><span class="type-name">Neg</span><span>]</span></code></pre>
        <p>To make it clear, this automatically gives us the option to use <code>Add(p, q)</code> <em>or</em> <code>Add from &quot;+&quot;</code>, and
        its the latter that we&#39;ll want to use inside the <code>precedence</code> combinator:</p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="identifier">expressions</span><span> {
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.{</span><span class="identifier">precedence</span><span>, </span><span class="type-name">Ops</span><span>, </span><span class="type-name">InfixL</span><span>, </span><span class="type-name">Prefix</span><span>}
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">sepEndBy1</span><span>

    </span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">implicitSymbol</span><span>
    </span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.{</span><span class="identifier">number</span><span>, </span><span class="identifier">fully</span><span>, </span><span class="identifier">identifier</span><span>}
    </span><span class="keyword">import</span><span> </span><span class="identifier">ast</span><span>.</span><span class="identifier">_</span><span>

    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">atom</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Expr</span><span>] =
        </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">expr</span><span> &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span> | </span><span class="type-name">Num</span><span>(</span><span class="identifier">number</span><span>) | </span><span class="type-name">Var</span><span>(</span><span class="identifier">identifier</span><span>)
    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span> = </span><span class="identifier">precedence</span><span>[</span><span class="type-name">Expr</span><span>](</span><span class="identifier">atom</span><span>)(
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">Prefix</span><span>)(</span><span class="type-name">Neg</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;negate&quot;</span><span>),
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="type-name">Mul</span><span>(</span><span class="string-literal">&quot;*&quot;</span><span>)),
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="type-name">Add</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;+&quot;</span><span>, </span><span class="type-name">Sub</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;-&quot;</span><span>))

    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">binding</span><span> = </span><span class="type-name">Binding</span><span>(</span><span class="identifier">identifier</span><span>, </span><span class="string-literal">&quot;=&quot;</span><span> ~&gt; </span><span class="identifier">letExpr</span><span>)
    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">bindings</span><span> = </span><span class="identifier">sepEndBy1</span><span>(</span><span class="identifier">binding</span><span>, </span><span class="string-literal">&quot;;&quot;</span><span>)
    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">letExpr</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">LetExpr</span><span>] =
      </span><span class="type-name">Let</span><span>(</span><span class="string-literal">&quot;let&quot;</span><span> ~&gt; </span><span class="identifier">bindings</span><span>, </span><span class="string-literal">&quot;in&quot;</span><span> ~&gt; </span><span class="identifier">expr</span><span>) | </span><span class="identifier">expr</span><span>

    </span><span class="keyword">val</span><span> </span><span class="identifier">parser</span><span> = </span><span class="identifier">fully</span><span>(</span><span class="identifier">letExpr</span><span>)
}</span></code></pre>
        
        <h3 id="abstracting-one-more-time" class="section"><a class="anchor-link left" href="#abstracting-one-more-time"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3.1 </span>Abstracting One More Time</h3>
        <p>In the refined definition of our generic bridge traits we supported the <em>Singleton Bridge</em>
        parsing design pattern by allowing the companion object itself to &quot;appear&quot; like a parser itself.
        However, if we peer in closely we can even spot some common structure between the two different
        <code>from</code> implementations from above:</p>
        <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">ParserBridgePos1</span><span>[-</span><span class="type-name">A</span><span>, +</span><span class="type-name">B</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>)(</span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)): </span><span class="type-name">B</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">from</span><span>(</span><span class="identifier">op</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="identifier">_</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>] =
        </span><span class="identifier">pos</span><span>.</span><span class="identifier">map</span><span>[</span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>](</span><span class="identifier">p</span><span> =&gt; </span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>)(</span><span class="identifier">p</span><span>)) &lt;* </span><span class="identifier">op</span><span>
    </span><span class="keyword">final</span><span> </span><span class="keyword">def</span><span> &lt;#(</span><span class="identifier">op</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="identifier">_</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>] = </span><span class="keyword">this</span><span> </span><span class="identifier">from</span><span> </span><span class="identifier">op</span><span>
}

</span><span class="keyword">trait</span><span> </span><span class="type-name">ParserBridgePos2</span><span>[-</span><span class="type-name">A</span><span>, -</span><span class="type-name">B</span><span>, +</span><span class="type-name">C</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">B</span><span>)(</span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)): </span><span class="type-name">C</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">from</span><span>(</span><span class="identifier">op</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="identifier">_</span><span>]): </span><span class="type-name">Parsley</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>) =&gt; </span><span class="type-name">C</span><span>] =
        </span><span class="identifier">pos</span><span>.</span><span class="identifier">map</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>) =&gt; </span><span class="type-name">C</span><span>](</span><span class="identifier">p</span><span> =&gt; </span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>)(</span><span class="identifier">p</span><span>)) &lt;* </span><span class="identifier">op</span><span>
    </span><span class="keyword">final</span><span> </span><span class="keyword">def</span><span> &lt;#(</span><span class="identifier">op</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="identifier">_</span><span>]): </span><span class="type-name">Parsley</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>) =&gt; </span><span class="type-name">C</span><span>] = </span><span class="keyword">this</span><span> </span><span class="identifier">from</span><span> </span><span class="identifier">op</span><span>
}</span></code></pre>
        <p>They are <em>almost</em> identical, except for the arity of the <code>apply</code> method found within the <code>map</code>.
        It&#39;s possible to abstract one more layer and introduce another couple of traits to help factor
        the common code:</p>
        <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">ParserSingletonBridgePos</span><span>[+</span><span class="type-name">A</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">con</span><span>(</span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)): </span><span class="type-name">A</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">from</span><span>(</span><span class="identifier">op</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="identifier">_</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="identifier">pos</span><span>.</span><span class="identifier">map</span><span>(</span><span class="keyword">this</span><span>.</span><span class="identifier">con</span><span>(</span><span class="identifier">_</span><span>)) &lt;* </span><span class="identifier">op</span><span>
    </span><span class="keyword">final</span><span> </span><span class="keyword">def</span><span> &lt;#(</span><span class="identifier">op</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="identifier">_</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="keyword">this</span><span> </span><span class="identifier">from</span><span> </span><span class="identifier">op</span><span>
}

</span><span class="keyword">trait</span><span> </span><span class="type-name">ParserBridgePos1</span><span>[-</span><span class="type-name">A</span><span>, +</span><span class="type-name">B</span><span>] </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserSingletonBridgePos</span><span>[</span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>)(</span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)): </span><span class="type-name">B</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">B</span><span>] = </span><span class="identifier">pos</span><span> &lt;**&gt; </span><span class="identifier">x</span><span>.</span><span class="identifier">map</span><span>(</span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
    </span><span class="keyword">override</span><span> </span><span class="keyword">final</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">con</span><span>(</span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)): </span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">B</span><span> = </span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>)(</span><span class="identifier">pos</span><span>)
}

</span><span class="keyword">trait</span><span> </span><span class="type-name">ParserBridgePos2</span><span>[-</span><span class="type-name">A</span><span>, -</span><span class="type-name">B</span><span>, +</span><span class="type-name">C</span><span>] </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserSingletonBridgePos</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>) =&gt; </span><span class="type-name">C</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">A</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">B</span><span>)(</span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)): </span><span class="type-name">C</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>], </span><span class="identifier">y</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">B</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">C</span><span>] =
        </span><span class="identifier">pos</span><span> &lt;**&gt; (</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>) </span><span class="identifier">_</span><span>)
    </span><span class="keyword">override</span><span> </span><span class="keyword">final</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">con</span><span>(</span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)): (</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>) =&gt; </span><span class="type-name">C</span><span> = </span><span class="keyword">this</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>)(</span><span class="identifier">pos</span><span>)
}</span></code></pre>
        <p>This provides a <em>modest</em> improvement over the original versions.</p>
        
        <h2 id="the-final-parser" class="section"><a class="anchor-link left" href="#the-final-parser"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">4 </span>The Final Parser</h2>
        <p>This is our final parser which compiles fine, and tracks positions correctly. As we can see, all of
        the work we needed to handle the position tracking, AST node construction, whitespace handling and
        lexing has all been abstracted elsewhere, leaving a clean core. For completeness, here&#39;s the entire
        file:</p>
        <p><details>
        <summary>The full completed parser</summary>
        <p></p>
        <pre><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="identifier">lexer</span><span> {
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">token</span><span>.{</span><span class="type-name">Lexer</span><span>, </span><span class="identifier">predicate</span><span>}
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">token</span><span>.</span><span class="identifier">descriptions</span><span>.{</span><span class="type-name">LexicalDesc</span><span>, </span><span class="type-name">NameDesc</span><span>, </span><span class="type-name">SymbolDesc</span><span>}

    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">desc</span><span> = </span><span class="type-name">LexicalDesc</span><span>.</span><span class="identifier">plain</span><span>.</span><span class="identifier">copy</span><span>(
        </span><span class="identifier">nameDesc</span><span> = </span><span class="type-name">NameDesc</span><span>.</span><span class="identifier">plain</span><span>.</span><span class="identifier">copy</span><span>(
            </span><span class="identifier">identifierStart</span><span> = </span><span class="identifier">predicate</span><span>.</span><span class="type-name">Basic</span><span>(</span><span class="identifier">_</span><span>.</span><span class="identifier">isLetter</span><span>),
            </span><span class="identifier">identifierLetter</span><span> = </span><span class="identifier">predicate</span><span>.</span><span class="type-name">Basic</span><span>(</span><span class="identifier">_</span><span>.</span><span class="identifier">isLetter</span><span>),
        ),
        </span><span class="identifier">symbolDesc</span><span> = </span><span class="type-name">SymbolDesc</span><span>.</span><span class="identifier">plain</span><span>.</span><span class="identifier">copy</span><span>(
            </span><span class="identifier">hardKeywords</span><span> = </span><span class="type-name">Set</span><span>(</span><span class="string-literal">&quot;negate&quot;</span><span>, </span><span class="string-literal">&quot;let&quot;</span><span>, </span><span class="string-literal">&quot;in&quot;</span><span>),
            </span><span class="identifier">hardOperators</span><span> = </span><span class="type-name">Set</span><span>(</span><span class="string-literal">&quot;*&quot;</span><span>, </span><span class="string-literal">&quot;+&quot;</span><span>, </span><span class="string-literal">&quot;-&quot;</span><span>),
        ),
    )

    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">lexer</span><span> = </span><span class="keyword">new</span><span> </span><span class="type-name">Lexer</span><span>(</span><span class="identifier">desc</span><span>)

    </span><span class="keyword">val</span><span> </span><span class="identifier">identifier</span><span> = </span><span class="identifier">lexer</span><span>.</span><span class="identifier">lexeme</span><span>.</span><span class="identifier">names</span><span>.</span><span class="identifier">identifier</span><span>
    </span><span class="keyword">val</span><span> </span><span class="identifier">number</span><span> = </span><span class="identifier">lexer</span><span>.</span><span class="identifier">lexeme</span><span>.</span><span class="identifier">natural</span><span>.</span><span class="identifier">decimal</span><span>

    </span><span class="keyword">def</span><span> </span><span class="declaration-name">fully</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">p</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]) = </span><span class="identifier">lexer</span><span>.</span><span class="identifier">fully</span><span>(</span><span class="identifier">p</span><span>)
    </span><span class="keyword">val</span><span> </span><span class="identifier">implicits</span><span> = </span><span class="identifier">lexer</span><span>.</span><span class="identifier">lexeme</span><span>.</span><span class="identifier">symbol</span><span>.</span><span class="identifier">implicits</span><span>
}

</span><span class="keyword">object</span><span> </span><span class="identifier">ast</span><span> {
    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">LetExpr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Let</span><span>(</span><span class="identifier">bindings</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Binding</span><span>], </span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">LetExpr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Binding</span><span>(</span><span class="identifier">v</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">x</span><span>: </span><span class="type-name">LetExpr</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>))

    </span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">LetExpr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Add</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Mul</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Sub</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Neg</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Num</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">BigInt</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
    </span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Var</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">String</span><span>)(</span><span class="keyword">val</span><span> </span><span class="identifier">pos</span><span>: (</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>)) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>

    </span><span class="keyword">object</span><span> </span><span class="type-name">Let</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos2</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Binding</span><span>], </span><span class="type-name">Expr</span><span>, </span><span class="type-name">LetExpr</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Binding</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos2</span><span>[</span><span class="type-name">String</span><span>, </span><span class="type-name">LetExpr</span><span>, </span><span class="type-name">Binding</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Add</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos2</span><span>[</span><span class="type-name">Expr</span><span>, </span><span class="type-name">Expr</span><span>, </span><span class="type-name">Add</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Mul</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos2</span><span>[</span><span class="type-name">Expr</span><span>, </span><span class="type-name">Expr</span><span>, </span><span class="type-name">Mul</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Sub</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos2</span><span>[</span><span class="type-name">Expr</span><span>, </span><span class="type-name">Expr</span><span>, </span><span class="type-name">Sub</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Neg</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos1</span><span>[</span><span class="type-name">Expr</span><span>, </span><span class="type-name">Neg</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Num</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos1</span><span>[</span><span class="type-name">BigInt</span><span>, </span><span class="type-name">Num</span><span>]
    </span><span class="keyword">object</span><span> </span><span class="type-name">Var</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridgePos1</span><span>[</span><span class="type-name">String</span><span>, </span><span class="type-name">Var</span><span>]
}

</span><span class="keyword">object</span><span> </span><span class="identifier">expressions</span><span> {
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.{</span><span class="identifier">precedence</span><span>, </span><span class="type-name">Ops</span><span>, </span><span class="type-name">InfixL</span><span>, </span><span class="type-name">Prefix</span><span>}
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">sepEndBy1</span><span>

    </span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">implicitSymbol</span><span>
    </span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.{</span><span class="identifier">number</span><span>, </span><span class="identifier">fully</span><span>, </span><span class="identifier">identifier</span><span>}
    </span><span class="keyword">import</span><span> </span><span class="identifier">ast</span><span>.</span><span class="identifier">_</span><span>

    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">atom</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Expr</span><span>] =
        </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">expr</span><span> &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span> | </span><span class="type-name">Num</span><span>(</span><span class="identifier">number</span><span>) | </span><span class="type-name">Var</span><span>(</span><span class="identifier">identifier</span><span>)
    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span> = </span><span class="identifier">precedence</span><span>[</span><span class="type-name">Expr</span><span>](</span><span class="identifier">atom</span><span>)(
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">Prefix</span><span>)(</span><span class="type-name">Neg</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;negate&quot;</span><span>),
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="type-name">Mul</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;*&quot;</span><span>),
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="type-name">Add</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;+&quot;</span><span>, </span><span class="type-name">Sub</span><span> </span><span class="identifier">from</span><span> </span><span class="string-literal">&quot;-&quot;</span><span>))

    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">binding</span><span> = </span><span class="type-name">Binding</span><span>(</span><span class="identifier">identifier</span><span>, </span><span class="string-literal">&quot;=&quot;</span><span> ~&gt; </span><span class="identifier">letExpr</span><span>)
    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">bindings</span><span> = </span><span class="identifier">sepEndBy1</span><span>(</span><span class="identifier">binding</span><span>, </span><span class="string-literal">&quot;;&quot;</span><span>)
    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">letExpr</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">LetExpr</span><span>] =
      </span><span class="type-name">Let</span><span>(</span><span class="string-literal">&quot;let&quot;</span><span> ~&gt; </span><span class="identifier">bindings</span><span>, </span><span class="string-literal">&quot;in&quot;</span><span> ~&gt; </span><span class="identifier">expr</span><span>) | </span><span class="identifier">expr</span><span>

    </span><span class="keyword">val</span><span> </span><span class="identifier">parser</span><span> = </span><span class="identifier">fully</span><span>(</span><span class="identifier">letExpr</span><span>)
}</span></code></pre>
        <p></p>
        </details></p>
        <p>As a last thought, it&#39;s worth reinforcing that the parser bridge pattern is just a guideline: it&#39;s
        free to take any shape you need it to, so experiment with what works well for your own structures.
        The value in it really in how easy you can separate the concerns of building a structure from the
        parser for the grammar. Of course, there is nothing to say you <em>have</em> to use it either. If you
        are fine with writing the bridge constructors inline in the parser, then do it! It might be that you
        find the extra lines of code in the file that defines your AST to be too grating. Really this is just
        another exercise in how leveraging Scala&#39;s functionality when we make our parsers can help us
        abstract and manage our code, once again showcasing the limitless flexibility combinators
        provide.</p>

        
<hr class="footer-rule"/>
<footer>
  Parsley is distributed under the <a href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a> license.
</footer>


      </main>

    </div>

  </body>

</html>