<!DOCTYPE html>
<html lang="en">
  
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Typelevel Laika + Parsley Theme" />
    
    <title>Building Expression Parsers</title>
    
    
    <meta name="author" content="parsley contributors"/>
    
    
    <meta name="description" content="How to handle left-recursion and precedence in a parser."/>
    
    
    
    <link rel="icon" sizes="32x32" type="image/svg+xml" href="../../icons/greenLeaf.svg"/>
    
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
    
    <link rel="stylesheet" type="text/css" href="../../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../../css/parsley-style.css" />
    <script src="../../helium/site/laika-helium.js"></script>
    <script src="../../helium/site/laika-versions.js"></script>
    <script>initVersions("../../", "/tutorial/building-expression-parsers.html", "4.5", null);</script>
    
    <script> /* for avoiding page load transitions */ </script>
  </head>


  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    <div class="menu-container version-menu">
      <a class="text-link menu-toggle" href="#">Version 4.5.x</a>
      <nav class="menu-content">
        <ul class="nav-list">
        </ul>
      </nav>
    </div>
  </div>

  <a class="icon-link svg-link" href="../../"><span class="leaf" title="Home"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 128 128" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M101.39,86.21c-14.25-5.91-22.34-4.3-28.47-2.5c-6.5,1.91-12.31,8.58-12.31,8.58s-1.93-0.58-5.04-0.51 c-1.49,0.04-2.67,0.28-3.54,0.54c2.64-5.99,4.51-12.08,7.57-18.76c1.95-0.81,4.63-1.86,6.35-2.23c2.96-0.64,6.45-0.84,6.45-0.84 c0.82,0.64,2,1.39,3.69,2.23c9.56,4.78,21.5,2.16,27.35-0.16c8.13-3.23,20.21-12.95,20.21-13.69s-5.5-3.38-13.32-5.71 c-7.82-2.33-18.27-2.44-26.21,0.95c-7.28,3.11-10.67,8.58-12.54,11.86c0,0-2.9,0.46-5,0.82c-1.56,0.27-2.96,0.64-4.07,0.99 c0.22-0.4,0.45-0.81,0.68-1.21C67.77,58.61,72.83,52.5,77,48.2c5.87,0.55,17.89,0.35,27.62-8.46 c15.64-14.15,18.46-35.92,18.07-36.35S97.35,3.34,84.54,14.91c-12.19,11.01-11.97,25.4-11.4,30.69c-3.97,3.71-8.81,9.17-14.2,17.12 c-0.04-2.12-0.29-4.73-0.29-4.73s7.19-6.73,7.72-17.18c0.42-8.24-0.46-15.89-5-24.14c-3.56-6.43-6.53-8.03-7.06-7.93 c-0.93,0.19-5.33,7.06-8.03,13.63c-2.13,5.17-4.26,18.38-0.45,26.52s8.22,9.68,8.22,9.68s0.54,2.37,0.48,5.55 c-0.02,1.36-0.13,4.51-0.18,5.98c-3.57,6.32-5.96,12.07-8.23,17.22c-0.34-0.99-0.73-1.96-1.11-2.65c-1.16-2.11-1.59-2.85-1.59-2.85 s2.57-15.99-1.8-29.17C36.45,37,27.57,31.08,19.33,27.59C11.09,24.1,6.54,24.11,5.8,24.95c-1.08,1.23,1.37,4.33,1.59,11.31 c0.17,5.71,1.16,25.05,6.87,34.98s13.63,12.37,16.17,13.21c2.54,0.85,8.03,0.95,8.03,0.95s2.33,2.01,3.17,4.86 c0.39,1.31,0.78,2.92,1.09,4.27c-1.95,3.71-4.17,7-7.21,9.86c-5.01,4.71-13.09,7.94-13.09,7.94s-6.47-0.15-6.91,0.15 c-0.44,0.29-1.73,3.53,0.69,7.51c2,3.29,5.05,4.12,6.08,4.26c1.03,0.15,2.94-4.27,3.68-4.86c0.74-0.59,9.43-3.93,15.6-10.74 c2.83-3.13,5.02-6.16,6.81-9.17c1.65-1.01,4.07-2.17,6.72-2.31c2.64-0.15,4.94,1.12,4.94,1.12s2.22,9.16,12.15,13 c12.5,4.83,25.83,0.61,31.64-1.4c5.81-2,19.83-8.42,19.94-10.22C123.86,97.87,115.66,92.13,101.39,86.21z"/>
  </g>
</svg></span></a>

  <div class="row links">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.4.0/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.4.0/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../../downloads.html">Documentation Downloads</a></li>
    <li class="level1 nav-leaf"><a href="../../home.html">Home</a></li>
    <li class="level1 nav-leaf"><a href="../faq.html">FAQ</a></li>
    <li class="level1 nav-leaf"><a href="../cheatsheet.html">Cheatsheet</a></li>
    <li class="level1 nav-node"><a href="../api-guide/">Understanding the API</a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/Parsley.html"><code>parsley.Parsley</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/character.html"><code>parsley.character</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/combinator.html"><code>parsley.combinator</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/generic.html"><code>parsley.genericbridges</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/syntax.html"><code>parsley.implicits</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/position.html"><code>parsley.position</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/state.html"><code>parsley.registers</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/debug.html"><code>parsley.debug</code></a></li>
    <li class="level2 nav-header"><code>parsley.expr</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/chain.html"><code>chain</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/infix.html"><code>infix</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/precedence.html"><code>precedence</code></a></li>
    <li class="level2 nav-header"><code>parsley.token</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/Lexer.html"><code>Lexer</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/descriptions.html"><code>descriptions</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/errors.html"><code>errors</code></a></li>
    <li class="level2 nav-header"><code>parsley.errors</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/combinator.html"><code>combinator</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/patterns.html"><code>patterns</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/ErrorBuilder.html"><code>ErrorBuilder</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/tokenextractors.html"><code>tokenextractors</code></a></li>
    <li class="level1 nav-node"><a href="index.html">Parser Combinator Tutorial</a></li>
    <li class="level2 nav-leaf"><a href="basics-of-combinators.html">Basics of Combinators</a></li>
    <li class="level2 active nav-leaf"><a href="#">Building Expression Parsers</a></li>
    <li class="level2 nav-leaf"><a href="effective-whitespace-parsing.html">Effective Whitespace Parsing</a></li>
    <li class="level2 nav-leaf"><a href="effective-lexing.html">Effective Lexing</a></li>
    <li class="level2 nav-leaf"><a href="parser-bridge-pattern.html">The Parser Bridge Pattern</a></li>
    <li class="level2 nav-leaf"><a href="interlude-1-haskell.html">Interlude 1: Building a Parser for Haskell</a></li>
    <li class="level2 nav-leaf"><a href="customising-error-messages.html">Customising Error Messages</a></li>
    <li class="level2 nav-leaf"><a href="advanced-error-messages.html">Advanced Error Messages</a></li>
    <li class="level1 nav-header">Related Projects</li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/parsley-cats">parsley-cats</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/gigaparsec">gigaparsec (Haskell)</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#">Building Expression Parsers</a></p>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="#the-problem-with-left-recursion"><span class="section-number">1 </span>The Problem with Left-Recursion</a></li>
    <li class="level1 nav-leaf"><a href="#using-expr-chain"><span class="section-number">2 </span>Using <code>expr.chain</code></a></li>
    <li class="level1 nav-node"><a href="#using-expr-precedence"><span class="section-number">3 </span>Using <code>expr.precedence</code></a></li>
    <li class="level2 nav-leaf"><a href="#generalising-precedence-with-gops-sops-and-levels"><span class="section-number">3.1 </span>Generalising <code>precedence</code> with <code>GOps</code>, <code>SOps</code>, and <code>Levels</code></a></li>
    <li class="level2 nav-leaf"><a href="#path-dependent-typing-and-ops-sops-gops"><span class="section-number">3.2 </span>Path-Dependent Typing and <code>Ops</code>/<code>SOps</code>/<code>GOps</code></a></li>
    <li class="level2 nav-leaf"><a href="#afternote-why-b-a-b-and-b-b"><span class="section-number">3.3 </span>Afternote: Why <code>(B, A) =&gt; B</code> and <code>B =&gt; B</code>?</a></li>
  </ul>

  <p class="footer"><a href="https://github.com/j-mie6/parsley/blob/master/docs/tutorial/building-expression-parsers.md"><i class="icofont-laika edit" title="Edit">&#xef10;</i>Source for this page</a></p>
</nav>


      <main class="content">

        <h1 id="building-expression-parsers" class="title">Building Expression Parsers</h1>
        <div class="callout info">
          <i class="icofont-laika info">&#xef4e;</i>
          <p>This page builds from the ground up on expression parsing. For a less
          discussion-based explanation see <a href="../api-guide/expr/precedence.html">precedence</a>, as well as <a href="../api-guide/expr/chain.html">chain combinators</a> and <a href="../api-guide/expr/infix.html">heterogeneous chain combinators</a> for more specific use-cases.</p>
        </div>
        <p>Expression parsing is a ubiquitous problem in parsing. It concerns the correct reading of
        operators and values, which are usually organised into precedence and fixities. For the
        purposes of this page a fixity will represent both the fixity <em>and</em> the associativity: infix-left,
        infix-right, prefix, and postfix. For example, this is a grammar for reading simple expressions
        consisting of numbers, brackets, addition, subtraction and multiplication with the standard
        precedences and left associativity.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span>&lt;</span><span class="identifier">number</span><span>&gt; ::= &lt;</span><span class="identifier">digit</span><span>&gt;+
&lt;</span><span class="identifier">expr</span><span>&gt; ::= &lt;</span><span class="identifier">expr</span><span>&gt; </span><span class="string-literal">&#39;+&#39;</span><span> &lt;</span><span class="identifier">term</span><span>&gt; | &lt;</span><span class="identifier">expr</span><span>&gt; </span><span class="string-literal">&#39;-&#39;</span><span> &lt;</span><span class="identifier">term</span><span>&gt; | &lt;</span><span class="identifier">term</span><span>&gt;
&lt;</span><span class="identifier">term</span><span>&gt; ::= &lt;</span><span class="identifier">term</span><span>&gt; </span><span class="string-literal">&#39;*&#39;</span><span> &lt;</span><span class="identifier">atom</span><span>&gt; | &lt;</span><span class="identifier">atom</span><span>&gt;
&lt;</span><span class="identifier">atom</span><span>&gt; ::= </span><span class="string-literal">&#39;(&#39;</span><span> &lt;</span><span class="identifier">expr</span><span>&gt; </span><span class="string-literal">&#39;)&#39;</span><span> | &lt;</span><span class="identifier">number</span><span>&gt;</span></code></pre>
        <p>Here, the precedence is encoded by the fact that <code>&lt;expr&gt;</code> contains <code>&lt;term&gt;</code>, but <code>&lt;term&gt;</code>
        only contains <code>&lt;atom&gt;</code>. The <code>&lt;expr&gt;</code> on the left of the <code>&#39;+&#39;</code> denotes that addition binds
        more tightly to the left, which is what we expect.</p>
        
        <h2 id="the-problem-with-left-recursion" class="section"><a class="anchor-link left" href="#the-problem-with-left-recursion"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">1 </span>The Problem with Left-Recursion</h2>
        <p>For a first atomic, let&#39;s directly translate this grammar into Parsley (for now, we&#39;ll
        parse into an <code>Int</code>: behold, the magic of combinators!):</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>, </span><span class="type-name">Parsley</span><span>.</span><span class="identifier">atomic</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">digit</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">charLift</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">zipped</span><span>.</span><span class="type-name">Zipped2</span><span>

</span><span class="comment">// Standard number parser
</span><span class="keyword">val</span><span> </span><span class="identifier">number</span><span> = </span><span class="identifier">digit</span><span>.</span><span class="identifier">foldLeft1</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="number-literal">0</span><span>)((</span><span class="identifier">n</span><span>, </span><span class="identifier">d</span><span>) =&gt; </span><span class="identifier">n</span><span> * </span><span class="number-literal">10</span><span> + </span><span class="identifier">d</span><span>.</span><span class="identifier">asDigit</span><span>)

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>] =
  </span><span class="identifier">atomic</span><span>((</span><span class="identifier">expr</span><span> &lt;* </span><span class="char-literal">&#39;+&#39;</span><span>, </span><span class="identifier">term</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="identifier">_</span><span> + </span><span class="identifier">_</span><span>)) |
  (</span><span class="identifier">expr</span><span> &lt;* </span><span class="char-literal">&#39;-&#39;</span><span>, </span><span class="identifier">term</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="identifier">_</span><span> - </span><span class="identifier">_</span><span>) |
  </span><span class="identifier">term</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">term</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>] = (</span><span class="identifier">term</span><span> &lt;* </span><span class="char-literal">&#39;*&#39;</span><span>, </span><span class="identifier">atom</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="identifier">_</span><span> * </span><span class="identifier">_</span><span>) | </span><span class="identifier">atom</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">atom</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>] = </span><span class="char-literal">&#39;(&#39;</span><span> *&gt; </span><span class="identifier">expr</span><span> &lt;* </span><span class="char-literal">&#39;)&#39;</span><span> | </span><span class="identifier">number</span></code></pre>
        <p>This parser has a few glaring issues: for a start, the <code>atomic</code> is causing excessive backtracking!
        While there are ways to improve this, the real problem here is
        the <em>left-recursion</em>. Imagine you are evaluating this parser, first you look at <code>expr</code>, and then
        your first task is to evaluate <code>expr</code>! In fact, due to the strictness of Parsley&#39;s combinators, this example breaks before the parser runs: on Scala 2, it will <code>StackOverflowError</code> at runtime when constructing the parser, and on Scala 3, it
        will report an infinitely recursive definition for <code>expr</code> and <code>term</code>. The solution is to turn to the <code>chain</code> combinators, but before we do that, let&#39;s
        eliminate the atomics and refactor it a little to make the transition less jarring:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>, </span><span class="type-name">Parsley</span><span>.</span><span class="identifier">atomic</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">digit</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">charLift</span><span>

</span><span class="comment">// Standard number parser
</span><span class="keyword">val</span><span> </span><span class="identifier">number</span><span> = </span><span class="identifier">digit</span><span>.</span><span class="identifier">foldLeft1</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="number-literal">0</span><span>)((</span><span class="identifier">n</span><span>, </span><span class="identifier">d</span><span>) =&gt; </span><span class="identifier">n</span><span> * </span><span class="number-literal">10</span><span> + </span><span class="identifier">d</span><span>.</span><span class="identifier">asDigit</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">add</span><span> = (</span><span class="identifier">y</span><span>: </span><span class="type-name">Int</span><span>) =&gt; (</span><span class="identifier">x</span><span>: </span><span class="type-name">Int</span><span>) =&gt; </span><span class="identifier">x</span><span> + </span><span class="identifier">y</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">sub</span><span> = (</span><span class="identifier">y</span><span>: </span><span class="type-name">Int</span><span>) =&gt; (</span><span class="identifier">x</span><span>: </span><span class="type-name">Int</span><span>) =&gt; </span><span class="identifier">x</span><span> - </span><span class="identifier">y</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">mul</span><span> = (</span><span class="identifier">y</span><span>: </span><span class="type-name">Int</span><span>) =&gt; (</span><span class="identifier">x</span><span>: </span><span class="type-name">Int</span><span>) =&gt; </span><span class="identifier">x</span><span> * </span><span class="identifier">y</span><span>

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>] =
  </span><span class="identifier">atomic</span><span>(</span><span class="identifier">expr</span><span> &lt;**&gt; (</span><span class="char-literal">&#39;+&#39;</span><span>.</span><span class="identifier">as</span><span>(</span><span class="identifier">add</span><span>) &lt;*&gt; </span><span class="identifier">term</span><span>)) |
  </span><span class="identifier">expr</span><span> &lt;**&gt; (</span><span class="char-literal">&#39;-&#39;</span><span>.</span><span class="identifier">as</span><span>(</span><span class="identifier">sub</span><span>) &lt;*&gt; </span><span class="identifier">term</span><span>) |
  </span><span class="identifier">term</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">term</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>] = </span><span class="identifier">term</span><span> &lt;**&gt; (</span><span class="char-literal">&#39;*&#39;</span><span>.</span><span class="identifier">as</span><span>(</span><span class="identifier">mul</span><span>) &lt;*&gt; </span><span class="identifier">atom</span><span>) | </span><span class="identifier">atom</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">atom</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>] = </span><span class="char-literal">&#39;(&#39;</span><span> ~&gt; </span><span class="identifier">expr</span><span> &lt;~ </span><span class="char-literal">&#39;)&#39;</span><span> | </span><span class="identifier">number</span></code></pre>
        <p>The first step is to perform the translation from the previous post, where we make the operator
        result a function and apply that (flipped) to the right hand side (with <code>&lt;*&gt;</code>) and then the left
        (with <code>&lt;**&gt;</code>). Now, in this form, hopefully you can notice we&#39;ve exposed the leading <code>expr</code> so that
        its on its own: now we can factor a bit more:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>] =
  </span><span class="identifier">expr</span><span> &lt;**&gt; ((</span><span class="char-literal">&#39;+&#39;</span><span>.</span><span class="identifier">as</span><span>(</span><span class="identifier">add</span><span>) &lt;*&gt; </span><span class="identifier">term</span><span>) | (</span><span class="char-literal">&#39;-&#39;</span><span>.</span><span class="identifier">as</span><span>(</span><span class="identifier">sub</span><span>) &lt;*&gt; </span><span class="identifier">term</span><span>)) |
  </span><span class="identifier">term</span></code></pre>
        <p>Now we&#39;ve eliminated the &quot;backtracking&quot; (if only we could make it that far!), but we can right factor
        the <code>|</code> too to obtain the simplest form for the parser:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>] =
  </span><span class="identifier">expr</span><span> &lt;**&gt; ((</span><span class="char-literal">&#39;+&#39;</span><span>.</span><span class="identifier">as</span><span>(</span><span class="identifier">add</span><span>) | </span><span class="char-literal">&#39;-&#39;</span><span>.</span><span class="identifier">as</span><span>(</span><span class="identifier">sub</span><span>)) &lt;*&gt; </span><span class="identifier">term</span><span>) |
  </span><span class="identifier">term</span></code></pre>
        <p>Now, at this point, I could demonstrate how to left-factor this grammar and produce something that
        is right recursive whilst preserving left-associativity. However, there isn&#39;t much point in doing
        this, as now we are in a good position to use the <code>chain.left1</code> combinator, which perfectly embodies
        the translation.</p>
        
        <h2 id="using-expr-chain" class="section"><a class="anchor-link left" href="#using-expr-chain"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">2 </span>Using <code>expr.chain</code></h2>
        <p>The left-recursion problem is not a new one, the parser combinator community has known about it
        for a long time. For parser combinator libraries it is necessary to <em>left-factor</em> the grammar.
        Thankfully, the left-factoring algorithm can be itself encoded nicely as a combinator: this is
        embodied by the <code>chain</code>-family. Here is the same example as before, but fixed using <code>chain.left1</code>:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">digit</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">charLift</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.</span><span class="identifier">chain</span><span>

</span><span class="comment">// Standard number parser
</span><span class="keyword">val</span><span> </span><span class="identifier">number</span><span> = </span><span class="identifier">digit</span><span>.</span><span class="identifier">foldLeft1</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="number-literal">0</span><span>)((</span><span class="identifier">n</span><span>, </span><span class="identifier">d</span><span>) =&gt; </span><span class="identifier">n</span><span> * </span><span class="number-literal">10</span><span> + </span><span class="identifier">d</span><span>.</span><span class="identifier">asDigit</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">add</span><span> = (</span><span class="identifier">x</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Int</span><span>) =&gt; </span><span class="identifier">x</span><span> + </span><span class="identifier">y</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">sub</span><span> = (</span><span class="identifier">x</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Int</span><span>) =&gt; </span><span class="identifier">x</span><span> - </span><span class="identifier">y</span><span>

</span><span class="comment">// chain.left1[A](p: Parsley[A], op: Parsley[(A, A) =&gt; A]): Parsley[A]
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>] = </span><span class="identifier">chain</span><span>.</span><span class="identifier">left1</span><span>(</span><span class="identifier">term</span><span>, </span><span class="char-literal">&#39;+&#39;</span><span>.</span><span class="identifier">as</span><span>(</span><span class="identifier">add</span><span>) | </span><span class="char-literal">&#39;-&#39;</span><span>.</span><span class="identifier">as</span><span>(</span><span class="identifier">sub</span><span>))
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">term</span><span>               = </span><span class="identifier">chain</span><span>.</span><span class="identifier">left1</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="identifier">atom</span><span>, </span><span class="char-literal">&#39;*&#39;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> * </span><span class="identifier">_</span><span>))
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">atom</span><span>               = </span><span class="char-literal">&#39;(&#39;</span><span> ~&gt; </span><span class="identifier">expr</span><span> &lt;~ </span><span class="char-literal">&#39;)&#39;</span><span> | </span><span class="identifier">number</span></code></pre>
        <p>The structure of the parser is roughly the same, however now you&#39;ll notice that <code>expr</code> and <code>term</code>
        are no longer self-recursive, and neither <code>term</code> nor <code>atom</code> need to be lazy (or have explicit types).
        Just to illustrate, if we provide the type argument to <code>chain.left1</code> we can continue to use
        <code>_ * _</code>, but without it, we need explicit type signatures: see <code>add</code> and <code>sub</code>.</p>
        
        <p>To make the relationship very clear between what we had before and what we have now, observe that
        the transformation from recursive to <code>chains</code> follows these shape:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">self</span><span> &lt;**&gt; (</span><span class="identifier">op</span><span> &lt;*&gt; </span><span class="identifier">next</span><span>) | </span><span class="identifier">next</span><span>        == </span><span class="identifier">chain</span><span>.</span><span class="identifier">left1</span><span>(</span><span class="identifier">next</span><span>, </span><span class="identifier">op</span><span>)  </span><span class="comment">// flipped op
</span><span class="identifier">self</span><span> &lt;**&gt; </span><span class="identifier">op</span><span> &lt;*&gt; </span><span class="identifier">next</span><span> | </span><span class="identifier">next</span><span>          == </span><span class="identifier">chain</span><span>.</span><span class="identifier">left1</span><span>(</span><span class="identifier">next</span><span>, </span><span class="identifier">op</span><span>)  </span><span class="comment">// normal op
</span><span class="identifier">next</span><span> &lt;**&gt; (</span><span class="identifier">op</span><span> &lt;*&gt; </span><span class="identifier">self</span><span> &lt;/&gt; </span><span class="identifier">identity</span><span>)  == </span><span class="identifier">chain</span><span>.</span><span class="identifier">right1</span><span>(</span><span class="identifier">next</span><span>, </span><span class="identifier">op</span><span>) </span><span class="comment">// no backtracking, flipped
</span><span class="identifier">atomic</span><span>(</span><span class="identifier">next</span><span> &lt;**&gt; </span><span class="identifier">op</span><span> &lt;*&gt; </span><span class="identifier">self</span><span>) | </span><span class="identifier">next</span><span>  == </span><span class="identifier">chain</span><span>.</span><span class="identifier">right1</span><span>(</span><span class="identifier">next</span><span>, </span><span class="identifier">op</span><span>) </span><span class="comment">// backtracking, normal op</span></code></pre>
        <p>In this parser, the nesting of the chains dictates the precedence order (again, terms are found <em>inside</em>
        expressions and atoms <em>inside</em> terms). Since the addition and subtraction are on the same level, they
        belong in the same chain. The <code>left1</code> indicates that the operator/s are left-associative and that there
        should be at least <em>one</em> of the next layer down. There are also <code>chain.right1</code>, <code>chain.prefix</code>, and
        <code>chain.postfix</code> combinators. The building of these parsers, however, is fairly mechanical, and it is
        tiresome to keep finding new names for new layers of the precedence table. For instances where there
        is more than one chain interacting together then <code>expr.precedence</code> comes in handy (but note that
        <code>expr.precedence</code> is complete overkill to replace a single chain!).</p>
        
        <h2 id="using-expr-precedence" class="section"><a class="anchor-link left" href="#using-expr-precedence"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3 </span>Using <code>expr.precedence</code></h2>
        <p>The final form of this parser uses a expression parser builder, called <code>precedence</code>. Since Parsley parsers
        are implemented in pure Scala, there is nothing to stop you from developing tools like this yourself: the
        ability to work with parsers as values and develop combinators with them is the biggest advantage of
        the approach. That being said, most combinator libraries provide this sort of functionality out of the box
        and Parsley is no exception. Let&#39;s see the same parser one last time and see what&#39;s changed:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">digit</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">charLift</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.{</span><span class="identifier">precedence</span><span>, </span><span class="type-name">Ops</span><span>, </span><span class="type-name">InfixL</span><span>}

</span><span class="keyword">val</span><span> </span><span class="identifier">number</span><span> = </span><span class="identifier">digit</span><span>.</span><span class="identifier">foldLeft1</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="number-literal">0</span><span>)((</span><span class="identifier">n</span><span>, </span><span class="identifier">d</span><span>) =&gt; </span><span class="identifier">n</span><span> * </span><span class="number-literal">10</span><span> + </span><span class="identifier">d</span><span>.</span><span class="identifier">asDigit</span><span>)

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>] = </span><span class="identifier">precedence</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="char-literal">&#39;(&#39;</span><span> ~&gt; </span><span class="identifier">expr</span><span> &lt;~ </span><span class="char-literal">&#39;)&#39;</span><span>, </span><span class="identifier">number</span><span>)(
    </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="char-literal">&#39;*&#39;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> * </span><span class="identifier">_</span><span>)),
    </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="char-literal">&#39;+&#39;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> + </span><span class="identifier">_</span><span>), </span><span class="char-literal">&#39;-&#39;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> - </span><span class="identifier">_</span><span>)))</span></code></pre>
        <p>This is a <em>lot</em> smaller! The way <code>precedence</code> works is that it is first provided with the
        <code>atom</code>s of the expression, and then each precedence level in turn (as many as needed),
        starting with the tightest binding operators. These levels are provided in the <code>Ops</code>, which
        take a fixity, and then any number of parsers which return functions matching the fixity given.
        Under the hood it will form the same nested chains that were used in the previous section.
        In essence, there is no practical difference between the two implementations.</p>
        <p>The precedence table can actually also be reversed so that it works the other way round:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>] = </span><span class="identifier">precedence</span><span>[</span><span class="type-name">Int</span><span>](
    </span><span class="type-name">Ops</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="type-name">InfixL</span><span>)(</span><span class="char-literal">&#39;+&#39;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> + </span><span class="identifier">_</span><span>), </span><span class="char-literal">&#39;-&#39;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> - </span><span class="identifier">_</span><span>)),
    </span><span class="type-name">Ops</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="type-name">InfixL</span><span>)(</span><span class="char-literal">&#39;*&#39;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> * </span><span class="identifier">_</span><span>)))(
    </span><span class="char-literal">&#39;(&#39;</span><span> ~&gt; </span><span class="identifier">expr</span><span> &lt;~ </span><span class="char-literal">&#39;)&#39;</span><span>, </span><span class="identifier">number</span><span>)</span></code></pre>
        <p>But due to the ordering that type inference happens, this form is a bit more cumbersome.</p>
        <p>As mentioned before, the fixity given to <code>Ops</code> influences what type the operators need to have.
        This works by a Scala feature called <em>path-dependent</em> typing, which is extraordinarily useful.
        If you want to know more about this, see the relevant sub-section: you don&#39;t need to know about it
        or understand it to use <code>precedence</code>, however.</p>
        <p>There is still a little more to this story though. So far we&#39;ve been working with a homogenous
        datatype: every level in the precedence table shares the same type <code>Int</code>. Now, in an abstract syntax
        tree, which is the far more common result of parsing, you <em>could</em> represent all expressions
        homogenously (which I call a <em>monolithic</em> AST). But sometimes, it&#39;s desirable to maintain stronger
        guarantees about how the AST is structured, and for that we need a heterogenous precedence table.</p>
        
        <h3 id="generalising-precedence-with-gops-sops-and-levels" class="section"><a class="anchor-link left" href="#generalising-precedence-with-gops-sops-and-levels"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3.1 </span>Generalising <code>precedence</code> with <code>GOps</code>, <code>SOps</code>, and <code>Levels</code></h3>
        
        <h4 id="subtyped-asts-with-sops" class="section"><a class="anchor-link left" href="#subtyped-asts-with-sops"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3.1.1 </span>Subtyped ASTs with <code>SOps</code></h4>
        <p>In some circumstances, it might be desirable to change the type of the parsers at each layer of the
        precedence table. This allows for a more strongly-typed AST, for example. Compared to Haskell, this
        can be easily achieved in Scala using subtyping.</p>
        <p>For example, we can make an AST for our expressions like so:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Add</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Term</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Sub</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Term</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>

</span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Term</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Mul</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Term</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Atom</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Term</span><span>

</span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Atom</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Term</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Number</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Int</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Atom</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Parens</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Atom</span></code></pre>
        <p>The magic of subtyping means that <code>Number(10)</code> is a valid value of type <code>Expr</code>. That being said,
        we have a guarantee that an <code>Expr</code> can only be found inside a <code>Mul</code> if it is wrapped in <code>Parens</code>:
        since <code>Expr</code> is not a subtype of <code>Term</code> or <code>Atom</code>, <code>Mul(Add(Number(6), Number(7)), Number(8))</code> does
        <em>not</em> type-check!</p>
        <p>Let&#39;s see what happens if we try and use our existing <code>precedence</code> knowledge with <code>Ops</code>:</p>
        <pre><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">mul</span><span> = (</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>) =&gt; </span><span class="type-name">Mul</span><span>(</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">add</span><span> = (</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>) =&gt; </span><span class="type-name">Add</span><span>(</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">sub</span><span> = (</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>) =&gt; </span><span class="type-name">Sub</span><span>(</span><span class="identifier">x</span><span>, </span><span class="identifier">y</span><span>)

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">atom</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Atom</span><span>] = </span><span class="identifier">number</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Number</span><span>) | </span><span class="char-literal">&#39;(&#39;</span><span> ~&gt; </span><span class="identifier">expr</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Parens</span><span>) &lt;~ </span><span class="char-literal">&#39;)&#39;</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span> = </span><span class="identifier">precedence</span><span>[</span><span class="type-name">Expr</span><span>](</span><span class="identifier">atom</span><span>)(
  </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="char-literal">&#39;*&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="identifier">mul</span><span>),
  </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="char-literal">&#39;+&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="identifier">add</span><span>, </span><span class="char-literal">&#39;-&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="identifier">sub</span><span>))
</span><span class="comment">// error: type mismatch;
//  found   : Expr
//  required: Term
// val mul = (x: Expr, y: Expr) =&gt; Mul(x, y)
//                                     ^
// error: type mismatch;
//  found   : Expr
//  required: Atom
// val mul = (x: Expr, y: Expr) =&gt; Mul(x, y)
//                                        ^
// error: type mismatch;
//  found   : Expr
//  required: Term
// val add = (x: Expr, y: Expr) =&gt; Add(x, y)
//                                        ^
// error: type mismatch;
//  found   : Expr
//  required: Term
// val sub = (x: Expr, y: Expr) =&gt; Sub(x, y)
//                                        ^</span></code></pre>
        <p>The problem is that, though all <code>Term</code>s are <code>Expr</code>s (and ditto
        for <code>Atom</code>), we are forced to create operators of the shape <code>(Expr, Expr) =&gt; Expr</code> to fit into the
        precedence table, but we can&#39;t guarantee that those <code>Expr</code>s we are passing into the function are
        actually <code>Term</code>s (even though we know intuitively that they will be). In other words,
        <code>(Term, Atom) =&gt; Term</code> is not a subtype of <code>(Expr, Expr) =&gt; Expr</code>!</p>
        <p>So, how do we fix this? Well, we need to stop using <code>Ops</code> and use <code>SOps</code>: instead of requiring an
        <code>(A, A) =&gt; A</code> operator for <code>InfixL</code>, <code>SOps</code> will demand those with shape <code>(B, A) =&gt; B</code> such that
        <code>A &lt;: B</code>. So, does our <code>(Term, Atom) =&gt; Term</code> match this type? Yes: <code>A = Atom</code>, <code>B = Term</code> and
        <code>Atom &lt;: Term</code>; all is good. Why do we require that <code>A &lt;: B</code> exactly? Well, consider that we didn&#39;t
        read any multiplication operators, then we are going to be handing just an <code>Atom</code> to the layer
        above, but we are making the claim that we produce <code>Term</code>s. Of course, this is ok because <code>Atom</code>s
        are themselves <code>Term</code>s.</p>
        <p>Unfortunately, we can&#39;t just provide <code>SOps</code> as variadic arguments to the combinator, since they all
        have different types to each other (that is the point, after all). Instead we use a heterogenous
        list of precedence levels called, well, <code>Levels</code>.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">Levels</span><span>[+</span><span class="type-name">A</span><span>]
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Atoms</span><span>[+</span><span class="type-name">A</span><span>](</span><span class="identifier">atoms</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]*) </span><span class="keyword">extends</span><span> </span><span class="type-name">Levels</span><span>[</span><span class="type-name">A</span><span>]
</span><span class="comment">// and
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Level</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>](
    </span><span class="identifier">nextLevels</span><span>: </span><span class="type-name">Levels</span><span>[</span><span class="type-name">A</span><span>],
    </span><span class="identifier">ops</span><span>: </span><span class="type-name">Ops</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>])
  </span><span class="keyword">extends</span><span> </span><span class="type-name">Levels</span><span>[</span><span class="type-name">B</span><span>]</span></code></pre>
        <p>Basically, the type parameter to <code>Levels</code> is saying that we <em>produce</em> values of
        type <code>A</code> from the outer-most level in the structure. There are two choices of constructor in the list: <code>Atoms</code> is the end of the
        list, it produces <code>A</code>s. The equivalent to <code>::</code>,
        <code>Level[A, B]</code> is a bit more complex: it says that, if you give it a precedence table that produces <code>A</code>s, then it can use its own operators that work on <code>A</code> to produce values of type <code>B</code>. As a result, the larger table produces <code>B</code>s.</p>
        <p>Now, to make life nicer for us, the <code>Levels</code> list supports the common-place Scala collections
        operators of <code>+:</code> and <code>:+</code>, which can be used in place of <code>Level</code>. Just like other Scala
        collections, the rest of the table appears on the side of the <code>:</code>. As a result, we can build tables
        like:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="type-name">Atoms</span><span>(</span><span class="identifier">atom1</span><span>, </span><span class="identifier">atom2</span><span>, .., </span><span class="identifier">atomN</span><span>) :+ </span><span class="identifier">ops1</span><span> :+ </span><span class="identifier">ops2</span><span> :+ .. :+ </span><span class="identifier">opsN</span><span>
</span><span class="comment">// or
</span><span class="identifier">opsN</span><span> +: .. +: </span><span class="identifier">ops2</span><span> +: </span><span class="identifier">ops1</span><span> +: </span><span class="type-name">Atoms</span><span>(</span><span class="identifier">atom1</span><span>, </span><span class="identifier">atom2</span><span>, .., </span><span class="identifier">atomN</span><span>)</span></code></pre>
        <p>The first form is the tightest first approach, and the second is the weakest first approach. So, what does our parser look like if we use <code>Levels</code> and <code>SOps</code>?</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">digit</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">charLift</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.{</span><span class="identifier">precedence</span><span>, </span><span class="type-name">SOps</span><span>, </span><span class="type-name">InfixL</span><span>, </span><span class="type-name">Atoms</span><span>}

</span><span class="keyword">val</span><span> </span><span class="identifier">number</span><span> = </span><span class="identifier">digit</span><span>.</span><span class="identifier">foldLeft1</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="number-literal">0</span><span>)((</span><span class="identifier">n</span><span>, </span><span class="identifier">d</span><span>) =&gt; </span><span class="identifier">n</span><span> * </span><span class="number-literal">10</span><span> + </span><span class="identifier">d</span><span>.</span><span class="identifier">asDigit</span><span>)

</span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Add</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Term</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Sub</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Term</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>

</span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Term</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Mul</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Term</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Atom</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Term</span><span>

</span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Atom</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Term</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Number</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Int</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Atom</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Parens</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Atom</span><span>

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Expr</span><span>] = </span><span class="identifier">precedence</span><span> {
  </span><span class="type-name">Atoms</span><span>(</span><span class="identifier">number</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Number</span><span>), </span><span class="char-literal">&#39;(&#39;</span><span> ~&gt; </span><span class="identifier">expr</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Parens</span><span>) &lt;~ </span><span class="char-literal">&#39;)&#39;</span><span>) :+
  </span><span class="type-name">SOps</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="char-literal">&#39;*&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="type-name">Mul</span><span>) :+
  </span><span class="type-name">SOps</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="char-literal">&#39;+&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="type-name">Add</span><span>, </span><span class="char-literal">&#39;-&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="type-name">Sub</span><span>)
}</span></code></pre>
        <p>Not so bad! We&#39;ve constructed the <code>Levels</code> list using <code>:+</code>, so this is strongest-first.
        This time, if we turn the list around it isn&#39;t going to make us need to add type-annotations
        like it did when we turned the <code>Ops</code> based table round earlier. Nice! An extra advantage of
        using this approach now is that if we tried to use <code>InfixR</code> instead of <code>InfixL</code>, this happens:</p>
        <pre><code>type mismatch;
    found   : (Term, Atom) =&gt; Term
    required: (Atom, Term) =&gt; Term</code></pre>
        <p>This means that, by using <code>SOps</code>, we get a guarantee that our parser correctly matches the intended
        associativity advertised by our ASTs constructors!</p>
        
        <h4 id="non-subtyped-heterogenous-asts-with-gops" class="section"><a class="anchor-link left" href="#non-subtyped-heterogenous-asts-with-gops"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3.1.2 </span>Non-Subtyped Heterogenous ASTs with <code>GOps</code></h4>
        <p>So far we&#39;ve seen how to generalise our expression parsers to work with heterogenous trees that rely
        on subtyping. However, there may be cases where the subtyping is undesirable, or otherwise not
        possible (for example, if you want layers from <code>Int</code> to <code>Expr</code>) but we still want these strongly typed guarantees about the shape of the tree. In this case we would change the data-type as follows:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Add</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Term</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Sub</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Term</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">OfTerm</span><span>(</span><span class="identifier">t</span><span>: </span><span class="type-name">Term</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>

</span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Term</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Mul</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Term</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Atom</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Term</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">OfAtom</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Atom</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Term</span><span>

</span><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Atom</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Number</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Int</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Atom</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Parens</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Atom</span></code></pre>
        <p>Now the question is, how do we use the <code>precedence</code> parser now? The types of each of
        these constructors no longer match <code>(B, A) =&gt; B</code> with <code>A &lt;: B</code>! This is where <code>GOps</code> comes in. It&#39;s
        very similar to <code>SOps</code>, except it doesn&#39;t come with the constraint that <code>A</code> is a subtype of <code>B</code>.
        Instead, a <code>GOps</code> constructor requires you to provide a function of type <code>A =&gt; B</code> too! In our case,
        these will correspond to the <code>OfAtom</code> and <code>OfTerm</code> functions from above. Note that, if there are
        any implicit conversion available from <code>A</code> to <code>B</code>, <code>GOps</code> will happily use those (this includes the
        implicit conversions called <code>A =:= A</code> and <code>A &lt;:&lt; B</code> for type equality and subtyping respectively:
        <code>GOps</code> can implement the behaviour of <code>Ops</code> and <code>SOps</code> via these conversions). So, what does this
        look like in practice?</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">digit</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">charLift</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.{</span><span class="identifier">precedence</span><span>, </span><span class="type-name">GOps</span><span>, </span><span class="type-name">InfixL</span><span>, </span><span class="type-name">Atoms</span><span>}

</span><span class="keyword">val</span><span> </span><span class="identifier">number</span><span> = </span><span class="identifier">digit</span><span>.</span><span class="identifier">foldLeft1</span><span>[</span><span class="type-name">Int</span><span>](</span><span class="number-literal">0</span><span>)((</span><span class="identifier">n</span><span>, </span><span class="identifier">d</span><span>) =&gt; </span><span class="identifier">n</span><span> * </span><span class="number-literal">10</span><span> + </span><span class="identifier">d</span><span>.</span><span class="identifier">asDigit</span><span>)

</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Expr</span><span>] = </span><span class="identifier">precedence</span><span> {
  </span><span class="type-name">Atoms</span><span>(</span><span class="identifier">number</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Number</span><span>), </span><span class="char-literal">&#39;(&#39;</span><span> ~&gt; </span><span class="identifier">expr</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Parens</span><span>) &lt;~ </span><span class="char-literal">&#39;)&#39;</span><span>) :+
  </span><span class="type-name">GOps</span><span>[</span><span class="type-name">Atom</span><span>, </span><span class="type-name">Term</span><span>](</span><span class="type-name">InfixL</span><span>)(</span><span class="char-literal">&#39;*&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="type-name">Mul</span><span>)(</span><span class="type-name">OfAtom</span><span>) :+
  </span><span class="type-name">GOps</span><span>[</span><span class="type-name">Term</span><span>, </span><span class="type-name">Expr</span><span>](</span><span class="type-name">InfixL</span><span>)(</span><span class="char-literal">&#39;+&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="type-name">Add</span><span>, </span><span class="char-literal">&#39;-&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="type-name">Sub</span><span>)(</span><span class="type-name">OfTerm</span><span>)
}</span></code></pre>
        <p>Not so different from the original using <code>SOps</code>, but if you can allow subtyping in your AST, you
        can use the much less brittle <code>SOps</code> form. What makes it brittle? Well, notice that this time we&#39;ve
        had to manually specify the types that each level deals with: this is because, without a subtyping
        constraint, Scala is reluctant to make <code>Mul</code> be of type <code>(Term, Atom) =&gt; Term</code>. Instead it makes it
        <code>(Term, Atom) =&gt; Mul</code> and complains that <code>OfAtom</code> hasn&#39;t got type <code>Atom =&gt; Mul</code>. Oops!</p>
        <p>By the way, you can actually intermingle <code>Ops</code>, <code>SOps</code>, <em>and</em> <code>GOps</code> all in the same table, just as
        long as you are using <code>Levels</code>. Each of them are just builders for values of type <code>Ops[A, B]</code>.</p>
        
        <h3 id="path-dependent-typing-and-ops-sops-gops" class="section"><a class="anchor-link left" href="#path-dependent-typing-and-ops-sops-gops"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3.2 </span>Path-Dependent Typing and <code>Ops</code>/<code>SOps</code>/<code>GOps</code></h3>
        <p>To support the advertised behaviour that the type of an operator depends on the fixity it has,
        the <code>Fixity</code> trait has an <em>abstract type</em> called <code>Op</code>. Let&#39;s take the machinery behind the simpler <code>Ops</code> as an
        example.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Fixity</span><span> {
    </span><span class="keyword">type</span><span> </span><span class="type-name">Op</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>]
}

</span><span class="keyword">object</span><span> </span><span class="type-name">Ops</span><span> {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">fixity</span><span>: </span><span class="type-name">Fixity</span><span>)(</span><span class="identifier">ops</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="identifier">fixity</span><span>.</span><span class="type-name">Op</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">A</span><span>]]*): </span><span class="type-name">Ops</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">A</span><span>] = ???
}</span></code></pre>
        <p>This is saying that the types of the parsers we pass to a call to <code>Ops.apply</code> should depend on the
        type of the <code>Op</code> supported by the <code>fixity</code>. For instance, let&#39;s take <code>InfixL</code> and <code>Prefix</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">object</span><span> </span><span class="type-name">InfixL</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Fixity</span><span> {
    </span><span class="keyword">override</span><span> </span><span class="keyword">type</span><span> </span><span class="type-name">Op</span><span>[-</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>] = (</span><span class="type-name">B</span><span>, </span><span class="type-name">A</span><span>) =&gt; </span><span class="type-name">B</span><span>
}
</span><span class="keyword">case</span><span> </span><span class="keyword">object</span><span> </span><span class="type-name">Prefix</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Fixity</span><span> {
    </span><span class="keyword">override</span><span> </span><span class="keyword">type</span><span> </span><span class="type-name">Op</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">B</span><span>] = </span><span class="type-name">B</span><span> =&gt; </span><span class="type-name">B</span><span>
}</span></code></pre>
        <p>Why <code>Op</code> works with <code>A</code>s and <code>B</code>s is explained in the very last subsection, so for now just always assume that <code>A =:= B</code>. Now observe the types of the partial applications of <code>Ops.apply</code>
        to the different fixities:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">infixLefts</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">ops</span><span>: </span><span class="type-name">Parsley</span><span>[(</span><span class="type-name">A</span><span>, </span><span class="type-name">A</span><span>) =&gt; </span><span class="type-name">A</span><span>]*): </span><span class="type-name">Ops</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">A</span><span>] =
  </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="identifier">ops</span><span>: </span><span class="identifier">_</span><span>*)
</span><span class="keyword">def</span><span> </span><span class="declaration-name">prefixes</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">ops</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span> =&gt; </span><span class="type-name">A</span><span>]*): </span><span class="type-name">Ops</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">A</span><span>] =
  </span><span class="type-name">Ops</span><span>(</span><span class="type-name">Prefix</span><span>)(</span><span class="identifier">ops</span><span>: </span><span class="identifier">_</span><span>*)</span></code></pre>
        <p>The path-dependent type of <code>fixity.Op[A, A]</code> allows the types of the parsers to change accordingly.
        There is a similar story for the <code>GOps</code> and <code>SOps</code> objects, but they instead rely on <code>Levels</code> as
        opposed to variadic arguments.</p>
        
        <h3 id="afternote-why-b-a-b-and-b-b" class="section"><a class="anchor-link left" href="#afternote-why-b-a-b-and-b-b"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3.3 </span>Afternote: Why <code>(B, A) =&gt; B</code> and <code>B =&gt; B</code>?</h3>
        <p>The types given to each fixity are as follows:</p>
        <ul>
          <li><code>InfixL</code> is <code>(B, A) =&gt; B</code></li>
          <li><code>InfixR</code> is <code>(A, B) =&gt; B</code></li>
          <li><code>Prefix</code> and <code>Postfix</code> are both <code>B =&gt; B</code></li>
        </ul>
        <p>This might seem confusing at first: why, for instance, do the unary operators not mention <code>A</code> at all?
        Well, let&#39;s first understand why <code>(B, A) =&gt; B</code> is appropriate for left-associative things but not
        right ones.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">LOp</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Expr</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Int</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">ROp</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Expr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Number</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Int</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span></code></pre>
        <p>Notice that <code>LOp(LOp(Number(6), 5), 4)</code> is ok, because the right hand argument to <code>LOp</code> is always an
        <code>Int</code> and the left-hand argument is always an expression. In the case of <code>6</code>, <code>Int</code> is not an <code>Expr</code>,
        so we wrap it up in the <code>Number</code> constructor. So, for <code>LOp</code>, if we take <code>A = Int</code> and <code>B = Expr</code>,
        it has the shape <code>(B, A) =&gt; B</code>. On the other hand, <code>ROp(ROp(Number(6), 5), 4)</code> is not ok, because
        <code>ROp(...)</code> is not an <code>Int</code>! This justifies the <code>(A, B) =&gt; B</code> type: like-expressions can appear on the
        right, but not the left. The level for this would be <code>GOp[Int, Expr](InfixL)(&#39;@&#39;.as(LOp))(Number)</code> or
        <code>GOp[Int, Expr](InfixR)(&#39;@&#39;.as(ROp))(Number)</code> (notice that switching them round wouldn&#39;t type-check!)</p>
        <p>For <code>Prefix</code> and <code>Postfix</code> it&#39;s a similar story:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">sealed</span><span> </span><span class="keyword">trait</span><span> </span><span class="type-name">BoolExpr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Not</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">BoolExpr</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">BoolExpr</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Literal</span><span>(</span><span class="identifier">b</span><span>: </span><span class="type-name">Boolean</span><span>) </span><span class="keyword">extends</span><span> </span><span class="type-name">BoolExpr</span></code></pre>
        <p>We would like to be able to write <code>Not(Not(Literal(False)))</code>, which means that <code>Not</code> needs to accept
        the same type as itself. This explains <code>B =&gt; B</code>, and in this case, the booleans themselves need to be
        wrapped up with <code>Literal</code> of shape <code>A =&gt; B</code>. This is the same role of <code>Number</code> before, which also has
        shape <code>A =&gt; B</code>. The level for this would be <code>GOp[Boolean, BoolExpr](&quot;not&quot; #&gt; Not)(Literal)</code>.</p>

        
<hr class="footer-rule"/>
<footer>
  Parsley is distributed under the <a href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a> license.
</footer>


      </main>

    </div>

  </body>

</html>