<!DOCTYPE html>
<html lang="en">
  
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Typelevel Laika + Parsley Theme" />
    
    <title>Detecting Left Recursion</title>
    
    
    <meta name="author" content="parsley contributors"/>
    
    
    <meta name="description" content="docs"/>
    
    
    
    <link rel="icon" sizes="32x32" type="image/svg+xml" href="../icons/greenLeaf.svg"/>
    
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
    
    <link rel="stylesheet" type="text/css" href="../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../css/parsley-style.css" />
    <script src="../helium/site/laika-helium.js"></script>
    <script src="../helium/site/laika-versions.js"></script>
    <script>initVersions("../", "", "", null);</script>
    
    <script> /* for avoiding page load transitions */ </script>
  </head>


  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    <div class="menu-container version-menu">
      <a class="text-link menu-toggle" href="#">Choose Version</a>
      <nav class="menu-content">
        <ul class="nav-list">
        </ul>
      </nav>
    </div>
  </div>

  <a class="icon-link svg-link" href="../"><span class="leaf" title="Home"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 128 128" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M101.39,86.21c-14.25-5.91-22.34-4.3-28.47-2.5c-6.5,1.91-12.31,8.58-12.31,8.58s-1.93-0.58-5.04-0.51 c-1.49,0.04-2.67,0.28-3.54,0.54c2.64-5.99,4.51-12.08,7.57-18.76c1.95-0.81,4.63-1.86,6.35-2.23c2.96-0.64,6.45-0.84,6.45-0.84 c0.82,0.64,2,1.39,3.69,2.23c9.56,4.78,21.5,2.16,27.35-0.16c8.13-3.23,20.21-12.95,20.21-13.69s-5.5-3.38-13.32-5.71 c-7.82-2.33-18.27-2.44-26.21,0.95c-7.28,3.11-10.67,8.58-12.54,11.86c0,0-2.9,0.46-5,0.82c-1.56,0.27-2.96,0.64-4.07,0.99 c0.22-0.4,0.45-0.81,0.68-1.21C67.77,58.61,72.83,52.5,77,48.2c5.87,0.55,17.89,0.35,27.62-8.46 c15.64-14.15,18.46-35.92,18.07-36.35S97.35,3.34,84.54,14.91c-12.19,11.01-11.97,25.4-11.4,30.69c-3.97,3.71-8.81,9.17-14.2,17.12 c-0.04-2.12-0.29-4.73-0.29-4.73s7.19-6.73,7.72-17.18c0.42-8.24-0.46-15.89-5-24.14c-3.56-6.43-6.53-8.03-7.06-7.93 c-0.93,0.19-5.33,7.06-8.03,13.63c-2.13,5.17-4.26,18.38-0.45,26.52s8.22,9.68,8.22,9.68s0.54,2.37,0.48,5.55 c-0.02,1.36-0.13,4.51-0.18,5.98c-3.57,6.32-5.96,12.07-8.23,17.22c-0.34-0.99-0.73-1.96-1.11-2.65c-1.16-2.11-1.59-2.85-1.59-2.85 s2.57-15.99-1.8-29.17C36.45,37,27.57,31.08,19.33,27.59C11.09,24.1,6.54,24.11,5.8,24.95c-1.08,1.23,1.37,4.33,1.59,11.31 c0.17,5.71,1.16,25.05,6.87,34.98s13.63,12.37,16.17,13.21c2.54,0.85,8.03,0.95,8.03,0.95s2.33,2.01,3.17,4.86 c0.39,1.31,0.78,2.92,1.09,4.27c-1.95,3.71-4.17,7-7.21,9.86c-5.01,4.71-13.09,7.94-13.09,7.94s-6.47-0.15-6.91,0.15 c-0.44,0.29-1.73,3.53,0.69,7.51c2,3.29,5.05,4.12,6.08,4.26c1.03,0.15,2.94-4.27,3.68-4.86c0.74-0.59,9.43-3.93,15.6-10.74 c2.83-3.13,5.02-6.16,6.81-9.17c1.65-1.01,4.07-2.17,6.72-2.31c2.64-0.15,4.94,1.12,4.94,1.12s2.22,9.16,12.15,13 c12.5,4.83,25.83,0.61,31.64-1.4c5.81-2,19.83-8.42,19.94-10.22C123.86,97.87,115.66,92.13,101.39,86.21z"/>
  </g>
</svg></span></a>

  <div class="row links">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/5.0.0-M14/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/5.0.0-M14/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../downloads.html">Documentation Downloads</a></li>
    <li class="level1 nav-leaf"><a href="../home.html">Home</a></li>
    <li class="level1 nav-leaf"><a href="../5.0/faq.html">FAQ</a></li>
    <li class="level1 nav-leaf"><a href="../5.0/cheatsheet.html">Cheatsheet</a></li>
    <li class="level1 nav-node"><a href="../5.0/api-guide/">Understanding the API</a></li>
    <li class="level2 nav-leaf"><a href="../5.0/api-guide/Parsley.html"><code>parsley.Parsley</code></a></li>
    <li class="level2 nav-leaf"><a href="../5.0/api-guide/character.html"><code>parsley.character</code></a></li>
    <li class="level2 nav-leaf"><a href="../5.0/api-guide/combinator.html"><code>parsley.combinator</code></a></li>
    <li class="level2 nav-leaf"><a href="../5.0/api-guide/generic.html"><code>parsley.generic</code></a></li>
    <li class="level2 nav-leaf"><a href="../5.0/api-guide/syntax.html"><code>parsley.syntax</code></a></li>
    <li class="level2 nav-leaf"><a href="../5.0/api-guide/position.html"><code>parsley.position</code></a></li>
    <li class="level2 nav-leaf"><a href="../5.0/api-guide/state.html"><code>parsley.state</code></a></li>
    <li class="level2 nav-leaf"><a href="../5.0/api-guide/debug.html"><code>parsley.debug</code></a></li>
    <li class="level2 nav-header"><code>parsley.expr</code></li>
    <li class="level3 nav-leaf"><a href="../5.0/api-guide/expr/chain.html"><code>chain</code></a></li>
    <li class="level3 nav-leaf"><a href="../5.0/api-guide/expr/infix.html"><code>infix</code></a></li>
    <li class="level3 nav-leaf"><a href="../5.0/api-guide/expr/precedence.html"><code>precedence</code></a></li>
    <li class="level2 nav-header"><code>parsley.token</code></li>
    <li class="level3 nav-leaf"><a href="../5.0/api-guide/token/Lexer.html"><code>Lexer</code></a></li>
    <li class="level3 nav-leaf"><a href="../5.0/api-guide/token/descriptions.html"><code>descriptions</code></a></li>
    <li class="level3 nav-leaf"><a href="../5.0/api-guide/token/errors.html"><code>errors</code></a></li>
    <li class="level2 nav-header"><code>parsley.errors</code></li>
    <li class="level3 nav-leaf"><a href="../5.0/api-guide/errors/combinator.html"><code>combinator</code></a></li>
    <li class="level3 nav-leaf"><a href="../5.0/api-guide/errors/patterns.html"><code>patterns</code></a></li>
    <li class="level3 nav-leaf"><a href="../5.0/api-guide/errors/ErrorBuilder.html"><code>ErrorBuilder</code></a></li>
    <li class="level3 nav-leaf"><a href="../5.0/api-guide/errors/tokenextractors.html"><code>tokenextractors</code></a></li>
    <li class="level1 nav-node"><a href="../5.0/tutorial/">Parser Combinator Tutorial</a></li>
    <li class="level2 nav-leaf"><a href="../5.0/tutorial/basics-of-combinators.html">Basics of Combinators</a></li>
    <li class="level2 nav-leaf"><a href="../5.0/tutorial/building-expression-parsers.html">Building Expression Parsers</a></li>
    <li class="level2 nav-leaf"><a href="../5.0/tutorial/effective-whitespace-parsing.html">Effective Whitespace Parsing</a></li>
    <li class="level2 nav-leaf"><a href="../5.0/tutorial/effective-lexing.html">Effective Lexing</a></li>
    <li class="level2 nav-leaf"><a href="../5.0/tutorial/parser-bridge-pattern.html">The Parser Bridge Pattern</a></li>
    <li class="level2 nav-leaf"><a href="../5.0/tutorial/interlude-1-haskell.html">Interlude 1: Building a Parser for Haskell</a></li>
    <li class="level2 nav-leaf"><a href="../5.0/tutorial/customising-error-messages.html">Customising Error Messages</a></li>
    <li class="level2 nav-leaf"><a href="../5.0/tutorial/advanced-error-messages.html">Advanced Error Messages</a></li>
    <li class="level1 nav-header">parsley-debug</li>
    <li class="level2 nav-leaf"><a href="../5.0/parsley-debug/debuggable.html"><code>@parsley.debuggable</code></a></li>
    <li class="level2 nav-leaf"><a href="../5.0/parsley-debug/attachment.html">Attaching Debugger Views</a></li>
    <li class="level2 nav-header">Debug Views</li>
    <li class="level3 nav-leaf"><a href="../5.0/parsley-debug/debug-views/PrintView.html"><code>PrintView</code></a></li>
    <li class="level2 active nav-leaf"><a href="#">Detecting Left Recursion</a></li>
    <li class="level1 nav-header">Related Projects</li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/parsley-cats">parsley-cats</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/gigaparsec">gigaparsec (Haskell)</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#">Detecting Left Recursion</a></p>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="#looping-vs-recursion">Looping vs Recursion</a></li>
    <li class="level1 nav-leaf"><a href="#stateful-parsers">Stateful Parsers</a></li>
    <li class="level1 nav-leaf"><a href="#limitations">Limitations</a></li>
  </ul>

  <p class="footer"><a href="https://github.com/j-mie6/parsley/blob/staging/5.0/docs/parsley-debug/recursion-detection.md"><i class="icofont-laika edit" title="Edit">&#xef10;</i>Source for this page</a></p>
</nav>


      <main class="content">

        <h1 id="detecting-left-recursion" class="title">Detecting Left Recursion</h1>
        <p>Left recursion is an issue that plagues recursive-descent parsing. Whenever a parser
        (eventually) performs itself as the first thing it does, this will infinite loop and
        the parser will not terminate. While <code>parsley</code> has been designed in a way that aims to
        statically rule out the more obvious left-recursive definitions, it is still possible to
        indirectly write these parsers. The <code>parsley-debug</code> library provides functionality to
        help track down the sources of such issues at runtime when provided with an input known
        to loop.</p>
        <div class="callout info">
          <i class="icofont-laika info">&#xef4e;</i>
          <p>Please see the <a href="../5.0/parsley-debug/debuggable.html"><code>@parsley.debuggable</code></a> page first, as this is used
          to provide meaningful names for this functionality.</p>
        </div>
        <p>The combinator we are interested in is called <code>parsley.debug.combinator.detectDivergence</code>, which
        wraps the top-level parser.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">quick</span><span>.*
</span><span class="comment">//import parsley.debuggable
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">debug</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">detectDivergence</span><span>

</span><span class="annotation">@debuggable</span><span>
</span><span class="keyword">object</span><span> </span><span class="identifier">parsers</span><span> {
    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">top</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">p</span><span>.</span><span class="identifier">void</span><span> </span><span class="comment">// simplifies the cycle, see #247
</span><span>    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">p</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">char</span><span>(</span><span class="char-literal">&#39;a&#39;</span><span>).</span><span class="identifier">void</span><span> | </span><span class="identifier">s</span><span> ~&gt; </span><span class="identifier">q</span><span>
    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">q</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">r</span><span>, </span><span class="identifier">string</span><span>(</span><span class="string-literal">&quot;,&quot;</span><span>)).</span><span class="identifier">void</span><span>
    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">r</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">many</span><span>(</span><span class="identifier">p</span><span>).</span><span class="identifier">void</span><span>
    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">s</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">unit</span><span>
}</span></code></pre>
        <p>While <code>parsers.top.parse(&quot;a&quot;)</code> would work fine, consider what happens if we pass the empty string:</p>
        <pre><code class="nohighlight"><span class="identifier">detectDivergence</span><span>(</span><span class="identifier">parsers</span><span>.</span><span class="identifier">top</span><span>).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;&quot;</span><span>)
</span><span class="comment">// parsley.exceptions.ParsleyException: 
// Left-recursion has been detected in the given parser. The trace is as follows:
// 
// p
// q
// r
// p
// 
// For readability, all non-named combinators have been stripped out -- to see more,
// use the `named` combinator to tag parts of the parser you want to see appear in
// the trace.
// 
// 	at repl.MdocSession$MdocApp$$anonfun$1.apply(recursion-detection.md:40)
// 	at repl.MdocSession$MdocApp$$anonfun$1.apply(recursion-detection.md:40)</span></code></pre>
        <p>Thankfully, the <code>detectDivergence</code> combinator can detect that this will cause an issue, and provides
        some insight into what that might be. If you follow that trace out carefully, you&#39;ll see that these
        four calls form a cycle where no input is consumed before you get back to the start again: this is
        what causes left-recursion.</p>
        
        <h2 id="looping-vs-recursion" class="section"><a class="anchor-link left" href="#looping-vs-recursion"><i class="icofont-laika link">&#xef71;</i></a>Looping vs Recursion</h2>
        <p>Divergence is a property that is more general than just left-recursion. In fact, some combinators
        can more accurately iteratively &quot;loop&quot; forever. One such case is as follows:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">detectDivergence</span><span>(</span><span class="identifier">many</span><span>(</span><span class="identifier">unit</span><span>)).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;&quot;</span><span>)
</span><span class="comment">// parsley.exceptions.ParsleyException: 
// `many` is looping unproductively as `unit` can succeed having not consumed input.
// 
// More precise names for the body and the loop can be sourced using @parsley.debuggable
// or the `named` combinator.
// 	at repl.MdocSession$MdocApp$$anonfun$2.apply(recursion-detection.md:50)
// 	at repl.MdocSession$MdocApp$$anonfun$2.apply(recursion-detection.md:50)</span></code></pre>
        <p>The <code>many</code> combinator reads zero-or-more things. When given something that doesn&#39;t consume input,
        it will succeed reading that parser, then loop back round and try to read it again. This
        is, as you might expect, exactly where it left off last iteration. As such, <code>detectDivergence</code> can
        also detect this kind of looping as well. While <code>parsley</code> implements <code>many</code> and friends more
        efficiently, in theory this is still left-recursion, it is just called <em>hidden left-recursion</em>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">many</span><span>(</span><span class="identifier">p</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>]] = {
    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">rec</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>]] = </span><span class="identifier">p</span><span> &lt;::&gt; </span><span class="identifier">rec</span><span> | </span><span class="identifier">pure</span><span>(</span><span class="type-name">Nil</span><span>)
    </span><span class="identifier">rec</span><span>
}</span></code></pre>
        <p>When <code>p</code> does not succeed having consumed input, <code>rec</code> will perform itself again from the same
        input point -- this is left-recursion, even if <code>p</code> is &quot;in the way&quot;.</p>
        
        <h2 id="stateful-parsers" class="section"><a class="anchor-link left" href="#stateful-parsers"><i class="icofont-laika link">&#xef71;</i></a>Stateful Parsers</h2>
        <p>It is &quot;easy&quot; to detect that a parser is looping if the only state in the parser is the input --
        if we get back to the same place with no input consumed we will most certainly repeat that forever.
        However, <code>parsley.state</code> gives us access to mutable pieces of state threaded through a parser.
        This adds an additional complication that makes <em>static analysis</em> of parser divergence more
        intractible. However, the <code>detectDivergence</code> combinator is a <em>runtime analysis</em>, and so has access
        to the state to track what&#39;s going on. This means it is able to detect more complex looping that
        involves <code>Ref</code>:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">quick</span><span>.*
</span><span class="comment">//import parsley.debuggable
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">debug</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">detectDivergence</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">state</span><span>.*

</span><span class="annotation">@debuggable</span><span>
</span><span class="keyword">object</span><span> </span><span class="identifier">stateful</span><span> {
    </span><span class="keyword">val</span><span> </span><span class="identifier">toggle</span><span> = </span><span class="type-name">Ref</span><span>.</span><span class="identifier">make</span><span>[</span><span class="type-name">Boolean</span><span>]
    </span><span class="keyword">val</span><span> </span><span class="identifier">counter</span><span> = </span><span class="type-name">Ref</span><span>.</span><span class="identifier">make</span><span>[</span><span class="type-name">Int</span><span>]
    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">p</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">counter</span><span>.</span><span class="identifier">update</span><span>(</span><span class="identifier">_</span><span> + </span><span class="number-literal">1</span><span>) ~&gt; </span><span class="identifier">ifS</span><span>(</span><span class="identifier">counter</span><span>.</span><span class="identifier">gets</span><span>(</span><span class="identifier">_</span><span> == </span><span class="number-literal">10</span><span>), </span><span class="identifier">counter</span><span>.</span><span class="identifier">set</span><span>(</span><span class="number-literal">0</span><span>) ~&gt; </span><span class="identifier">q</span><span>, </span><span class="identifier">p</span><span>)
    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">q</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">toggle</span><span>.</span><span class="identifier">update</span><span>(!</span><span class="identifier">_</span><span>) ~&gt; </span><span class="identifier">p</span><span>
    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">top</span><span> = </span><span class="identifier">toggle</span><span>.</span><span class="identifier">set</span><span>(</span><span class="boolean-literal">false</span><span>) ~&gt; </span><span class="identifier">counter</span><span>.</span><span class="identifier">set</span><span>(</span><span class="number-literal">0</span><span>) ~&gt; </span><span class="identifier">p</span><span>
}</span></code></pre>
        <p>This parser is a contrived example, admittedly, but illustrates what <code>detectDivergence</code> is capable of.
        The parser <code>top</code> runs in the presence of two <code>Ref</code>s: <code>p</code> will loop until the counter reaches <code>10</code>, when
        it will reset it and execute <code>q</code> one time. <code>q</code> flips the <code>toggle</code>, but then does <code>p</code>. With some thought,
        you might be able to identify the cycle that will happen here:</p>
        <pre><code class="nohighlight"><span class="identifier">detectDivergence</span><span>(</span><span class="identifier">stateful</span><span>.</span><span class="identifier">top</span><span>).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;&quot;</span><span>)
</span><span class="comment">// parsley.exceptions.ParsleyException: 
// Left-recursion has been detected in the given parser. The trace is as follows:
// 
// p (with state (0, false))
// p (with state (1, false))
// p (with state (2, false))
// p (with state (3, false))
// p (with state (4, false))
// p (with state (5, false))
// p (with state (6, false))
// p (with state (7, false))
// p (with state (8, false))
// p (with state (9, false))
// q (with state (0, false))
// p (with state (0, true))
// p (with state (1, true))
// p (with state (2, true))
// p (with state (3, true))
// p (with state (4, true))
// p (with state (5, true))
// p (with state (6, true))
// p (with state (7, true))
// p (with state (8, true))
// p (with state (9, true))
// q (with state (0, true))
// p (with state (0, false))
// 
// For readability, all non-named combinators have been stripped out -- to see more,
// use the `named` combinator to tag parts of the parser you want to see appear in
// the trace.
// 
// 	at repl.MdocSession$MdocApp$$anonfun$3.apply(recursion-detection.md:88)
// 	at repl.MdocSession$MdocApp$$anonfun$3.apply(recursion-detection.md:88)</span></code></pre>
        <p>Unfortunately, at the moment there is no way to name the references, but this is future work. Regardless,
        this time, the cycle shows the state snapshots that lead to the loop in the parser; namely, when
        the counter hits <code>0</code> again and the toggle is reset to <code>false</code>, we enter our initial state, and the
        parser is killed.</p>
        <p>Obviously, if this were just an infinite loop of the form <code>lazy val p: Parsley[Unit] = counter.update(_ + 1) ~&gt; p</code>, then <code>detectDivergence</code> cannot detect this until <code>counter</code> overflows! The system isn&#39;t fool proof,
        obviously, since this would mean solving the general halting problem, but it works for any non-stateful
        parser and stateful parsers which repeat the same stateful behaviour.</p>
        
        <h2 id="limitations" class="section"><a class="anchor-link left" href="#limitations"><i class="icofont-laika link">&#xef71;</i></a>Limitations</h2>
        <p>As you may have noticed in the above example with <code>many</code>, sometimes there may be a lack of information
        about the naming of certain parsers (which can help pin-point where a problem arose from). Obviously,
        the <code>@parsley.debuggable</code> annotation is meant to help with this, but it does not necessarily have
        visibility over <em>all</em> parsers! Let&#39;s see where this might go wrong:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="annotation">@debuggable</span><span>
</span><span class="keyword">object</span><span> </span><span class="identifier">nameless</span><span> {
    </span><span class="keyword">val</span><span> </span><span class="identifier">top</span><span> = </span><span class="boolean-literal">false</span><span>.</span><span class="identifier">makeRef</span><span> { </span><span class="identifier">r</span><span> =&gt;
        </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">p</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">r</span><span>.</span><span class="identifier">update</span><span>(!</span><span class="identifier">_</span><span>) ~&gt; </span><span class="identifier">p</span><span>
        </span><span class="identifier">p</span><span>
    }
}</span></code></pre>
        <p>While we might expect this to work out much like the <code>stateful</code> example above, in reality we see
        this:</p>
        <pre><code class="nohighlight"><span class="identifier">detectDivergence</span><span>(</span><span class="identifier">nameless</span><span>.</span><span class="identifier">top</span><span>).</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;&quot;</span><span>)
</span><span class="comment">// parsley.exceptions.ParsleyException: 
// Left-recursion has been detected in the given parser; however, there is not
// enough information to determine the cycle. To get the full cycle diagnostic,
// please use the `parsley.debuggable` annotation to populate the name information.
// 
// For example, if your parsers are exposed (publically) in an object called
// `foo`, you should write:
// 
// &gt; @parsley.debuggable object foo { ... }
// 
// Alternatively, you can give individual parser fragments names by using the
// `named` combinator, which will cause them to appear along the path.
// 
// 	at repl.MdocSession$MdocApp$$anonfun$5.apply(recursion-detection.md:116)
// 	at repl.MdocSession$MdocApp$$anonfun$5.apply(recursion-detection.md:116)</span></code></pre>
        <p>Unfortunately, the annotation cannot see into nested definitions, only top-level ones. In this case,
        we can use the <code>named</code> combinator from <code>parsley.debug.combinator</code> to explicitly name <code>p</code> (via <code>named(p, &quot;p&quot;)</code>), or you may be able to get away with something like:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="annotation">@debuggable</span><span>
</span><span class="keyword">class</span><span> </span><span class="type-name">Nested</span><span>(</span><span class="identifier">r</span><span>: </span><span class="type-name">Ref</span><span>[</span><span class="type-name">Boolean</span><span>]) {
    </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">p</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">r</span><span>.</span><span class="identifier">update</span><span>(!</span><span class="identifier">_</span><span>) ~&gt; </span><span class="identifier">p</span><span>
}

</span><span class="annotation">@debuggable</span><span>
</span><span class="keyword">object</span><span> </span><span class="identifier">nameful</span><span> {
    </span><span class="keyword">val</span><span> </span><span class="identifier">top</span><span> = </span><span class="boolean-literal">false</span><span>.</span><span class="identifier">makeRef</span><span>(</span><span class="identifier">r</span><span> =&gt; </span><span class="keyword">new</span><span> </span><span class="type-name">Nested</span><span>(</span><span class="identifier">r</span><span>).</span><span class="identifier">p</span><span>)
}</span></code></pre>
        <p>However, this is remarkably clumsy to use in practice (please don&#39;t)!</p>

        
<hr class="footer-rule"/>
<footer>
  Parsley is distributed under the <a href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a> license.
</footer>


      </main>

    </div>

  </body>

</html>