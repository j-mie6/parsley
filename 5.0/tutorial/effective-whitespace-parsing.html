<!DOCTYPE html>
<html lang="en">
  
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Typelevel Laika + Parsley Theme" />
    
    <title>Effective Whitespace Parsing</title>
    
    
    <meta name="author" content="parsley contributors"/>
    
    
    <meta name="description" content="Conventions for how a parser should deal with whitespace."/>
    
    
    
    <link rel="icon" sizes="32x32" type="image/svg+xml" href="../../icons/greenLeaf.svg"/>
    
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
    
    <link rel="stylesheet" type="text/css" href="../../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../../css/parsley-style.css" />
    <link rel="stylesheet" type="text/css" href="../../search/search.css" />
    <script src="../../helium/site/laika-helium.js"></script>
    <script src="../../helium/site/laika-versions.js"></script>
    <script src="../../search/protosearch.js"></script>
    <script src="../../search/searchBar.js"></script>
    <script>initVersions("../../", "/tutorial/effective-whitespace-parsing.html", "5.0", null);</script>
    
    <script> /* for avoiding page load transitions */ </script>
  </head>


  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>

    <div class="menu-container version-menu">
      <a class="text-link menu-toggle" href="#">Version 5.0.x</a>
      <nav class="menu-content">
        <ul class="nav-list">
        </ul>
      </nav>
    </div>
  </div>

  <a class="icon-link svg-link" href="../../"><span class="leaf" title="Home"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 128 128" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M101.39,86.21c-14.25-5.91-22.34-4.3-28.47-2.5c-6.5,1.91-12.31,8.58-12.31,8.58s-1.93-0.58-5.04-0.51 c-1.49,0.04-2.67,0.28-3.54,0.54c2.64-5.99,4.51-12.08,7.57-18.76c1.95-0.81,4.63-1.86,6.35-2.23c2.96-0.64,6.45-0.84,6.45-0.84 c0.82,0.64,2,1.39,3.69,2.23c9.56,4.78,21.5,2.16,27.35-0.16c8.13-3.23,20.21-12.95,20.21-13.69s-5.5-3.38-13.32-5.71 c-7.82-2.33-18.27-2.44-26.21,0.95c-7.28,3.11-10.67,8.58-12.54,11.86c0,0-2.9,0.46-5,0.82c-1.56,0.27-2.96,0.64-4.07,0.99 c0.22-0.4,0.45-0.81,0.68-1.21C67.77,58.61,72.83,52.5,77,48.2c5.87,0.55,17.89,0.35,27.62-8.46 c15.64-14.15,18.46-35.92,18.07-36.35S97.35,3.34,84.54,14.91c-12.19,11.01-11.97,25.4-11.4,30.69c-3.97,3.71-8.81,9.17-14.2,17.12 c-0.04-2.12-0.29-4.73-0.29-4.73s7.19-6.73,7.72-17.18c0.42-8.24-0.46-15.89-5-24.14c-3.56-6.43-6.53-8.03-7.06-7.93 c-0.93,0.19-5.33,7.06-8.03,13.63c-2.13,5.17-4.26,18.38-0.45,26.52s8.22,9.68,8.22,9.68s0.54,2.37,0.48,5.55 c-0.02,1.36-0.13,4.51-0.18,5.98c-3.57,6.32-5.96,12.07-8.23,17.22c-0.34-0.99-0.73-1.96-1.11-2.65c-1.16-2.11-1.59-2.85-1.59-2.85 s2.57-15.99-1.8-29.17C36.45,37,27.57,31.08,19.33,27.59C11.09,24.1,6.54,24.11,5.8,24.95c-1.08,1.23,1.37,4.33,1.59,11.31 c0.17,5.71,1.16,25.05,6.87,34.98s13.63,12.37,16.17,13.21c2.54,0.85,8.03,0.95,8.03,0.95s2.33,2.01,3.17,4.86 c0.39,1.31,0.78,2.92,1.09,4.27c-1.95,3.71-4.17,7-7.21,9.86c-5.01,4.71-13.09,7.94-13.09,7.94s-6.47-0.15-6.91,0.15 c-0.44,0.29-1.73,3.53,0.69,7.51c2,3.29,5.05,4.12,6.08,4.26c1.03,0.15,2.94-4.27,3.68-4.86c0.74-0.59,9.43-3.93,15.6-10.74 c2.83-3.13,5.02-6.16,6.81-9.17c1.65-1.01,4.07-2.17,6.72-2.31c2.64-0.15,4.94,1.12,4.94,1.12s2.22,9.16,12.15,13 c12.5,4.83,25.83,0.61,31.64-1.4c5.81-2,19.83-8.42,19.94-10.22C123.86,97.87,115.66,92.13,101.39,86.21z"/>
  </g>
</svg></span></a>

  <div class="row search-row">
    <input id="search-top-bar" class="input" type="text" placeholder="Search">
  </div>
  <div id="search-modal" class="search-modal">
    <div class="search-modal-content">
      <span class="search-close">&times;</span>
      <input id="search-modal-input" class="input" type="text">
      <div id="search-modal-content-body"></div>
    </div>
  </div>

  <div class="row links">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/5.0.0-M15/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>

</header>

    
    <nav id="sidebar">

  <div class="row">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/5.0.0-M15/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../../downloads.html">Documentation Downloads</a></li>
    <li class="level1 nav-leaf"><a href="../../home.html">Home</a></li>
    <li class="level1 nav-leaf"><a href="../faq.html">FAQ</a></li>
    <li class="level1 nav-leaf"><a href="../cheatsheet.html">Cheatsheet</a></li>
    <li class="level1 nav-node"><a href="../api-guide/">Understanding the API</a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/Parsley.html"><code>parsley.Parsley</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/character.html"><code>parsley.character</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/combinator.html"><code>parsley.combinator</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/generic.html"><code>parsley.generic</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/syntax.html"><code>parsley.syntax</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/position.html"><code>parsley.position</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/state.html"><code>parsley.state</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/debug.html"><code>parsley.debug</code></a></li>
    <li class="level2 nav-header"><code>parsley.expr</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/chain.html"><code>chain</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/infix.html"><code>infix</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/precedence.html"><code>precedence</code></a></li>
    <li class="level2 nav-header"><code>parsley.token</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/Lexer.html"><code>Lexer</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/descriptions.html"><code>descriptions</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/errors.html"><code>errors</code></a></li>
    <li class="level2 nav-header"><code>parsley.errors</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/combinator.html"><code>combinator</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/patterns.html"><code>patterns</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/ErrorBuilder.html"><code>ErrorBuilder</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/tokenextractors.html"><code>tokenextractors</code></a></li>
    <li class="level1 nav-node"><a href="index.html">Parser Combinator Tutorial</a></li>
    <li class="level2 nav-leaf"><a href="basics-of-combinators.html">Basics of Combinators</a></li>
    <li class="level2 nav-leaf"><a href="building-expression-parsers.html">Building Expression Parsers</a></li>
    <li class="level2 active nav-leaf"><a href="#">Effective Whitespace Parsing</a></li>
    <li class="level2 nav-leaf"><a href="effective-lexing.html">Effective Lexing</a></li>
    <li class="level2 nav-leaf"><a href="parser-bridge-pattern.html">The Parser Bridge Pattern</a></li>
    <li class="level2 nav-leaf"><a href="interlude-1-haskell.html">Interlude 1: Building a Parser for Haskell</a></li>
    <li class="level2 nav-leaf"><a href="customising-error-messages.html">Customising Error Messages</a></li>
    <li class="level2 nav-leaf"><a href="advanced-error-messages.html">Advanced Error Messages</a></li>
    <li class="level1 nav-header">parsley-debug</li>
    <li class="level2 nav-leaf"><a href="../parsley-debug/debuggable.html"><code>@parsley.debuggable</code></a></li>
    <li class="level2 nav-leaf"><a href="../parsley-debug/attachment.html">Attaching Debugger Views</a></li>
    <li class="level2 nav-header">Debug Views</li>
    <li class="level3 nav-leaf"><a href="../parsley-debug/debug-views/PrintView.html"><code>PrintView</code></a></li>
    <li class="level2 nav-leaf"><a href="../../parsley-debug/recursion-detection.html">Detecting Left Recursion</a></li>
    <li class="level1 nav-header">Related Projects</li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/parsley-cats">parsley-cats</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/gigaparsec">gigaparsec (Haskell)</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#">Effective Whitespace Parsing</a></p>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="#defining-whitespace-readers"><span class="section-number">1 </span>Defining whitespace readers</a></li>
    <li class="level1 nav-leaf"><a href="#lexemes"><span class="section-number">2 </span>Lexemes</a></li>
    <li class="level1 nav-leaf"><a href="#a-problem-with-scope"><span class="section-number">3 </span>A Problem with Scope</a></li>
  </ul>

  <p class="footer"><a href="https://github.com/j-mie6/parsley/blob/staging/5.0/docs/tutorial/effective-whitespace-parsing.md"><i class="icofont-laika edit" title="Edit">&#xef10;</i>Source for this page</a></p>
</nav>


      <main class="content">

        <h1 id="effective-whitespace-parsing" class="title">Effective Whitespace Parsing</h1>
        <div class="callout info">
          <i class="icofont-laika info">&#xef4e;</i>
          <p>Note that this page describes conventions for whitespace handling, but these
          are handled directly by the <a href="../api-guide/token/Lexer.html"><code>parsley.token.Lexer</code></a> and its subfunctionality, which is expored at the end of the next page.</p>
        </div>
        <p>Previously, in <a href="basics-of-combinators.html#basics-of-combinators">Basics of Combinators</a> and <a href="building-expression-parsers.html#building-expression-parsers">Building Expression Parsers</a>,
        we&#39;ve seen parsers for languages that do not account for whitespace. In this page I&#39;ll discuss
        the best practices for handling whitespace in your grammars.</p>
        
        <h2 id="defining-whitespace-readers" class="section"><a class="anchor-link left" href="#defining-whitespace-readers"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">1 </span>Defining whitespace readers</h2>
        <p>The first step in the correct handling of whitespace is to build the small parsers that
        recognise the grammar itself.  The two concerns usually are spaces and comments. For
        comments, the combinator <code>combinator.manyTill</code> is <em>very</em> useful. For example:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>, </span><span class="type-name">Parsley</span><span>.{</span><span class="identifier">atomic</span><span>, </span><span class="identifier">many</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.{</span><span class="identifier">whitespace</span><span>, </span><span class="identifier">string</span><span>, </span><span class="identifier">item</span><span>, </span><span class="identifier">endOfLine</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">manyTill</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">errors</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="type-name">ErrorMethods</span><span> </span><span class="comment">//for hide
</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">symbol</span><span>(</span><span class="identifier">str</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">String</span><span>] = </span><span class="identifier">atomic</span><span>(</span><span class="identifier">string</span><span>(</span><span class="identifier">str</span><span>))

</span><span class="keyword">val</span><span> </span><span class="identifier">lineComment</span><span> = </span><span class="identifier">symbol</span><span>(</span><span class="string-literal">&quot;//&quot;</span><span>) ~&gt; </span><span class="identifier">manyTill</span><span>(</span><span class="identifier">item</span><span>, </span><span class="identifier">endOfLine</span><span>).</span><span class="identifier">void</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">multiComment</span><span> = </span><span class="identifier">symbol</span><span>(</span><span class="string-literal">&quot;/*&quot;</span><span>) ~&gt; </span><span class="identifier">manyTill</span><span>(</span><span class="identifier">item</span><span>, </span><span class="identifier">symbol</span><span>(</span><span class="string-literal">&quot;*/&quot;</span><span>)).</span><span class="identifier">void</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">comment</span><span> = </span><span class="identifier">lineComment</span><span> | </span><span class="identifier">multiComment</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">skipWhitespace</span><span> = </span><span class="identifier">many</span><span>(</span><span class="identifier">whitespace</span><span>.</span><span class="identifier">void</span><span> | </span><span class="identifier">comment</span><span>).</span><span class="identifier">void</span><span>.</span><span class="identifier">hide</span></code></pre>
        <p>Here, the <code>manyTill</code> combinator is used to read up until the end of the comment. You may
        notice the <code>hide</code> method having been called on <code>skipWhitespace</code>. This handy operation
        hides the &quot;expected&quot; error message from a given parser. In other words, when we have a
        parse error, it isn&#39;t particularly useful to see in the suggestions of what would have
        worked that we could type some whitespace! Producing informative and tidy error messages,
        however, is a more general topic for another post. Now that we have the <code>skipWhitespace</code>
        parser we can start using it!</p>
        
        <h2 id="lexemes" class="section"><a class="anchor-link left" href="#lexemes"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">2 </span>Lexemes</h2>
        <p>Lexemes are indivisible chunks of the input, the sort usually produced by a lexer in a
        classical setup. The <code>symbol</code> combinator I defined above forms part of this: it uses <code>atomic</code>
        to make an indivisible string, either you read the entire thing or none of it. The next piece
        of the puzzle is a combinator called <code>lexeme</code>, which should perform a parser and then always
        read spaces after it:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">lexeme</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">p</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="identifier">p</span><span> &lt;~ </span><span class="identifier">skipWhitespace</span><span>
</span><span class="keyword">def</span><span> </span><span class="declaration-name">token</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">p</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="identifier">lexeme</span><span>(</span><span class="identifier">atomic</span><span>(</span><span class="identifier">p</span><span>))

</span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">implicitSymbol</span><span>(</span><span class="identifier">s</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">String</span><span>] = </span><span class="identifier">lexeme</span><span>(</span><span class="identifier">symbol</span><span>(</span><span class="identifier">s</span><span>))</span></code></pre>
        <p>The <code>token</code> combinator is a more general form of <code>symbol</code>, that works for all parsers, handling
        them atomically <em>and</em> consuming whitespace after. Note that it&#39;s important to consume the whitespace
        outside the scope of the <code>atomic</code>, otherwise malformed whitespace might cause backtracking for an
        otherwise legal token!</p>
        <p>With the <code>implicitSymbol</code> combinator, we can now treat all string literals as lexemes. This
        can be very useful, but ideally this could be improved by also recognising whether or not the
        provided string is a keyword, and if so, ensuring that it is not followed by another
        alphabetical character. This is out of scope for this post, however.</p>
        <p>Now let&#39;s take the example
        from <a href="building-expression-parsers.html#building-expression-parsers">Building Expression Parsers</a> and see what needs to change to finish up recognising whitespace.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">digit</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.{</span><span class="identifier">precedence</span><span>, </span><span class="type-name">Ops</span><span>, </span><span class="type-name">InfixL</span><span>}

</span><span class="keyword">val</span><span> </span><span class="identifier">number</span><span> = </span><span class="identifier">token</span><span>(</span><span class="identifier">digit</span><span>.</span><span class="identifier">foldLeft1</span><span>[</span><span class="type-name">BigInt</span><span>](</span><span class="number-literal">0</span><span>)((</span><span class="identifier">n</span><span>, </span><span class="identifier">d</span><span>) =&gt; </span><span class="identifier">n</span><span> * </span><span class="number-literal">10</span><span> + </span><span class="identifier">d</span><span>.</span><span class="identifier">asDigit</span><span>))
</span><span class="comment">// number: Parsley[BigInt] = parsley.Parsley@1f0492e2
</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">atom</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">BigInt</span><span>] = </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">expr</span><span> &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span> | </span><span class="identifier">number</span><span>
</span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span> = </span><span class="identifier">precedence</span><span>[</span><span class="type-name">BigInt</span><span>](</span><span class="identifier">atom</span><span>)(
  </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="string-literal">&quot;*&quot;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> * </span><span class="identifier">_</span><span>)),
  </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="string-literal">&quot;+&quot;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> + </span><span class="identifier">_</span><span>), </span><span class="string-literal">&quot;-&quot;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> - </span><span class="identifier">_</span><span>)))</span></code></pre>
        <p>Other than introducing our new infrastructure, I&#39;ve changed the characters in the original
        parser to strings: this is going to make them use our new <code>implicitLexeme</code> combinator! Notice
        how I&#39;ve also marked the <em>whole</em> of <code>number</code> as a token: we don&#39;t want to read whitespace
        between the digits, but instead after the entire number has been read, and a number should be entirely
        atomic. Now that we&#39;ve done this we can try running it on some input and see what happens:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">expr</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;5 + </span><span class="escape-sequence">\n</span><span class="string-literal">6 /*hello!*/ * 7&quot;</span><span>)
</span><span class="comment">// res0: parsley.Result[String, BigInt] = Success(47)
</span><span>
</span><span class="identifier">expr</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot; 5 * (</span><span class="escape-sequence">\n</span><span class="string-literal">2 + 3)&quot;</span><span>)
</span><span class="comment">// res1: parsley.Result[String, BigInt] = Failure((line 1, column 1):
//   unexpected space
//   expected &quot;(&quot; or digit
//   &gt; 5 * (
//    ^
//   &gt;2 + 3))</span></code></pre>
        <p>Ah, we&#39;ve forgotten one last bit! The way we&#39;ve set it up so far is that every lexeme reads
        whitespace <em>after</em> the token. This is nice and consistent and reduces any unnecessary extra
        work reading whitespace before and after a token (which inevitably means whitespace will be
        unnecessarily checked in between tokens <em>twice</em>). But this means we have to be careful to
        read whitespace once at the very beginning of the parser. Using <code>skipWhitespace ~&gt; expr</code> as
        our parser we run is the final step we need to make it all work. If we use <code>expr</code> in another
        parser, however, we don&#39;t want to read the whitespace at the beginning in that case. It should
        <strong>only</strong> be at the very start of the parser (so when <code>parse</code> is called).</p>
        
        <h2 id="a-problem-with-scope" class="section"><a class="anchor-link left" href="#a-problem-with-scope"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">3 </span>A Problem with Scope</h2>
        <p>The eagle-eyed reader might have spotted that there is a distinction between the string literals we
        are using in the main parser and the <code>symbol</code>s we are using in the definitions of whitespace. Indeed,
        because we are using an implicit that consumes whitespace, it would be inappropriate
        to use it in the <em>definition</em> of whitespace! If we were to pull in the <code>stringLift</code> implicit as we&#39;re
        used to, then Scala will report and ambiguous implicit and we&#39;ll be stuck. It&#39;s a <em>much</em> better idea
        to limit the scope of these implicits, so we can be clear about which we mean where. To illustrate
        what I mean, let&#39;s restructure the code a little for the parser and ensure we don&#39;t run into any issues.</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>, </span><span class="type-name">Parsley</span><span>.{</span><span class="identifier">atomic</span><span>, </span><span class="identifier">eof</span><span>, </span><span class="identifier">many</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.{</span><span class="identifier">digit</span><span>, </span><span class="identifier">whitespace</span><span>, </span><span class="identifier">string</span><span>, </span><span class="identifier">item</span><span>, </span><span class="identifier">endOfLine</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">manyTill</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.{</span><span class="identifier">precedence</span><span>, </span><span class="type-name">Ops</span><span>, </span><span class="type-name">InfixL</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">errors</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="type-name">ErrorMethods</span><span> </span><span class="comment">//for hide
</span><span>
</span><span class="keyword">object</span><span> </span><span class="identifier">lexer</span><span> {
    </span><span class="keyword">private</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">symbol</span><span>(</span><span class="identifier">str</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">String</span><span>] = </span><span class="identifier">atomic</span><span>(</span><span class="identifier">string</span><span>(</span><span class="identifier">str</span><span>))

    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">lineComment</span><span> = </span><span class="identifier">symbol</span><span>(</span><span class="string-literal">&quot;//&quot;</span><span>) ~&gt; </span><span class="identifier">manyTill</span><span>(</span><span class="identifier">item</span><span>, </span><span class="identifier">endOfLine</span><span>).</span><span class="identifier">void</span><span>
    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">multiComment</span><span> = </span><span class="identifier">symbol</span><span>(</span><span class="string-literal">&quot;/*&quot;</span><span>) ~&gt; </span><span class="identifier">manyTill</span><span>(</span><span class="identifier">item</span><span>, </span><span class="identifier">symbol</span><span>(</span><span class="string-literal">&quot;*/&quot;</span><span>)).</span><span class="identifier">void</span><span>
    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">comment</span><span> = </span><span class="identifier">lineComment</span><span> | </span><span class="identifier">multiComment</span><span>
    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">skipWhitespace</span><span> = </span><span class="identifier">many</span><span>(</span><span class="identifier">whitespace</span><span>.</span><span class="identifier">void</span><span> | </span><span class="identifier">comment</span><span>).</span><span class="identifier">void</span><span>.</span><span class="identifier">hide</span><span>

    </span><span class="keyword">private</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">lexeme</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">p</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="identifier">p</span><span> &lt;~ </span><span class="identifier">skipWhitespace</span><span>
    </span><span class="keyword">private</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">token</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">p</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="identifier">lexeme</span><span>(</span><span class="identifier">atomic</span><span>(</span><span class="identifier">p</span><span>))
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">fully</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">p</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="identifier">skipWhitespace</span><span> ~&gt; </span><span class="identifier">p</span><span> &lt;~ </span><span class="identifier">eof</span><span>

    </span><span class="keyword">val</span><span> </span><span class="identifier">number</span><span> = </span><span class="identifier">token</span><span>(</span><span class="identifier">digit</span><span>.</span><span class="identifier">foldLeft1</span><span>[</span><span class="type-name">BigInt</span><span>](</span><span class="number-literal">0</span><span>)((</span><span class="identifier">n</span><span>, </span><span class="identifier">d</span><span>) =&gt; </span><span class="identifier">n</span><span> * </span><span class="number-literal">10</span><span> + </span><span class="identifier">d</span><span>.</span><span class="identifier">asDigit</span><span>))

    </span><span class="keyword">object</span><span> </span><span class="identifier">implicits</span><span> {
        </span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">implicitSymbol</span><span>(</span><span class="identifier">s</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">String</span><span>] =
            </span><span class="identifier">lexeme</span><span>(</span><span class="identifier">symbol</span><span>(</span><span class="identifier">s</span><span>)) </span><span class="comment">// or `token(string(s))
</span><span>    }
}

</span><span class="keyword">object</span><span> </span><span class="identifier">expressions</span><span> {
    </span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">implicitSymbol</span><span>
    </span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.{</span><span class="identifier">number</span><span>, </span><span class="identifier">fully</span><span>}

    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">atom</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">BigInt</span><span>] = </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">expr</span><span> &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span> | </span><span class="identifier">number</span><span>
    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span> = </span><span class="identifier">precedence</span><span>[</span><span class="type-name">BigInt</span><span>](</span><span class="identifier">atom</span><span>)(
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="string-literal">&quot;*&quot;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> * </span><span class="identifier">_</span><span>)),
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="string-literal">&quot;+&quot;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> + </span><span class="identifier">_</span><span>), </span><span class="string-literal">&quot;-&quot;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> - </span><span class="identifier">_</span><span>)))

    </span><span class="keyword">val</span><span> </span><span class="identifier">parser</span><span> = </span><span class="identifier">fully</span><span>(</span><span class="identifier">expr</span><span>)
}</span></code></pre>
        <p>In the above refactoring, I&#39;ve introduced three distinct scopes: the <code>lexer</code>, the <code>lexer.implicits</code>
        and the <code>expressions</code>. Within <code>lexer</code>, I&#39;ve marked the internal parts as <code>private</code>, in particular
        the <code>implicitSymbol</code> combinator that I&#39;ve introduced to allow the lexer to use string literals in
        the description of the tokens. By marking <code>implicitSymbol</code> as <code>private</code>, we ensure that it cannot be
        accidentally used within <code>expressions</code>, where the main part of the parser is defined. In contrast,
        the <code>implicits</code> object nested within <code>lexer</code> provides the ability for the <code>expressions</code> object to
        hook into our whitespace sensitive string literal parsing (using <code>implicitToken</code>), and, but
        enclosing it within the object, we prevent it being accidentally used inside the rest of the lexer
        (without an explicit import, which we know would be bad!). This is a good general structure to adopt,
        as it keeps the lexing code cleanly separated from the parser. If, for instance, you wanted to test
        these internals, then you could leave them public, but I would advise adding a private to its
        internal implicits at <em>all</em> times (however, ScalaTest does have the ability to test <code>private</code> members!)</p>

        
<hr class="footer-rule"/>
<footer>
  Parsley is distributed under the <a href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a> license.
</footer>


      </main>

    </div>

  </body>

</html>