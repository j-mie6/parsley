<!DOCTYPE html>
<html lang="en">
  
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Typelevel Laika + Parsley Theme" />
    
    <title>Parser Combinator Tutorial</title>
    
    
    <meta name="author" content="parsley contributors"/>
    
    
    <meta name="description" content="Roadmap of the parser combinator tutorial."/>
    
    
    
    <link rel="icon" sizes="32x32" type="image/svg+xml" href="../../icons/greenLeaf.svg"/>
    
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
    
    <link rel="stylesheet" type="text/css" href="../../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../../css/parsley-style.css" />
    <script src="../../helium/site/laika-helium.js"></script>
    <script src="../../helium/site/laika-versions.js"></script>
    <script>initVersions("../../", "/tutorial/index.html", "5.0", null);</script>
    
    <script> /* for avoiding page load transitions */ </script>
  </head>


  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    <div class="menu-container version-menu">
      <a class="text-link menu-toggle" href="#">Version 5.0.x</a>
      <nav class="menu-content">
        <ul class="nav-list">
        </ul>
      </nav>
    </div>
  </div>

  <a class="icon-link svg-link" href="../../"><span class="leaf" title="Home"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 128 128" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M101.39,86.21c-14.25-5.91-22.34-4.3-28.47-2.5c-6.5,1.91-12.31,8.58-12.31,8.58s-1.93-0.58-5.04-0.51 c-1.49,0.04-2.67,0.28-3.54,0.54c2.64-5.99,4.51-12.08,7.57-18.76c1.95-0.81,4.63-1.86,6.35-2.23c2.96-0.64,6.45-0.84,6.45-0.84 c0.82,0.64,2,1.39,3.69,2.23c9.56,4.78,21.5,2.16,27.35-0.16c8.13-3.23,20.21-12.95,20.21-13.69s-5.5-3.38-13.32-5.71 c-7.82-2.33-18.27-2.44-26.21,0.95c-7.28,3.11-10.67,8.58-12.54,11.86c0,0-2.9,0.46-5,0.82c-1.56,0.27-2.96,0.64-4.07,0.99 c0.22-0.4,0.45-0.81,0.68-1.21C67.77,58.61,72.83,52.5,77,48.2c5.87,0.55,17.89,0.35,27.62-8.46 c15.64-14.15,18.46-35.92,18.07-36.35S97.35,3.34,84.54,14.91c-12.19,11.01-11.97,25.4-11.4,30.69c-3.97,3.71-8.81,9.17-14.2,17.12 c-0.04-2.12-0.29-4.73-0.29-4.73s7.19-6.73,7.72-17.18c0.42-8.24-0.46-15.89-5-24.14c-3.56-6.43-6.53-8.03-7.06-7.93 c-0.93,0.19-5.33,7.06-8.03,13.63c-2.13,5.17-4.26,18.38-0.45,26.52s8.22,9.68,8.22,9.68s0.54,2.37,0.48,5.55 c-0.02,1.36-0.13,4.51-0.18,5.98c-3.57,6.32-5.96,12.07-8.23,17.22c-0.34-0.99-0.73-1.96-1.11-2.65c-1.16-2.11-1.59-2.85-1.59-2.85 s2.57-15.99-1.8-29.17C36.45,37,27.57,31.08,19.33,27.59C11.09,24.1,6.54,24.11,5.8,24.95c-1.08,1.23,1.37,4.33,1.59,11.31 c0.17,5.71,1.16,25.05,6.87,34.98s13.63,12.37,16.17,13.21c2.54,0.85,8.03,0.95,8.03,0.95s2.33,2.01,3.17,4.86 c0.39,1.31,0.78,2.92,1.09,4.27c-1.95,3.71-4.17,7-7.21,9.86c-5.01,4.71-13.09,7.94-13.09,7.94s-6.47-0.15-6.91,0.15 c-0.44,0.29-1.73,3.53,0.69,7.51c2,3.29,5.05,4.12,6.08,4.26c1.03,0.15,2.94-4.27,3.68-4.86c0.74-0.59,9.43-3.93,15.6-10.74 c2.83-3.13,5.02-6.16,6.81-9.17c1.65-1.01,4.07-2.17,6.72-2.31c2.64-0.15,4.94,1.12,4.94,1.12s2.22,9.16,12.15,13 c12.5,4.83,25.83,0.61,31.64-1.4c5.81-2,19.83-8.42,19.94-10.22C123.86,97.87,115.66,92.13,101.39,86.21z"/>
  </g>
</svg></span></a>

  <div class="row links">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/5.0.0-M14/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/5.0.0-M14/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../../downloads.html">Documentation Downloads</a></li>
    <li class="level1 nav-leaf"><a href="../../home.html">Home</a></li>
    <li class="level1 nav-leaf"><a href="../faq.html">FAQ</a></li>
    <li class="level1 nav-leaf"><a href="../cheatsheet.html">Cheatsheet</a></li>
    <li class="level1 nav-node"><a href="../api-guide/">Understanding the API</a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/Parsley.html"><code>parsley.Parsley</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/character.html"><code>parsley.character</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/combinator.html"><code>parsley.combinator</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/generic.html"><code>parsley.generic</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/syntax.html"><code>parsley.syntax</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/position.html"><code>parsley.position</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/state.html"><code>parsley.state</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/debug.html"><code>parsley.debug</code></a></li>
    <li class="level2 nav-header"><code>parsley.expr</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/chain.html"><code>chain</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/infix.html"><code>infix</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/precedence.html"><code>precedence</code></a></li>
    <li class="level2 nav-header"><code>parsley.token</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/Lexer.html"><code>Lexer</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/descriptions.html"><code>descriptions</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/errors.html"><code>errors</code></a></li>
    <li class="level2 nav-header"><code>parsley.errors</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/combinator.html"><code>combinator</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/patterns.html"><code>patterns</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/ErrorBuilder.html"><code>ErrorBuilder</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/tokenextractors.html"><code>tokenextractors</code></a></li>
    <li class="level1 active nav-node"><a href="#">Parser Combinator Tutorial</a></li>
    <li class="level2 nav-leaf"><a href="basics-of-combinators.html">Basics of Combinators</a></li>
    <li class="level2 nav-leaf"><a href="building-expression-parsers.html">Building Expression Parsers</a></li>
    <li class="level2 nav-leaf"><a href="effective-whitespace-parsing.html">Effective Whitespace Parsing</a></li>
    <li class="level2 nav-leaf"><a href="effective-lexing.html">Effective Lexing</a></li>
    <li class="level2 nav-leaf"><a href="parser-bridge-pattern.html">The Parser Bridge Pattern</a></li>
    <li class="level2 nav-leaf"><a href="interlude-1-haskell.html">Interlude 1: Building a Parser for Haskell</a></li>
    <li class="level2 nav-leaf"><a href="customising-error-messages.html">Customising Error Messages</a></li>
    <li class="level2 nav-leaf"><a href="advanced-error-messages.html">Advanced Error Messages</a></li>
    <li class="level1 nav-header">parsley-debug</li>
    <li class="level2 nav-leaf"><a href="../parsley-debug/debuggable.html"><code>@parsley.debuggable</code></a></li>
    <li class="level2 nav-leaf"><a href="../parsley-debug/attachment.html">Attaching Debugger Views</a></li>
    <li class="level2 nav-header">Debug Views</li>
    <li class="level3 nav-leaf"><a href="../parsley-debug/debug-views/PrintView.html"><code>PrintView</code></a></li>
    <li class="level2 nav-leaf"><a href="../../parsley-debug/recursion-detection.html">Detecting Left Recursion</a></li>
    <li class="level1 nav-header">Related Projects</li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/parsley-cats">parsley-cats</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/gigaparsec">gigaparsec (Haskell)</a></li>
  </ul>

</nav>

    <div id="container">

      

      <main class="content">

        <h1 id="parser-combinator-tutorial" class="title">Parser Combinator Tutorial</h1>
        <p>Parsley is a <em>parser combinator library</em>.  In contrast to a parser generator library, like
        ANTLR, this allows the users to build their parsers as part of the host language: in this case
        Scala. This brings a huge amount of power to the fingertips of the programmer, but, admittedly,
        embarking on the journey to learning how they work is very intimidating! Personally, I think
        the pay-off is still great, and, really, it&#39;s quite hard to see why until after you&#39;ve tried
        it. The most important part is not being afraid to play with things.</p>
        <p>This series of wiki posts aims to help guide you on your journey to learning parser
        combinators. Unfortunately, while the fundamentals carry nicely over to other libraries, such
        as <code>parsec</code>, <code>megaparsec</code> and so on in Haskell (and to a lesser extent the other Scala
        libraries, which admittedly have a slightly different feel to them), learning a parser
        combinator library is still a specialism, and many of the helpful abstractions and patterns
        that Parsley provides may not be available or even possible in some other contexts.</p>
        <p>Something I&#39;ve learnt about this wiki is that people can take it fairly literally at each step
        instead of viewing each page as a larger whole. The consequence is that some of the neat
        techniques that are presented later in the series may have come too late, and users may have
        already implemented something the &quot;long way&quot;. My advice is to <strong>keep reading</strong> until the end
        before embarking on any serious work using the library. Of course, you don&#39;t have to, but I&#39;ve
        distilled <em>years</em> of knowledge into this wiki, and it would be a shame to miss out on it. To
        try and make this process easier, I&#39;ve added a road-map of sorts below, to help you understand
        the whole story before you start it.</p>
        
        <h2 id="the-roadmap" class="section"><a class="anchor-link left" href="#the-roadmap"><i class="icofont-laika link">&#xef71;</i></a>The Roadmap</h2>
        
        <h3 id="basics-of-combinators" class="section"><a class="anchor-link left" href="#basics-of-combinators"><i class="icofont-laika link">&#xef71;</i></a>Basics of Combinators</h3>
        <p>Our journey starts at the beginning: the very beginning. In many respects, this first post
        probably goes into too much detail. However, I think it&#39;s very important to see the lower level
        primitives to be able to understand the more powerful and convenient abstractions. In
        particular, the nuances of backtracking can have a big effect on the error messages of even
        correct parsers, so understanding <em>how</em> and <em>when</em> to backtrack is an important skill. That
        being said, the way that parsers are written in this post are <strong>not</strong> representative of how
        parsers really <strong>should</strong> be written! Instead it demonstrates some recurring <em>themes</em> and some
        of the most important ideas.</p>
        
        <h3 id="building-expression-parsers-introduces-expr-precedence" class="section"><a class="anchor-link left" href="#building-expression-parsers-introduces-expr-precedence"><i class="icofont-laika link">&#xef71;</i></a>Building Expression Parsers (<em>introduces</em> <code>expr.precedence</code>)</h3>
        <p>By the end of the first post, the basic combinators, recursion and the main principles of
        combinators have been demonstrated. However, the final example, which sees us write a parser
        for boolean expressions, leaves much to be desired. For the uninitiated reader, they&#39;ll see
        nothing wrong with it, but as the second page shows, there are much easier and more powerful
        tools at our disposal for working with expressions. Again, this page starts by showing off the
        fundamental building blocks of the expression parser before showing the more commonly used
        <code>precedence</code> combinator. The reason I chose to take this route is similar to before, it&#39;s good
        to be able to have a sense of how the more powerful tools were built up, and there are often
        opportunities to use these combinators where a <code>precedence</code> (which takes the center stage) is
        just a bit more clunky.</p>
        <p>Be warned that this page doesn&#39;t re-introduce any of the material of the previous page, so if a
        combinator is used without being explained, you can always check back to the first post (or the
        cheatsheet). Also you should be aware that the latter half of the post gets a bit more
        technical than most people will a) need to know and b) care about. The reason these sections
        were left in was to help the many people who don&#39;t like to blindly accept concepts presented to
        them without having a, however basic, understanding of how it works. If you&#39;re not one of those
        people, or you&#39;re otherwise not interested, then you can feel free to move on to the next page
        at the section <em>Path-Dependent Typing and <code>Ops</code>/<code>Gops</code></em>.</p>
        
        <h3 id="effective-whitespace-parsing" class="section"><a class="anchor-link left" href="#effective-whitespace-parsing"><i class="icofont-laika link">&#xef71;</i></a>Effective Whitespace Parsing</h3>
        <p>By the third post, we take a (welcome) break from learning new combinators and concepts, and
        instead discuss good parser <em>design</em>, and the best ways to deal with pesky whitespace in the
        input: from the first two posts, we&#39;ll already have seen all the tools we need to write correct
        parsers, just not the <em>best</em> ways to do so.</p>
        <p>Whitespace, simply put, is annoying because it distracts from the rest of the grammar.
        Normally, a lexer is used to deal with whitespace, and the grammar more accurately describes
        the relationships between tokens. The basic idea behind this page is to demonstrate how we can
        start to use Scala&#39;s features to develop handy abstractions for ourselves that make whitespace
        disappear from the main parser. Again, there are better tools for dealing with these issues
        than hand-rolling them ourselves, but in order to use such tools effectively and really
        understand their implication, it&#39;s a very good idea to understand the fundamentals: the
        <strong>fourth</strong> page more effectively deals with the issues highlighted in this page <em>and</em> uses some
        of the techniques introduced, in the process refining them.</p>
        
        <h3 id="effective-lexing-introduces-lexer" class="section"><a class="anchor-link left" href="#effective-lexing-introduces-lexer"><i class="icofont-laika link">&#xef71;</i></a>Effective Lexing (<em>introduces</em> <code>Lexer</code>)</h3>
        <p>The fourth post builds on the ideas of its predecessor, first outlining the general principles
        behind how we write and structure the lexical parsers for our grammar, and then how to
        seemlessly integrate them into the parser proper. The ideas here are very similar to those
        already laid out previously.</p>
        <p>Unlike the third post, here the mighty <code>Lexer</code> class is introduced. While it&#39;s not always
        needed to write parsers, its usefulness, even for just handling whitespace, can&#39;t be
        understated. It&#39;s not always the right tool for the job though, so definitely don&#39;t disregard
        all the lessons presented before it!</p>
        
        <h3 id="the-parser-bridges-pattern-introduces-position-tracking-with-line-col-and-pos" class="section"><a class="anchor-link left" href="#the-parser-bridges-pattern-introduces-position-tracking-with-line-col-and-pos"><i class="icofont-laika link">&#xef71;</i></a>The <em>Parser Bridges</em> Pattern (<em>introduces position tracking with</em> <code>line</code><em>,</em> <code>col</code><em>, and</em> <code>pos</code>)</h3>
        <p>This page takes a huge leap forward in terms of how parsers are designed and integrated with
        the Abstract Syntax Trees they so often produce. An important (and often overlooked) aspect of
        parsing with combinators is how position information in the parser is preserved in the
        generated structure. In my experience, I&#39;ve found this is often done as an afterthought, when
        the programmer realises that the information is important: for instance, when performing
        Semantic Analysis in a compiler... And, usually, its introduction makes a complete mess of an otherwise nice looking parser.</p>
        <p>The joy of the <em>Parser Bridges</em> pattern, which this page introduces, is that it separates the building
        of the AST during parsing from whether or not that AST node needs position information, or
        indeed the mechanics of putting together the components in the right way. This separation
        creates a pleasant cleanliness in the main body of the grammar, which by this point now retains
        the simple elegance we might expect to see with a plain old BNF representation. If you&#39;ve been
        unconvinced so far that parser combinators look very similar to the grammar they represent,
        this may change your perspective.</p>
        
        <h3 id="interlude-1-building-a-parser-for-haskell" class="section"><a class="anchor-link left" href="#interlude-1-building-a-parser-for-haskell"><i class="icofont-laika link">&#xef71;</i></a><em>Interlude 1</em>: Building a Parser for Haskell</h3>
        <p>By this point, you&#39;ll have covered a lot of information:</p>
        <ul>
          <li>Basics of what combinators are and what they are built from</li>
          <li>Cleanly handing expressions with varying precedence and associativities</li>
          <li>How to correctly deal with whitespace</li>
          <li>How to cleanly factor out lexing logic</li>
          <li>How to abstract away the construction of a resulting AST from the grammar</li>
        </ul>
        <p>With this wealth of knowledge, you&#39;ll have the power to go and write all but the trickiest
        of parsers. To demonstrate that, the first of three interludes will work through the structure
        and design of a (simplified) Haskell parser with the tools we&#39;ve accrued so far. Even though
        this will help consolidate everything you&#39;ve been shown by putting it all into practice, there
        is still a big chunk of the story missing: error messages.</p>
        
        <h3 id="customising-error-messages-introduces-label-explain-and-errorbuilder" class="section"><a class="anchor-link left" href="#customising-error-messages-introduces-label-explain-and-errorbuilder"><i class="icofont-laika link">&#xef71;</i></a>Customising Error Messages (<em>introduces</em> <code>label</code>, <code>explain</code>, <em>and</em> <code>ErrorBuilder</code>)</h3>
        <p>With the mechanics of writing parsers that can <em>succeed</em> out of the way, it&#39;s about time to
        learn about how to improve error messages that <em>failing</em> parsers produce. By default, the error
        messages, whilst not <em>bad</em>, aren&#39;t nearly as they could be. The <code>Lexer</code> class does help with
        this for lexemes at least, but that doesn&#39;t mean all the work is done: especially in the main
        grammar, or for times when <code>Lexer</code> was a no-go. Writing good error messages is an art-form, and
        so this page takes a more subjective look at the process. For most people, this is just about as
        far as you&#39;d need to go.</p>
        <p>The second part of this post explains how to use the <code>ErrorBuilder</code> mechanism in Parsley to
        customise the format of error messages, or even change what type they have. This can be particularly
        useful for unit-testing or for standardising parser error messages as part of a larger compiler.</p>
        
        <h3 id="advanced-error-messages-introduces-unexpected-and-fail" class="section"><a class="anchor-link left" href="#advanced-error-messages-introduces-unexpected-and-fail"><i class="icofont-laika link">&#xef71;</i></a>Advanced Error Messages (<em>introduces</em> <code>unexpected</code> <em>and</em> <code>fail</code>)</h3>
        <p>The combinators introduced in the previous page are already pretty good! But there are still
        some neat patterns we can use to kick it up a notch or two. In particular, this page introduces
        patterns that can be used to <em>anticipate</em> common syntax errors and produce much more
        descriptive errors upon encountering them.</p>
        
        <h3 id="interlude-2-adding-errors-to-the-haskell-parser" class="section"><a class="anchor-link left" href="#interlude-2-adding-errors-to-the-haskell-parser"><i class="icofont-laika link">&#xef71;</i></a><em>Interlude 2</em>: Adding Errors to the Haskell Parser</h3>
        <p>The second interlude takes the new-found lessons from the previous two pages to augment the
        Haskell parser with error messages, illustrating the considerations and patterns in practice.
        The reason that Interlude 1 comes before error messages is that, whilst they aren&#39;t
        particularly obstructive, the error message combinators provide a little extra noise that makes
        the core part of the parser a little bit harder to admire, especially for someone who is only
        getting to grips with the concepts for the very first time!</p>
        <p>This, for almost all use-cases, the end of the story. By this point you&#39;ll have all the tools
        you need to parse context-free grammars, which make up the vast majority of practical languages
        and data formats <em>and</em> generate good error messages for them. If however, you are keen to learn
        about context-sensitive grammars, or you are thoroughly engrossed in the story up to this
        point, there is one final stretch.</p>
        
        <h3 id="indentation-sensitive-parsing" class="section"><a class="anchor-link left" href="#indentation-sensitive-parsing"><i class="icofont-laika link">&#xef71;</i></a>Indentation Sensitive Parsing</h3>
        <p>For most languages, the grammar is constructed in such a way that it remains context-free. This
        is, primarily, because context-sensitive grammars are a brutal combination of hard to express
        and hard to parse efficiently. Indentation-sensitive parsing <em>can</em> be considered an example of
        a context-sensitive grammar, though, in practice, some compilers like to shunt the work out to
        the lexer to make the grammar context-free again (this is the case with Python).</p>
        <p>Using parser combinators though, context-sensitive grammars can be encoded comparatively
        naturally! In most other combinator libraries, the <code>flatMap</code> (or <code>&gt;&gt;=</code>) combinator is used to
        deal with context-sensitivity. However, in the Parsley family, the power that <code>flatMap</code>
        provides comes at a heavy cost to performance. Instead, we reach for stateful parsers called
        &quot;references&quot;, evoking images of register machines vs stack machines: as we know, register
        machines are turing powerful, and can most certainly do the job, no matter the parsing task.</p>
        <p>This page provides a more concrete and gentle introduction to using references specifically
        demonstrating how to use them to implement combinators for managing indentation-sensitive
        workloads in a clean and effective way.</p>
        
        <h3 id="interlude-3-supporting-the-haskell-offside-rule" class="section"><a class="anchor-link left" href="#interlude-3-supporting-the-haskell-offside-rule"><i class="icofont-laika link">&#xef71;</i></a><em>Interlude 3</em>: Supporting the Haskell Offside Rule</h3>
        <p>As the final act of this series, the last &quot;interlude&quot; (by this point just a finale) takes the
        combinators built up in the previous page to add the off-side rule to the Haskell parser: this is
        the essence of Haskell&#39;s indentation-sensitive syntax.</p>

        
<hr class="footer-rule"/>
<footer>
  Parsley is distributed under the <a href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a> license.
</footer>


      </main>

    </div>

  </body>

</html>