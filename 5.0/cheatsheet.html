<!DOCTYPE html>
<html lang="en">
  
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Typelevel Laika + Parsley Theme" />
    
    <title>Cheatsheet</title>
    
    
    <meta name="author" content="parsley contributors"/>
    
    
    <meta name="description" content="Cheatsheet of common combinators and uses."/>
    
    
    
    <link rel="icon" sizes="32x32" type="image/svg+xml" href="../icons/greenLeaf.svg"/>
    
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
    
    <link rel="stylesheet" type="text/css" href="../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../css/parsley-style.css" />
    <script src="../helium/site/laika-helium.js"></script>
    <script src="../helium/site/laika-versions.js"></script>
    <script>initVersions("../", "/cheatsheet.html", "5.0", null);</script>
    
    <script> /* for avoiding page load transitions */ </script>
  </head>


  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    <div class="menu-container version-menu">
      <a class="text-link menu-toggle" href="#">Version 5.0.x</a>
      <nav class="menu-content">
        <ul class="nav-list">
        </ul>
      </nav>
    </div>
  </div>

  <a class="icon-link svg-link" href="../"><span class="leaf" title="Home"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 128 128" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M101.39,86.21c-14.25-5.91-22.34-4.3-28.47-2.5c-6.5,1.91-12.31,8.58-12.31,8.58s-1.93-0.58-5.04-0.51 c-1.49,0.04-2.67,0.28-3.54,0.54c2.64-5.99,4.51-12.08,7.57-18.76c1.95-0.81,4.63-1.86,6.35-2.23c2.96-0.64,6.45-0.84,6.45-0.84 c0.82,0.64,2,1.39,3.69,2.23c9.56,4.78,21.5,2.16,27.35-0.16c8.13-3.23,20.21-12.95,20.21-13.69s-5.5-3.38-13.32-5.71 c-7.82-2.33-18.27-2.44-26.21,0.95c-7.28,3.11-10.67,8.58-12.54,11.86c0,0-2.9,0.46-5,0.82c-1.56,0.27-2.96,0.64-4.07,0.99 c0.22-0.4,0.45-0.81,0.68-1.21C67.77,58.61,72.83,52.5,77,48.2c5.87,0.55,17.89,0.35,27.62-8.46 c15.64-14.15,18.46-35.92,18.07-36.35S97.35,3.34,84.54,14.91c-12.19,11.01-11.97,25.4-11.4,30.69c-3.97,3.71-8.81,9.17-14.2,17.12 c-0.04-2.12-0.29-4.73-0.29-4.73s7.19-6.73,7.72-17.18c0.42-8.24-0.46-15.89-5-24.14c-3.56-6.43-6.53-8.03-7.06-7.93 c-0.93,0.19-5.33,7.06-8.03,13.63c-2.13,5.17-4.26,18.38-0.45,26.52s8.22,9.68,8.22,9.68s0.54,2.37,0.48,5.55 c-0.02,1.36-0.13,4.51-0.18,5.98c-3.57,6.32-5.96,12.07-8.23,17.22c-0.34-0.99-0.73-1.96-1.11-2.65c-1.16-2.11-1.59-2.85-1.59-2.85 s2.57-15.99-1.8-29.17C36.45,37,27.57,31.08,19.33,27.59C11.09,24.1,6.54,24.11,5.8,24.95c-1.08,1.23,1.37,4.33,1.59,11.31 c0.17,5.71,1.16,25.05,6.87,34.98s13.63,12.37,16.17,13.21c2.54,0.85,8.03,0.95,8.03,0.95s2.33,2.01,3.17,4.86 c0.39,1.31,0.78,2.92,1.09,4.27c-1.95,3.71-4.17,7-7.21,9.86c-5.01,4.71-13.09,7.94-13.09,7.94s-6.47-0.15-6.91,0.15 c-0.44,0.29-1.73,3.53,0.69,7.51c2,3.29,5.05,4.12,6.08,4.26c1.03,0.15,2.94-4.27,3.68-4.86c0.74-0.59,9.43-3.93,15.6-10.74 c2.83-3.13,5.02-6.16,6.81-9.17c1.65-1.01,4.07-2.17,6.72-2.31c2.64-0.15,4.94,1.12,4.94,1.12s2.22,9.16,12.15,13 c12.5,4.83,25.83,0.61,31.64-1.4c5.81-2,19.83-8.42,19.94-10.22C123.86,97.87,115.66,92.13,101.39,86.21z"/>
  </g>
</svg></span></a>

  <div class="row links">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/5.0.0-M1/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/5.0.0-M1/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../downloads.html">Documentation Downloads</a></li>
    <li class="level1 nav-leaf"><a href="../home.html">Home</a></li>
    <li class="level1 nav-leaf"><a href="faq.html">FAQ</a></li>
    <li class="level1 active nav-leaf"><a href="#">Cheatsheet</a></li>
    <li class="level1 nav-node"><a href="api-guide/">Understanding the API</a></li>
    <li class="level2 nav-leaf"><a href="api-guide/Parsley.html"><code>parsley.Parsley</code></a></li>
    <li class="level2 nav-leaf"><a href="api-guide/character.html"><code>parsley.character</code></a></li>
    <li class="level2 nav-leaf"><a href="api-guide/combinator.html"><code>parsley.combinator</code></a></li>
    <li class="level2 nav-leaf"><a href="api-guide/generic.html"><code>parsley.generic</code></a></li>
    <li class="level2 nav-leaf"><a href="api-guide/syntax.html"><code>parsley.syntax</code></a></li>
    <li class="level2 nav-leaf"><a href="api-guide/position.html"><code>parsley.position</code></a></li>
    <li class="level2 nav-leaf"><a href="api-guide/state.html"><code>parsley.state</code></a></li>
    <li class="level2 nav-leaf"><a href="api-guide/debug.html"><code>parsley.debug</code></a></li>
    <li class="level2 nav-header"><code>parsley.expr</code></li>
    <li class="level3 nav-leaf"><a href="api-guide/expr/chain.html"><code>chain</code></a></li>
    <li class="level3 nav-leaf"><a href="api-guide/expr/infix.html"><code>infix</code></a></li>
    <li class="level3 nav-leaf"><a href="api-guide/expr/precedence.html"><code>precedence</code></a></li>
    <li class="level2 nav-header"><code>parsley.token</code></li>
    <li class="level3 nav-leaf"><a href="api-guide/token/Lexer.html"><code>Lexer</code></a></li>
    <li class="level3 nav-leaf"><a href="api-guide/token/descriptions.html"><code>descriptions</code></a></li>
    <li class="level3 nav-leaf"><a href="api-guide/token/errors.html"><code>errors</code></a></li>
    <li class="level2 nav-header"><code>parsley.errors</code></li>
    <li class="level3 nav-leaf"><a href="api-guide/errors/combinator.html"><code>combinator</code></a></li>
    <li class="level3 nav-leaf"><a href="api-guide/errors/patterns.html"><code>patterns</code></a></li>
    <li class="level3 nav-leaf"><a href="api-guide/errors/ErrorBuilder.html"><code>ErrorBuilder</code></a></li>
    <li class="level3 nav-leaf"><a href="api-guide/errors/tokenextractors.html"><code>tokenextractors</code></a></li>
    <li class="level1 nav-node"><a href="tutorial/">Parser Combinator Tutorial</a></li>
    <li class="level2 nav-leaf"><a href="tutorial/basics-of-combinators.html">Basics of Combinators</a></li>
    <li class="level2 nav-leaf"><a href="tutorial/building-expression-parsers.html">Building Expression Parsers</a></li>
    <li class="level2 nav-leaf"><a href="tutorial/effective-whitespace-parsing.html">Effective Whitespace Parsing</a></li>
    <li class="level2 nav-leaf"><a href="tutorial/effective-lexing.html">Effective Lexing</a></li>
    <li class="level2 nav-leaf"><a href="tutorial/parser-bridge-pattern.html">The Parser Bridge Pattern</a></li>
    <li class="level2 nav-leaf"><a href="tutorial/interlude-1-haskell.html">Interlude 1: Building a Parser for Haskell</a></li>
    <li class="level2 nav-leaf"><a href="tutorial/customising-error-messages.html">Customising Error Messages</a></li>
    <li class="level2 nav-leaf"><a href="tutorial/advanced-error-messages.html">Advanced Error Messages</a></li>
    <li class="level1 nav-header">Related Projects</li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/parsley-cats">parsley-cats</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/gigaparsec">gigaparsec (Haskell)</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#">Cheatsheet</a></p>

  <ul class="nav-list">
    <li class="level1 nav-node"><a href="#quick-documentation">Quick Documentation</a></li>
    <li class="level2 nav-leaf"><a href="#basic-combinators">Basic Combinators</a></li>
    <li class="level2 nav-leaf"><a href="#character-combinators">Character Combinators</a></li>
    <li class="level2 nav-leaf"><a href="#lifty-combinators">Lifty Combinators</a></li>
    <li class="level2 nav-leaf"><a href="#composite-combinators">Composite Combinators</a></li>
    <li class="level1 nav-node"><a href="#building-values-and-asts">Building Values and ASTs</a></li>
    <li class="level2 nav-leaf"><a href="#transforming-a-single-value-with-map">Transforming a single value with <code>map</code></a></li>
    <li class="level2 nav-leaf"><a href="#combining-multiple-results-with-lift-and-friends">Combining multiple results with <code>lift</code>, <code>&lt;::&gt;</code>, and friends</a></li>
  </ul>

  <p class="footer"><a href="https://github.com/j-mie6/parsley/blob/18428c686e24955f578cebb9bf1cbca0dca3f649/docs/cheatsheet.md"><i class="icofont-laika edit" title="Edit">&#xef10;</i>Source for this page</a></p>
</nav>


      <main class="content">

        <h1 id="parser-combinator-cheatsheet" class="title">Parser Combinator Cheatsheet</h1>
        <p>Until you&#39;re more comfortable using parser combinators and have a sense for how to piece things
        together, the sheer choice can be daunting. This page is designed to help bridge this gap by
        bringing attention to some of the more common and useful combinators, as well as a few common idioms
        for getting stuff done.</p>
        
        <h2 id="quick-documentation" class="section"><a class="anchor-link left" href="#quick-documentation"><i class="icofont-laika link">&#xef71;</i></a>Quick Documentation</h2>
        <p>This section is designed to give a quick reference for some of the most common combinators, their types
        as well as their use.</p>
        
        <h3 id="basic-combinators" class="section"><a class="anchor-link left" href="#basic-combinators"><i class="icofont-laika link">&#xef71;</i></a>Basic Combinators</h3>
        <p>These are the basic combinators for combining smaller parsers into bigger parsers, or adjusting their
        results. These combinators are sometimes lazy in their arguments, which is
        denoted here by the regular <em>by-name</em> (<code>=&gt;A</code>) syntax. If an argument is
        strict, it means that it will be parsed immediately on entry to the combinator
        before any input can be consumed.</p>
        <table>
          <thead>
            <tr>
              <th>Combinator</th>
              <th>Type</th>
              <th>Use</th>
              <th>Pronounciation</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>pure(_)</code></td>
              <td><code>A =&gt; Parsley[A]</code></td>
              <td>return a value of type <code>A</code> without parsing anything.</td>
              <td>&quot;pure&quot;</td>
            </tr>
            <tr>
              <td><code>_ *&gt; _</code> <br> <code>_ ~&gt; _</code></td>
              <td><code>( Parsley[A]</code><br><code>, =&gt;Parsley[B]</code><br><code>) =&gt; Parsley[B]</code></td>
              <td>sequence two parsers, returning the result of the <strong>second</strong>.</td>
              <td>&quot;then&quot;</td>
            </tr>
            <tr>
              <td><code>_ &lt;* _</code> <br> <code>_ &lt;~ _</code></td>
              <td><code>( Parsley[A]</code><br><code>, =&gt;Parsley[B]</code><br><code>) =&gt; Parsley[A]</code></td>
              <td>sequence two parsers, returning the result of the <strong>first</strong>.</td>
              <td>&quot;then discard&quot;</td>
            </tr>
            <tr>
              <td><code>_.map(_)</code></td>
              <td><code>( Parsley[A]</code><br><code>, A =&gt; B</code><br><code>) =&gt; Parsley[B]</code></td>
              <td>use a function to change the result of a parser.</td>
              <td>&quot;map&quot;</td>
            </tr>
            <tr>
              <td><code>_ &lt;#&gt; _</code></td>
              <td><code>( A =&gt; B</code><br><code>, Parsley[A]</code><br><code>) =&gt; Parsley[B]</code></td>
              <td>use a function to change the result of a parser. <br><br>(<em>Requires <code>import parsley.extension.HaskellStyleMap</code></em>)</td>
              <td>&quot;map&quot;</td>
            </tr>
            <tr>
              <td><code>_ #&gt; _</code> <br> <code>_.as(_)</code></td>
              <td><code>( Parsley[A]</code><br><code>, B</code><br><code>) =&gt; Parsley[B]</code></td>
              <td>replace the result of a parser with a fixed value.</td>
              <td>&quot;as&quot;</td>
            </tr>
            <tr>
              <td><code>liftN(_, .., _)</code></td>
              <td><code>( (A1, A2, .., An) =&gt; B</code><br><code>, Parsley[A1]</code><br><code>, =&gt;Parsley[A2]</code><br><code>, ..</code><br><code>, =&gt;Parsley[An]</code><br><code>) =&gt; Parsley[B]</code></td>
              <td>use a function to combine the results of <em>n</em> parsers, sequencing them all together.</td>
              <td>&quot;lift n&quot;</td>
            </tr>
            <tr>
              <td><code>_ &lt;|&gt; _</code> <br> <code>_  |  _</code></td>
              <td><code>( Parsley[A]</code><br><code>, =&gt;Parsley[A]</code><br><code>) =&gt; Parsley[A]</code></td>
              <td>try one parser, and if it fails <em>without consuming input</em> try the second</td>
              <td>&quot;or&quot;</td>
            </tr>
            <tr>
              <td><code>atomic(_)</code></td>
              <td><code>Parsley[A] =&gt; Parsley[A]</code></td>
              <td>perform a parser, but roll-back any consumed input if it fails, use in conjunction with <code>&lt;|&gt;</code>.</td>
              <td>&quot;atomic&quot;</td>
            </tr>
            <tr>
              <td><code>lookAhead(_)</code></td>
              <td><code>Parsley[A] =&gt; Parsley[A]</code></td>
              <td>execute a parser, and roll-back any consumed input if it <em>succeeded</em>.</td>
              <td>&quot;look-ahead&quot;</td>
            </tr>
            <tr>
              <td><code>notFollowedBy(_)</code></td>
              <td><code>Parsley[A] =&gt; Parsley[Unit]</code></td>
              <td>execute a parser, never consuming input: succeed only if the parser fails.</td>
              <td>&quot;not followed by&quot;</td>
            </tr>
            <tr>
              <td><code>empty</code></td>
              <td><code>Parsley[Nothing]</code></td>
              <td>fails when executed.</td>
              <td>&quot;empty&quot;</td>
            </tr>
          </tbody>
        </table>
        
        <h3 id="character-combinators" class="section"><a class="anchor-link left" href="#character-combinators"><i class="icofont-laika link">&#xef71;</i></a>Character Combinators</h3>
        <p>These combinators, found in <code>parsley.character</code> are useful for dealing with <em>actually</em> consuming input.</p>
        <table>
          <thead>
            <tr>
              <th>Combinator</th>
              <th>Type</th>
              <th>Use</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>char(_)</code></td>
              <td><code>Char =&gt; Parsley[Char]</code></td>
              <td>Reading a single specific character. That character is returned.</td>
            </tr>
            <tr>
              <td><code>string(_)</code></td>
              <td><code>String =&gt; Parsley[String]</code></td>
              <td>Reading a single specific string. That string is returned.</td>
            </tr>
            <tr>
              <td><code>satisfy(_)</code></td>
              <td><code>(Char =&gt; Boolean) =&gt; Parsley[Char]</code></td>
              <td>Read any single character for which the provided function returns <code>true</code>. The character returned is the one read.</td>
            </tr>
            <tr>
              <td><code>oneOf(_*)</code></td>
              <td><code>Char* =&gt; Parsley[Char]</code></td>
              <td>Read any <em>one</em> of the provided characters (which are varargs). The character returned is the one read.</td>
            </tr>
            <tr>
              <td><code>noneOf(_*)</code></td>
              <td><code>Char* =&gt; Parsley[Char]</code></td>
              <td>Read any single character that is <em>not</em> one of the provided characters. The character returned is the one read.</td>
            </tr>
          </tbody>
        </table>
        
        <h3 id="lifty-combinators" class="section"><a class="anchor-link left" href="#lifty-combinators"><i class="icofont-laika link">&#xef71;</i></a>Lifty Combinators</h3>
        <p>These combinators can all be implemented in terms of <code>lift2</code> (see <code>liftN</code> above), but are considered useful enough to have
        their own syntax and name. These combinators are lazy in their arguments (but not receivers),denoted here by the regular <em>by-name</em> (<code>=&gt;A</code>) syntax. As such,
        the receiver is parsed first and may consume input, which means the argument
        may contain a recursive position (and must therefore be lazy).</p>
        <table>
          <thead>
            <tr>
              <th>Combinator</th>
              <th>Type</th>
              <th>Use</th>
              <th>Pronounciation</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>_ &lt;~&gt; _</code></td>
              <td><code>(Parsley[A], =&gt;Parsley[B]) =&gt; Parsley[(A, B)]</code></td>
              <td>combine the results using <code>(_, _)</code></td>
              <td>&quot;zip&quot;</td>
            </tr>
            <tr>
              <td><code>_ &lt;*&gt; _</code></td>
              <td><code>(Parsley[A =&gt; B], =&gt;Parsley[A]) =&gt; Parsley[B]</code></td>
              <td>combine the results using <code>(f, x) =&gt; f(x)</code>.</td>
              <td>&quot;ap&quot;</td>
            </tr>
            <tr>
              <td><code>_ &lt;**&gt; _</code></td>
              <td><code>(Parsley[A], =&gt;Parsley[A =&gt; B]) =&gt; Parsley[B]</code></td>
              <td>combine the results using <code>(x, f) =&gt; f(x)</code>.</td>
              <td>&quot;reverse ap&quot;</td>
            </tr>
            <tr>
              <td><code>_ &lt;::&gt; _</code></td>
              <td><code>(Parsley[A], =&gt;Parsley[List[A]]) =&gt; Parsley[List[A]]</code></td>
              <td>combine the results using <code>_ :: _</code>.</td>
              <td>&quot;cons&quot;</td>
            </tr>
          </tbody>
        </table>
        
        <h3 id="composite-combinators" class="section"><a class="anchor-link left" href="#composite-combinators"><i class="icofont-laika link">&#xef71;</i></a>Composite Combinators</h3>
        <p>These combinators tackle more common complex tasks. In particular <code>many</code> and <code>some</code> are <strong>very</strong> important.
        They are all found in <code>parsley.combinator</code>. These combinators are sometimes lazy in their arguments, which is
        denoted here by the regular <em>by-name</em> (<code>=&gt;A</code>) syntax. Care should be taken with
        the combinators with variadic arguments, as they are totally strict, even in
        normally lazy positions: <code>LazyParsley.unary_~</code> can be used to restore laziness in these positions.</p>
        <table>
          <thead>
            <tr>
              <th>Combinator</th>
              <th>Type</th>
              <th>Use</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td><code>many(_)</code></td>
              <td><code>Parsley[A] =&gt; Parsley[List[A]]</code></td>
              <td>run one parser many times until it fails, collecting all the results in a list.</td>
            </tr>
            <tr>
              <td><code>some(_)</code></td>
              <td><code>Parsley[A] =&gt; Parsley[List[A]]</code></td>
              <td>as above, but the parser must succeed at least once.</td>
            </tr>
            <tr>
              <td><code>eof</code></td>
              <td><code>Parsley[Unit]</code></td>
              <td>check if there is any remaining input: it will succeed if there is none.</td>
            </tr>
            <tr>
              <td><code>choice(_*)</code></td>
              <td><code>Parsley[A]* =&gt; Parsley[A]</code></td>
              <td>try each of the given parsers in turn until one succeeds: uses <code>&lt;|&gt;</code>.</td>
            </tr>
            <tr>
              <td><code>option(_)</code></td>
              <td><code>Parsley[A] =&gt; Parsley[Option[A]]</code></td>
              <td>try a parser, if it succeeds wrap the result in <code>Some</code>, and if it fails <em>without consuming input</em> return <code>None</code>.</td>
            </tr>
            <tr>
              <td><code>optional(_)</code></td>
              <td><code>Parsley[A] =&gt; Parsley[Unit]</code></td>
              <td>optionally parse something (but if it fails, it must not consume input).</td>
            </tr>
            <tr>
              <td><code>sepBy1(_, _)</code></td>
              <td><code>(Parsley[A], =&gt;Parsley[_]) =&gt; Parsley[List[A]]</code></td>
              <td>parse one thing separated by another, collecting all the results. Something like comma-separated arguments in a function call.</td>
            </tr>
            <tr>
              <td><code>endBy1(_, _)</code></td>
              <td><code>(Parsley[A], =&gt;Parsley[_]) =&gt; Parsley[List[A]]</code></td>
              <td>same as above, but the sequence must be ended by the separator again. Something like semi-colon separated statements in C-like languages.</td>
            </tr>
            <tr>
              <td><code>sepEndBy1(_, _)</code></td>
              <td><code>(Parsley[A], =&gt;Parsley[_]) =&gt; Parsley[List[A]]</code></td>
              <td>same as above, but the terminal separator is optional. Something like semi-colon separated statements in Scala.</td>
            </tr>
          </tbody>
        </table>
        
        <h2 id="building-values-and-asts" class="section"><a class="anchor-link left" href="#building-values-and-asts"><i class="icofont-laika link">&#xef71;</i></a>Building Values and ASTs</h2>
        <p>This section covers the common ways you might build a result value or Abstract Syntax Tree (AST)
        with your parsers.</p>
        <p>The most primitive combinators for reading input all have a tendency to return the thing they parsed,
        be it a single character or a string. For the most part, this is not the useful output you&#39;d like your
        parser to have.</p>
        
        <h3 id="transforming-a-single-value-with-map" class="section"><a class="anchor-link left" href="#transforming-a-single-value-with-map"><i class="icofont-laika link">&#xef71;</i></a>Transforming a single value with <code>map</code></h3>
        <p>The quickest way to change the result of a parser is by using <code>.map</code> or the <code>#&gt;</code> combinator (see
        the above quick documentation). This is really useful for changing the result of a <em>single</em> parser,
        but provides no way of combining multiple.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>, </span><span class="type-name">Parsley</span><span>.</span><span class="identifier">some</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">digit</span><span>

</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Num</span><span>(</span><span class="identifier">n</span><span>: </span><span class="type-name">Int</span><span>)

</span><span class="comment">// A preferred method is to use `digit.foldLeft1` to avoid creating a List.
</span><span class="keyword">val</span><span> </span><span class="identifier">digits</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Char</span><span>]] = </span><span class="identifier">some</span><span>(</span><span class="identifier">digit</span><span>)
</span><span class="comment">// `map` here is using a function of type `List[Char] =&gt; Int`
</span><span class="keyword">val</span><span> </span><span class="identifier">int</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>] = </span><span class="identifier">digits</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">_</span><span>.</span><span class="identifier">mkString</span><span>.</span><span class="identifier">toInt</span><span>) </span><span class="comment">// equivalently `digits.map(_.mkString).map(_.toInt)
// `map` here is being used to wrap the `Int` in the `Num` class
</span><span class="keyword">val</span><span> </span><span class="identifier">num</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Num</span><span>] = </span><span class="identifier">int</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Num</span><span>)</span></code></pre>
        <p>But when you need to combine the results of two parsers more options open up.</p>
        
        <h3 id="combining-multiple-results-with-lift-and-friends" class="section"><a class="anchor-link left" href="#combining-multiple-results-with-lift-and-friends"><i class="icofont-laika link">&#xef71;</i></a>Combining multiple results with <code>lift</code>, <code>&lt;::&gt;</code>, and friends</h3>
        <p>Let&#39;s suppose we want to rule out leading zeros in the above parser. We&#39;ll need to read one non-zero
        digit before we read zero or more digits. In this case, we want the first digit to be added to the
        list of remaining digits. This task is quite common, so the <code>&lt;::&gt;</code> combinator is designed specially
        for it:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>, </span><span class="type-name">Parsley</span><span>.</span><span class="identifier">many</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.{</span><span class="identifier">digit</span><span>, </span><span class="identifier">oneOf</span><span>, </span><span class="identifier">char</span><span>}

</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Num</span><span>(</span><span class="identifier">n</span><span>: </span><span class="type-name">Int</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">nonzero</span><span> = </span><span class="identifier">oneOf</span><span>(</span><span class="char-literal">&#39;1&#39;</span><span> </span><span class="identifier">to</span><span> </span><span class="char-literal">&#39;9&#39;</span><span>)

</span><span class="comment">// &lt;::&gt; adds the leading non-zero char onto the other digits
</span><span class="keyword">val</span><span> </span><span class="identifier">digits</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Char</span><span>]] = </span><span class="identifier">nonzero</span><span> &lt;::&gt; </span><span class="identifier">many</span><span>(</span><span class="identifier">digit</span><span>)
</span><span class="comment">// Using #&gt; here to handle the plain ol&#39; zero case
</span><span class="keyword">val</span><span> </span><span class="identifier">int</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>] = </span><span class="identifier">char</span><span>(</span><span class="char-literal">&#39;0&#39;</span><span>) #&gt; </span><span class="number-literal">0</span><span> | </span><span class="identifier">digits</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">_</span><span>.</span><span class="identifier">mkString</span><span>.</span><span class="identifier">toInt</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">num</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Num</span><span>] = </span><span class="identifier">int</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Num</span><span>)</span></code></pre>
        <p>But more generally, we could reach for the <code>lift</code> functions:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>, </span><span class="type-name">Parsley</span><span>.</span><span class="identifier">many</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.{</span><span class="identifier">digit</span><span>, </span><span class="identifier">oneOf</span><span>, </span><span class="identifier">char</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">lift</span><span>.</span><span class="identifier">lift2</span><span>

</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Num</span><span>(</span><span class="identifier">n</span><span>: </span><span class="type-name">Int</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">nonzero</span><span> = </span><span class="identifier">oneOf</span><span>(</span><span class="char-literal">&#39;1&#39;</span><span> </span><span class="identifier">to</span><span> </span><span class="char-literal">&#39;9&#39;</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">digits</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Char</span><span>]] = </span><span class="identifier">lift2</span><span>[</span><span class="type-name">Char</span><span>, </span><span class="type-name">List</span><span>[</span><span class="type-name">Char</span><span>], </span><span class="type-name">List</span><span>[</span><span class="type-name">Char</span><span>]](</span><span class="identifier">_</span><span> :: </span><span class="identifier">_</span><span>, </span><span class="identifier">nonzero</span><span>, </span><span class="identifier">many</span><span>(</span><span class="identifier">digit</span><span>))
</span><span class="comment">// Using #&gt; here to handle the plain ol&#39; zero case
</span><span class="keyword">val</span><span> </span><span class="identifier">int</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Int</span><span>] = </span><span class="identifier">char</span><span>(</span><span class="char-literal">&#39;0&#39;</span><span>) #&gt; </span><span class="number-literal">0</span><span> | </span><span class="identifier">digits</span><span>.</span><span class="identifier">map</span><span>(</span><span class="identifier">_</span><span>.</span><span class="identifier">mkString</span><span>.</span><span class="identifier">toInt</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">num</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Num</span><span>] = </span><span class="identifier">int</span><span>.</span><span class="identifier">map</span><span>(</span><span class="type-name">Num</span><span>)</span></code></pre>
        <p>Sadly, to do this, it&#39;s sometimes necessary to specify all the types, in particular for anonymous
        functions that can have many possible type-instantiations, like <code>_ :: _</code>. The reason is that
        Scala doesn&#39;t infer the types of arguments, only return values, so on its own <code>_ :: _</code> has no known
        type. As such, the fix is to let other type-instantations help give the argument types (as above) or
        to specify the types in the function manually:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">lift2</span><span>((</span><span class="identifier">c</span><span>: </span><span class="type-name">Char</span><span>, </span><span class="identifier">cs</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Char</span><span>]) =&gt; </span><span class="identifier">c</span><span> :: </span><span class="identifier">cs</span><span>, </span><span class="identifier">nonzero</span><span>, </span><span class="identifier">many</span><span>(</span><span class="identifier">digit</span><span>))</span></code></pre>
        <p>Notice that this didn&#39;t seem to be a problem with <code>map</code>. This is because the function is type-checked
        after the receiver of the method: it gets given the right argument type straight away. Parsley has a syntax
        for leveraging this property:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">zipped</span><span>.</span><span class="type-name">Zipped2</span><span>

(</span><span class="identifier">nonzero</span><span>, </span><span class="identifier">many</span><span>(</span><span class="identifier">digit</span><span>)).</span><span class="identifier">zipped</span><span>(</span><span class="identifier">_</span><span> :: </span><span class="identifier">_</span><span>)</span></code></pre>
        <div class="callout warning">
          <i class="icofont-laika warning">&#xf026;</i>
          <p>The <code>zipped</code> syntax, unlike the <code>liftN</code> combinators or <code>lift</code> syntax, is not lazy in <em>any</em> of its arguments, so care
          may be needed to use <code>LazyParsley.unary_~</code> to restore laziness to those arguments that need it.</p>
        </div>
        <p>Use this form of lifting when type-inference fails you. Otherwise, for clarity, use a regular <code>liftN</code>, or the
        syntactic sugar for it:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">syntax</span><span>.</span><span class="identifier">lift</span><span>.{</span><span class="type-name">Lift2</span><span>, </span><span class="type-name">Lift1</span><span>}

</span><span class="keyword">val</span><span> </span><span class="identifier">charCons</span><span> = (</span><span class="identifier">c</span><span>: </span><span class="type-name">Char</span><span>, </span><span class="identifier">cs</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Char</span><span>]) =&gt; </span><span class="identifier">c</span><span> :: </span><span class="identifier">cs</span><span>

</span><span class="identifier">charCons</span><span>.</span><span class="identifier">lift</span><span>(</span><span class="identifier">nonzero</span><span>, </span><span class="identifier">many</span><span>(</span><span class="identifier">digit</span><span>))
</span><span class="type-name">Num</span><span>.</span><span class="identifier">lift</span><span>(</span><span class="identifier">int</span><span>)</span></code></pre>
        <p>The <code>lift</code> functions work all the way up to 22 arguments (which is a JVM limit). The same goes for
        the <code>zipped</code> syntax and <code>lift</code> syntax. Don&#39;t forget about <code>&lt;::&gt;</code> as well as its friends <code>&lt;~&gt;</code>,
        <code>&lt;*&gt;</code>, and <code>&lt;**&gt;</code>! They all provide a concise way of combining things in (common) special cases.</p>
        <div class="callout info">
          <i class="icofont-laika info">&#xef4e;</i>
          <p><strong>A note for Haskellers</strong></p>
          <p>In Scala, curried application is not as favoured as it is in Haskell for
          performance reasons. The classic <code>f &lt;$&gt; p &lt;*&gt; .. &lt;*&gt; z</code> pattern that is common in Haskell
          is unfavourable compared to the scala <code>liftN(f, p, .., z)</code>. For the latter, <code>f</code> is uncurried, which
          is the norm, and so it is almost always more efficient. Both <code>&lt;*&gt;</code> and <code>&lt;**&gt;</code> should be, therefore,
          used sparingly in idiomatic <code>parsley</code> code instead of liberally like in Haskell.</p>
          <p>However, it goes without saying that <code>lift2[A =&gt; B, A, B]((f, x) =&gt; f(x), pf, px)</code> is no more
          efficient than <code>pf &lt;*&gt; px</code> so the latter is favoured for that use case!</p>
        </div>
        <p><!--${cursor.currentDocument.fragments.liftN} --></p>

        
<hr class="footer-rule"/>
<footer>
  Parsley is distributed under the <a href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a> license.
</footer>


      </main>

    </div>

  </body>

</html>