<!DOCTYPE html>
<html lang="en">
  
  <head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="generator" content="Typelevel Laika + Helium Theme" />
  <title>`parsley.genericbridges`</title>
  
  <meta name="author" content="parsley contributors"/>
  
  
  <meta name="description" content="docs"/>
  
  
  
  <link rel="icon" sizes="32x32" type="image/svg+xml" href="../../icons/greenLeaf.svg"/>
  
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
  
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
  
  <link rel="stylesheet" type="text/css" href="../../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../../css/parsley-style.css" />
  <script src="../../helium/site/laika-helium.js"></script>
    <script src="../../helium/site/laika-versions.js"></script>
  <script>initVersions("../../", "/api-guide/generic.html", "latest", null);</script>
  
  <script> /* for avoiding page load transitions */ </script>
</head>

  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    <div class="menu-container version-menu">
      <a class="text-link menu-toggle" href="#">Version 4.4.x</a>
      <nav class="menu-content">
        <ul class="nav-list">
        </ul>
      </nav>
    </div>
  </div>

  <a class="icon-link svg-link" href="../"><span class="leaf" title="Home"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 128 128" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M101.39,86.21c-14.25-5.91-22.34-4.3-28.47-2.5c-6.5,1.91-12.31,8.58-12.31,8.58s-1.93-0.58-5.04-0.51 c-1.49,0.04-2.67,0.28-3.54,0.54c2.64-5.99,4.51-12.08,7.57-18.76c1.95-0.81,4.63-1.86,6.35-2.23c2.96-0.64,6.45-0.84,6.45-0.84 c0.82,0.64,2,1.39,3.69,2.23c9.56,4.78,21.5,2.16,27.35-0.16c8.13-3.23,20.21-12.95,20.21-13.69s-5.5-3.38-13.32-5.71 c-7.82-2.33-18.27-2.44-26.21,0.95c-7.28,3.11-10.67,8.58-12.54,11.86c0,0-2.9,0.46-5,0.82c-1.56,0.27-2.96,0.64-4.07,0.99 c0.22-0.4,0.45-0.81,0.68-1.21C67.77,58.61,72.83,52.5,77,48.2c5.87,0.55,17.89,0.35,27.62-8.46 c15.64-14.15,18.46-35.92,18.07-36.35S97.35,3.34,84.54,14.91c-12.19,11.01-11.97,25.4-11.4,30.69c-3.97,3.71-8.81,9.17-14.2,17.12 c-0.04-2.12-0.29-4.73-0.29-4.73s7.19-6.73,7.72-17.18c0.42-8.24-0.46-15.89-5-24.14c-3.56-6.43-6.53-8.03-7.06-7.93 c-0.93,0.19-5.33,7.06-8.03,13.63c-2.13,5.17-4.26,18.38-0.45,26.52s8.22,9.68,8.22,9.68s0.54,2.37,0.48,5.55 c-0.02,1.36-0.13,4.51-0.18,5.98c-3.57,6.32-5.96,12.07-8.23,17.22c-0.34-0.99-0.73-1.96-1.11-2.65c-1.16-2.11-1.59-2.85-1.59-2.85 s2.57-15.99-1.8-29.17C36.45,37,27.57,31.08,19.33,27.59C11.09,24.1,6.54,24.11,5.8,24.95c-1.08,1.23,1.37,4.33,1.59,11.31 c0.17,5.71,1.16,25.05,6.87,34.98s13.63,12.37,16.17,13.21c2.54,0.85,8.03,0.95,8.03,0.95s2.33,2.01,3.17,4.86 c0.39,1.31,0.78,2.92,1.09,4.27c-1.95,3.71-4.17,7-7.21,9.86c-5.01,4.71-13.09,7.94-13.09,7.94s-6.47-0.15-6.91,0.15 c-0.44,0.29-1.73,3.53,0.69,7.51c2,3.29,5.05,4.12,6.08,4.26c1.03,0.15,2.94-4.27,3.68-4.86c0.74-0.59,9.43-3.93,15.6-10.74 c2.83-3.13,5.02-6.16,6.81-9.17c1.65-1.01,4.07-2.17,6.72-2.31c2.64-0.15,4.94,1.12,4.94,1.12s2.22,9.16,12.15,13 c12.5,4.83,25.83,0.61,31.64-1.4c5.81-2,19.83-8.42,19.94-10.22C123.86,97.87,115.66,92.13,101.39,86.21z"/>
  </g>
</svg></span></a>

  <div class="row links">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.3.1/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.3.1/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../../downloads.html">Documentation Downloads</a></li>
    <li class="level1 nav-leaf"><a href="../">Home</a></li>
    <li class="level1 nav-leaf"><a href="../faq.html">FAQ</a></li>
    <li class="level1 nav-leaf"><a href="../cheatsheet.html">Cheatsheet</a></li>
    <li class="level1 nav-node"><a href="index.html">Understanding the API</a></li>
    <li class="level2 active nav-leaf"><a href="#"><code>parsley.genericbridges</code></a></li>
    <li class="level2 nav-header"><code>parsley.token</code></li>
    <li class="level3 nav-leaf"><a href="token/Lexer.html"><code>Lexer</code></a></li>
    <li class="level2 nav-leaf"><a href="Parsley.html"><code>parsley.Parsley</code></a></li>
    <li class="level1 nav-node"><a href="../tutorial/">Parser Combinator Tutorial</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/basics-of-combinators.html">Basics of Combinators</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/building-expression-parsers.html">Building Expression Parsers</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/effective-whitespace-parsing.html">Effective Whitespace Parsing</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/effective-lexing.html">Effective Lexing</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/parser-bridge-pattern.html">The Parser Bridge Pattern</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/interlude-1-haskell.html">Interlude 1: Building a Parser for Haskell</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/customising-error-messages.html">Customising Error Messages</a></li>
    <li class="level2 nav-leaf"><a href="../tutorial/advanced-error-messages.html">Advanced Error Messages</a></li>
    <li class="level1 nav-header">Related Projects</li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/parsley-cats">parsley-cats</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/gigaparsec">gigaparsec (Haskell)</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#"><code>parsley.genericbridges</code></a></p>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="#what-are-parser-bridges">What are <em>Parser Bridges</em>?</a></li>
    <li class="level1 nav-node"><a href="#how-to-use">How to use</a></li>
    <li class="level2 nav-leaf"><a href="#parserbridge1-t1-r-through-parserbridge22-t1-t22-r"><code>ParserBridge1[-T1, +R]</code> through <code>ParserBridge22[-T1, .., -T22, +R]</code></a></li>
    <li class="level2 nav-leaf"><a href="#parsersingletonbridge-t"><code>ParserSingletonBridge[+T]</code></a></li>
    <li class="level2 nav-leaf"><a href="#parserbridge0-t"><code>ParserBridge0[+T]</code></a></li>
    <li class="level1 nav-node"><a href="#additional-use-cases">Additional Use Cases</a></li>
    <li class="level2 nav-leaf"><a href="#normalising-or-disambiguating-data">Normalising or Disambiguating Data</a></li>
    <li class="level2 nav-leaf"><a href="#enforcing-invariances">Enforcing Invariances</a></li>
    <li class="level1 nav-leaf"><a href="#when-not-to-use">When <em>not</em> to use</a></li>
  </ul>

  <p class="footer"><a href="https://github.com/j-mie6/parsley/blob/wiki-improvements/docs/api-guide/generic.md"><i class="icofont-laika edit" title="Edit">&#xef10;</i>Source for this page</a></p>
</nav>


      <main class="content">

        <h1 id="generic-bridges-parsley-genericbridges" class="title">Generic Bridges (<code>parsley.genericbridges</code>)</h1>
        <p>The <em>Parser Bridge</em> pattern is a technique for decoupling semantic actions from the parser itself.
        The <code>parsley.genericbridges</code> module contains 23 classes that allow
        you to get started using the technique straight away if you wish.</p>
        <div class="callout info">
          <i class="icofont-laika info">&#xef4e;</i>
          <p><em>The Scaladoc for this page can be found at <a class="api" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.3.1/parsley/genericbridges$.html"><code>parsley.genericbridges</code></a>.</em></p>
        </div>
        
        <h2 id="what-are-parser-bridges" class="section"><a class="anchor-link left" href="#what-are-parser-bridges"><i class="icofont-laika link">&#xef71;</i></a>What are <em>Parser Bridges</em>?</h2>
        <p>Without making use of <em>Parser Bridges</em>, results of parsers are usually combined by using <code>lift</code>,
        <code>map</code>, or <code>zipped</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">zipped</span><span>.</span><span class="type-name">Zipped2</span><span>
</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Foo</span><span>(</span><span class="identifier">x</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">y</span><span>: </span><span class="type-name">Int</span><span>)
</span><span class="comment">// with px, py of type Parsley[Int]
</span><span class="keyword">val</span><span> </span><span class="identifier">p</span><span> = (</span><span class="identifier">px</span><span>, </span><span class="identifier">py</span><span>).</span><span class="identifier">zipped</span><span>(</span><span class="type-name">Foo</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>))
</span><span class="comment">// p: Parsley[Foo] = parsley.Parsley@29117428</span></code></pre>
        <p>These work fine for the most part, however, there are couple of problems with this:</p>
        <ol class="arabic">
          <li>In Scala 3, <code>Foo(_, _)</code> actually needs to be written as <code>Foo.apply</code>, which introduces some (minor) noise;
          <code>zipped</code> itself is even contributing noise.</li>
          <li>
            <code>Foo</code> itself is a simple constructor, if it gets more complex, readability rapidly decreases:
            <ul>
              <li>The result produced may require inspection of the data, including pattern matching (see <a href="#normalising-or-disambiguating-data">Normalising or Disambiguating Data</a>).</li>
              <li>Additional information may need to be threaded in, like position information.</li>
              <li>Data invariances may need to be enforced (see <a href="#enforcing-invariances">Enforcing Invariances</a>).</li>
            </ul>
          </li>
          <li>Constructor application is on the right of the data, which people may find harder to read;
          this can be mitigated with <code>lift</code>, but that may run into type inference issues.</li>
        </ol>
        <p>For some people (1) or (3) may not be an issue, or can be tolerated, but (2) can get out of hand
        quickly. For larger parsers, properly decoupling these issues can make a huge difference to the
        maintainability.</p>
        <p><span class="paragraph"> How do bridges help? </span>
        In short, a bridge is an object that provides an <code>apply</code> method that takes parsers as arguments,
        as opposed to values. This means that they can be used directly in the parser with the logic kept
        elsewhere. While you can just define a bridge manually with an <code>apply</code> method (or even just as a
        function), it is more ergonomic to <em>synthesise</em> a bridge in terms of a function that does not interact
        with <code>Parsley</code> values. If we assume that the companion object of <code>Foo</code> has been turned into such a
        bridge (definition below), the above example can be written as:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">q</span><span> = </span><span class="type-name">Foo</span><span>(</span><span class="identifier">px</span><span>, </span><span class="identifier">py</span><span>)
</span><span class="comment">// q: Parsley[Foo] = parsley.Parsley@788eaf1d</span></code></pre>
        <p>In this version, the act of constructing the <code>Foo</code> value has been abstracted behind the bridge, <code>Foo</code>:
        this means that the underlying implementation can vary without changing the parser.</p>
        <p><span class="paragraph"> What are <em>Generic Bridges</em>? </span>
        Generic bridges are the templating mechanism that allow for the synthesis of an <code>apply</code> method that
        works on values of type <code>Parsley</code> from another that does not. While you can define your own bridge
        templates (see <a href="../tutorial/parser-bridge-pattern.html">the associated tutorial</a> for an explanation),
        <code>parsley</code> provides some basic ones to get you started.</p>
        
        <h2 id="how-to-use" class="section"><a class="anchor-link left" href="#how-to-use"><i class="icofont-laika link">&#xef71;</i></a>How to use</h2>
        <p>The <a class="api" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.3.1/parsley/genericbridges$.html"><code>parsley.genericbridges</code></a> module contains <code>ParserBridge1</code> through
        <code>ParserBridge22</code> as well as <code>ParserBridge0</code>; they all extend <code>ParserBridgeSingleton</code>, which provides
        some additional combinators.</p>
        
        <h3 id="parserbridge1-t1-r-through-parserbridge22-t1-t22-r" class="section"><a class="anchor-link left" href="#parserbridge1-t1-r-through-parserbridge22-t1-t22-r"><i class="icofont-laika link">&#xef71;</i></a><code>ParserBridge1[-T1, +R]</code> through <code>ParserBridge22[-T1, .., -T22, +R]</code></h3>
        <p>Each of these traits are designed to be implemented ideally by a companion object for a <code>case class</code>.
        For example, the <code>Foo</code> class above can have its companion object turned into a bridge by extending
        <code>ParserBridge2</code> (which is for two argument bridges):</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">genericbridges</span><span>.</span><span class="type-name">ParserBridge2</span><span>
</span><span class="keyword">object</span><span> </span><span class="type-name">Foo</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>, </span><span class="type-name">Foo</span><span>]</span></code></pre>
        <p>This defines <code>def apply(px: Parsley[Int], py: Parsley[Int]): Parsley[Foo]</code>, implementing it in
        terms of <code>def apply(x: Int, y: Int): Foo</code>, which is included as part of Scala&#39;s automatic <code>case class</code>
        implementation. By making use of a companion object, this is <em>all</em> the boilerplate required to
        start using the bridge. Of course, it&#39;s possible to define standalone bridges as well, so long as
        you provide an implementation of <code>apply</code>, as illustrated by this error:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">object</span><span> </span><span class="type-name">Add</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>, </span><span class="type-name">Int</span><span>]
</span><span class="comment">// error: object creation impossible.
// Missing implementation for member of trait ParserBridge2:
//   def apply(x1: Int, x2: Int): Int = ??? // implements `def apply(x1: T1, x2: T2): R`
// 
// object Add extends ParserBridge2[Int, Int, Int]
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></code></pre>
        <p>Implement that <code>apply</code> method and it&#39;s good to go! Of course, if the traits are mixed into a regular <code>class</code>,
        they can also be parametric:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">class</span><span> </span><span class="type-name">Cons</span><span>[</span><span class="type-name">A</span><span>] </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">A</span><span>, </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>], </span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>]]
</span><span class="comment">// error: class Cons needs to be abstract.
// Missing implementation for member of trait ParserBridge2:
//   def apply(x1: A, x2: List[A]): List[A] = ??? // implements `def apply(x1: T1, x2: T2): R`
// 
// class Cons[A] extends ParserBridge2[A, List[A], List[A]]
// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^</span></code></pre>
        
        <h3 id="parsersingletonbridge-t" class="section"><a class="anchor-link left" href="#parsersingletonbridge-t"><i class="icofont-laika link">&#xef71;</i></a><code>ParserSingletonBridge[+T]</code></h3>
        <p>All the generic bridges extend the <code>ParserSingletonBridge</code> trait instantiated to a function type. For
        example, <code>trait ParserBridge2[-A, -B, +C] extends ParserSingletonBridge[(A, B) =&gt; C]</code>. This means that
        every bridge uniformly gets access to a couple of extra combinators in addition to their <code>apply</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">ParserSingletonBridge</span><span>[+</span><span class="type-name">T</span><span>] {
    </span><span class="keyword">final</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">from</span><span>(</span><span class="identifier">op</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="identifier">_</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">T</span><span>]
    </span><span class="keyword">final</span><span> </span><span class="keyword">def</span><span> &lt;#(</span><span class="identifier">op</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="identifier">_</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">T</span><span>] = </span><span class="keyword">this</span><span>.</span><span class="identifier">from</span><span>(</span><span class="identifier">op</span><span>)
}</span></code></pre>
        <p>The implementation of <code>from</code> is not important, it will be handled by the other <code>ParserBridgeN</code>s. What these
        two combinators give you is the ability to write <code>Foo.from(parser): Parsley[(Int, Int) =&gt; Foo]</code>, for instance.
        This can be useful when you want to use a bridge somewhere where the arguments cannot be directly applied,
        like in <a href="expr/chain.html">chain</a> or <a href="expr/precedence.html">precedence</a> combinators:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.</span><span class="identifier">chain</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">stringLift</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">term</span><span> = </span><span class="identifier">chain</span><span>.</span><span class="identifier">left1</span><span>(</span><span class="identifier">px</span><span>, </span><span class="type-name">Add</span><span>.</span><span class="identifier">from</span><span>(</span><span class="string-literal">&quot;+&quot;</span><span>)) </span><span class="comment">// or `Add &lt;# &quot;+&quot;`</span></code></pre>
        <p>They are analogous to the <code>as</code> and <code>#&gt;</code> combinators respectively.</p>
        
        <h3 id="parserbridge0-t" class="section"><a class="anchor-link left" href="#parserbridge0-t"><i class="icofont-laika link">&#xef71;</i></a><code>ParserBridge0[+T]</code></h3>
        <p>This trait is a special case for objects that should return themselves.
        As an example, here is an object which forms part of a larger AST, say:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">genericbridges</span><span>.</span><span class="type-name">ParserBridge0</span><span>
</span><span class="keyword">trait</span><span> </span><span class="type-name">Expr</span><span>
</span><span class="comment">// rest of AST
</span><span class="keyword">case</span><span> </span><span class="keyword">object</span><span> </span><span class="type-name">NullLit</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span> </span><span class="keyword">with</span><span> </span><span class="type-name">ParserBridge0</span><span>[</span><span class="type-name">Expr</span><span>]</span></code></pre>
        <p>The <code>NullLit</code> object is part of the <code>Expr</code> AST, and it has also mixed in <code>ParserBridge0[Expr]</code>,
        giving it access to <code>from</code> and <code>&lt;#</code> only (no <code>apply</code> for this one!). What this means is that
        you can now write the following:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">nullLit</span><span> = </span><span class="type-name">NullLit</span><span> &lt;# </span><span class="string-literal">&quot;null&quot;</span><span>
</span><span class="comment">// nullLit: Parsley[Expr] = parsley.Parsley@23ba2449
</span><span class="identifier">nullLit</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;null&quot;</span><span>)
</span><span class="comment">// res2: parsley.Result[String, Expr] = Success(NullLit)</span></code></pre>
        <p>Without any further configuration, notice that the result of parsing <code>&quot;null&quot;</code> is indeed <code>NullLit</code>,
        and <code>nullLit: Parsley[Expr]</code>.</p>
        <div class="callout error">
          <i class="icofont-laika error">&#xeedd;</i>
          <p>Be aware that the type passed to the generic parameter cannot be itself:</p>
          <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">object</span><span> </span><span class="type-name">Bad</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge0</span><span>[</span><span class="type-name">Bad</span><span>.</span><span class="keyword">type</span><span>]
</span><span class="comment">// error: illegal cyclic reference involving object Bad
// case object Bad extends ParserBridge0[Bad.type]
//                                       ^^^</span></code></pre>
          <p>Resolving this will require introducing an extra type, like <code>Expr</code> in the example with
          <code>NullLit</code>, which breaks the cycle sufficiently.</p>
        </div>
        
        <h2 id="additional-use-cases" class="section"><a class="anchor-link left" href="#additional-use-cases"><i class="icofont-laika link">&#xef71;</i></a>Additional Use Cases</h2>
        <p>Other than the natural decoupling that the bridges provide, there are some more specialised
        uses that can come out of the generic bridges alone.</p>
        
        <h3 id="normalising-or-disambiguating-data" class="section"><a class="anchor-link left" href="#normalising-or-disambiguating-data"><i class="icofont-laika link">&#xef71;</i></a>Normalising or Disambiguating Data</h3>
        <p>Occasionally, the shape of an AST can change internally even though the syntax of the
        language being parsed does not. Bridges are perfectly suited for handling these internal
        changes while masking them from the parser itself. As an example, assume that a <code>Let</code>
        AST node was <em>previously</em> defined as follows:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Let</span><span>(</span><span class="identifier">bindings</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Binding</span><span>], </span><span class="identifier">body</span><span>: </span><span class="type-name">Expr</span><span>)
</span><span class="keyword">object</span><span> </span><span class="type-name">Let</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Binding</span><span>], </span><span class="type-name">Expr</span><span>, </span><span class="type-name">Let</span><span>]</span></code></pre>
        <p>The parser, therefore, can be expected to produce lists of bindings to feed in. However,
        later it was decided that the ordering of the bindings doesn&#39;t matter, so a <code>Set</code> is being
        used. The decoupling of the bridge will allow for this change to happen without changing the
        parser, so long as the bridge performs the &quot;patching&quot;:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Let</span><span>(</span><span class="identifier">bindings</span><span>: </span><span class="type-name">Set</span><span>[</span><span class="type-name">Binding</span><span>], </span><span class="identifier">body</span><span>: </span><span class="type-name">Expr</span><span>)
</span><span class="keyword">object</span><span> </span><span class="type-name">Let</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge2</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">Binding</span><span>], </span><span class="type-name">Expr</span><span>, </span><span class="type-name">Let</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">bindings</span><span>: </span><span class="type-name">List</span><span>[</span><span class="type-name">Binding</span><span>], </span><span class="identifier">body</span><span>: </span><span class="type-name">Expr</span><span>): </span><span class="type-name">Let</span><span> = </span><span class="type-name">Let</span><span>(</span><span class="identifier">bindings</span><span>.</span><span class="identifier">toSet</span><span>, </span><span class="identifier">body</span><span>)
}</span></code></pre>
        <p>By defining the appropriate &quot;forwarding&quot; in its own <code>apply</code>, the bridge has ensured the
        parser will still work.</p>
        <p><span class="paragraph"> Handling ambiguity </span>
        Another use of this kind of bridge is to allow for the disambiguation of two syntactically
        similar structures. As an example, consider Scala&#39;s tuple syntax:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">x</span><span>  = (</span><span class="number-literal">6</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">xy</span><span> = (</span><span class="number-literal">5</span><span>, </span><span class="number-literal">6</span><span>)</span></code></pre>
        <p>It is clear to us that <code>x</code> is not a &quot;singleton pair&quot;, whatever that would be, but a parenthesised
        expression; on the other hand, <code>xy</code> is clearly a pair. The problem is that the syntax for these
        overlap, requiring backtracking to resolve (you can only know if you&#39;re parsing a tuple when
        you find your first <code>&#39;,&#39;</code>).</p>
        <p>In practice, arbitrary backtracking in a parser can impact performance
        and the quality of error messages. Instead of dealing with this ambiguity by backtracking, it
        is possible to exploit the shared structure in a <em>Disambiguator Bridge</em>: this is just a bridge
        that looks at the provided arguments to decide what to make. For example:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">cats</span><span>.</span><span class="identifier">data</span><span>.</span><span class="type-name">NonEmptyList</span><span>

</span><span class="keyword">case</span><span> </span><span class="keyword">class</span><span> </span><span class="type-name">Tuple</span><span>(</span><span class="identifier">exprs</span><span>: </span><span class="type-name">NonEmptyList</span><span>[</span><span class="type-name">Expr</span><span>]) </span><span class="keyword">extends</span><span> </span><span class="type-name">Expr</span><span>

</span><span class="keyword">object</span><span> </span><span class="type-name">TupleOrParens</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">NonEmptyList</span><span>[</span><span class="type-name">Expr</span><span>], </span><span class="type-name">Expr</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">exprs</span><span>: </span><span class="type-name">NonEmptyList</span><span>[</span><span class="type-name">Expr</span><span>]): </span><span class="type-name">Expr</span><span> = </span><span class="identifier">exprs</span><span> </span><span class="keyword">match</span><span> {
        </span><span class="keyword">case</span><span> </span><span class="type-name">NonEmptyList</span><span>(</span><span class="identifier">expr</span><span>, </span><span class="type-name">Nil</span><span>) =&gt; </span><span class="identifier">expr</span><span>
        </span><span class="keyword">case</span><span> </span><span class="identifier">exprs</span><span>                   =&gt; </span><span class="type-name">Tuple</span><span>(</span><span class="identifier">exprs</span><span>)
    }
}</span></code></pre>
        <p>In the above example, the parser will parse one or more expressions (signified by the <code>NonEmptyList</code>
        from <code>cats</code>); the bridge will then inspect these expressions, returning a single expression if
        only one was parsed, and construct the <code>Tuple</code> node otherwise. In the parser, this would just look
        something like:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="comment">// from `parsley-cats`, produces `NonEmptyList` instead of `List`
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">cats</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">sepBy1</span><span>
</span><span class="keyword">val</span><span> </span><span class="identifier">tupleOrParens</span><span> = </span><span class="type-name">TupleOrParens</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">sepBy1</span><span>(</span><span class="identifier">nullLit</span><span>, </span><span class="string-literal">&quot;,&quot;</span><span>) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)
</span><span class="comment">// tupleOrParens: Parsley[Expr] = parsley.Parsley@23cb47d0
</span><span class="identifier">tupleOrParens</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;(null)&quot;</span><span>)
</span><span class="comment">// res4: parsley.Result[String, Expr] = Success(NullLit)
</span><span class="identifier">tupleOrParens</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;(null,null)&quot;</span><span>)
</span><span class="comment">// res5: parsley.Result[String, Expr] = Success(Tuple(NonEmptyList(NullLit, NullLit)))</span></code></pre>
        
        <h3 id="enforcing-invariances" class="section"><a class="anchor-link left" href="#enforcing-invariances"><i class="icofont-laika link">&#xef71;</i></a>Enforcing Invariances</h3>
        <p>So far, the bridges we&#39;ve seen have been altering the way that the data itself should
        be constructed from the results. However, it may also be desirable to override the
        <em>templated</em> <code>apply</code> to perform additional checks. This basically means that you
        can add in a <code>filter</code>-like combinator after the data has been constructed to validate
        that the thing you&#39;ve constructed is actually correct. As an example, it turns out that
        Scala only allows tuples with a maximum of 22 elements:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">oops</span><span> = (</span><span class="number-literal">1</span><span>, </span><span class="number-literal">2</span><span>, </span><span class="number-literal">3</span><span>, </span><span class="number-literal">4</span><span>, </span><span class="number-literal">5</span><span>, </span><span class="number-literal">6</span><span>, </span><span class="number-literal">7</span><span>, </span><span class="number-literal">8</span><span>, </span><span class="number-literal">9</span><span>, </span><span class="number-literal">0</span><span>, </span><span class="number-literal">1</span><span>, </span><span class="number-literal">2</span><span>, </span><span class="number-literal">3</span><span>, </span><span class="number-literal">4</span><span>, </span><span class="number-literal">5</span><span>, </span><span class="number-literal">6</span><span>, </span><span class="number-literal">7</span><span>, </span><span class="number-literal">8</span><span>, </span><span class="number-literal">9</span><span>, </span><span class="number-literal">0</span><span>, </span><span class="number-literal">1</span><span>, </span><span class="number-literal">2</span><span>, </span><span class="number-literal">3</span><span>)
</span><span class="comment">// error: tuples may not have more than 22 elements, but 23 given
// val oops = (1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3)
//                                                                               ^</span></code></pre>
        
        <p>How to adjust the parser to handle this? One possible approach is to use a <code>range</code> combinator
        (which does not exist in <code>parsley:4.3.1</code>, it is in <code>parsley:4.4.0</code>, but for sake of example):</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">def</span><span> </span><span class="declaration-name">nonEmptyList</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">px</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>], </span><span class="identifier">pxs</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">List</span><span>[</span><span class="type-name">A</span><span>]]) =
    </span><span class="identifier">lift2</span><span>(</span><span class="type-name">NonEmptyList</span><span>(</span><span class="identifier">_</span><span>, </span><span class="identifier">_</span><span>), </span><span class="identifier">px</span><span>, </span><span class="identifier">pxs</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">tupleOrParensObtuse</span><span> =
    </span><span class="type-name">TupleOrParens</span><span>(</span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">nonEmptyList</span><span>(</span><span class="identifier">nullLit</span><span>, </span><span class="identifier">range</span><span>(</span><span class="number-literal">0</span><span>, </span><span class="number-literal">21</span><span>)(</span><span class="string-literal">&quot;,&quot;</span><span> ~&gt; </span><span class="identifier">nullLit</span><span>)) &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span>)</span></code></pre>
        <p>This works, but it&#39;s very obtuse. Not to mention that the error message generated isn&#39;t particularly
        good.  Instead, we can hook some extra behaviour into the generated <code>apply</code>:</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">errors</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">object</span><span> </span><span class="type-name">TupleOrParens</span><span> </span><span class="keyword">extends</span><span> </span><span class="type-name">ParserBridge1</span><span>[</span><span class="type-name">NonEmptyList</span><span>[</span><span class="type-name">Expr</span><span>], </span><span class="type-name">Expr</span><span>] {
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">exprs</span><span>: </span><span class="type-name">NonEmptyList</span><span>[</span><span class="type-name">Expr</span><span>]): </span><span class="type-name">Expr</span><span> = </span><span class="identifier">exprs</span><span> </span><span class="keyword">match</span><span> {
        </span><span class="keyword">case</span><span> </span><span class="type-name">NonEmptyList</span><span>(</span><span class="identifier">expr</span><span>, </span><span class="type-name">Nil</span><span>) =&gt; </span><span class="identifier">expr</span><span>
        </span><span class="keyword">case</span><span> </span><span class="identifier">exprs</span><span>                   =&gt; </span><span class="type-name">Tuple</span><span>(</span><span class="identifier">exprs</span><span>)
    }

    </span><span class="keyword">override</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">apply</span><span>(</span><span class="identifier">exprs</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">NonEmptyList</span><span>[</span><span class="type-name">Expr</span><span>]]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Expr</span><span>] =
        </span><span class="keyword">super</span><span>.</span><span class="identifier">apply</span><span>(</span><span class="identifier">exprs</span><span>).</span><span class="identifier">guardAgainst</span><span> {
            </span><span class="keyword">case</span><span> </span><span class="type-name">Tuple</span><span>(</span><span class="identifier">exprs</span><span>) </span><span class="keyword">if</span><span> </span><span class="identifier">exprs</span><span>.</span><span class="identifier">size</span><span> &gt; </span><span class="number-literal">22</span><span> =&gt;
                </span><span class="type-name">Seq</span><span>(</span><span class="string-literal">s&quot;tuples may not have more than 22 elements, but </span><span class="substitution">${exprs.size}</span><span class="string-literal"> given&quot;</span><span>)
        }
}</span></code></pre>
        <p>This bridge invokes the templated <code>apply</code> with <code>super.apply</code> first, then after processes it
        with the <code>guardAgainst</code> combinator to generate a bespoke message:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">tupleOrParens</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;(null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null)&quot;</span><span>)
</span><span class="comment">// res7: parsley.Result[String, Expr] = Failure((line 1, column 1):
//   tuples may not have more than 22 elements, but 23 given
//   &gt;(null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null)
//    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^)</span></code></pre>
        <p>To be clear, this is using the original definition of <code>tupleOrParens</code> and <em>not</em> <code>tupleOrParensObtuse</code>.</p>
        <div class="callout warning">
          <i class="icofont-laika warning">&#xf026;</i>
          <p>While this use of bridges does retain the unsaturated application from <code>ParserSingletonBridge</code>, using the
          <code>from</code> combinator will not perform the additional validation: be careful!</p>
        </div>
        
        
        <h2 id="when-not-to-use" class="section"><a class="anchor-link left" href="#when-not-to-use"><i class="icofont-laika link">&#xef71;</i></a>When <em>not</em> to use</h2>
        <p>Simply put, generic bridges have one major limitation: they cannot interact with additional metadata
        that might be required in the parser. One excellent example of this is position information. While
        <code>parsley</code> could take a stance on how this should be done, I&#39;d prefer if the users can make that
        decision for themselves. The previously linked tutorial demonstrates how to <em>make</em> templating bridges
        from scratch, which you would need to do to support something like position tracking.</p>

        
<hr class="footer-rule"/>
<footer>
  Parsley is distributed under the <a href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a> license.
</footer>


      </main>

    </div>

  </body>

</html>