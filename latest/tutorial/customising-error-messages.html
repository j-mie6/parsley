<!DOCTYPE html>
<html lang="en">
  
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Typelevel Laika + Parsley Theme" />
    
    <title>Customising Error Messages</title>
    
    
    <meta name="author" content="parsley contributors"/>
    
    
    <meta name="description" content="How to customise error messages to make them more informative."/>
    
    
    
    <link rel="icon" sizes="32x32" type="image/svg+xml" href="../../icons/greenLeaf.svg"/>
    
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Lato:400,700">
    
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Fira+Mono:500">
    
    <link rel="stylesheet" type="text/css" href="../../helium/site/icofont.min.css" />
    <link rel="stylesheet" type="text/css" href="../../helium/site/laika-helium.css" />
    <link rel="stylesheet" type="text/css" href="../../css/parsley-style.css" />
    <script src="../../helium/site/laika-helium.js"></script>
    <script src="../../helium/site/laika-versions.js"></script>
    <script>initVersions("../../", "/tutorial/customising-error-messages.html", "latest", null);</script>
    
    <script> /* for avoiding page load transitions */ </script>
  </head>


  <body>

    <header id="top-bar" class="light-default dark-default">

  <div class="row">
    <a id="nav-icon">
      <i class="icofont-laika navigationMenu" title="Navigation">&#xefa2;</i>
    </a>
    
    <div class="menu-container version-menu">
      <a class="text-link menu-toggle" href="#">Version 4.4.x</a>
      <nav class="menu-content">
        <ul class="nav-list">
        </ul>
      </nav>
    </div>
  </div>

  <a class="icon-link svg-link" href="../"><span class="leaf" title="Home"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 128 128" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xml:space="preserve" xmlns:serif="http://www.serif.com/" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M101.39,86.21c-14.25-5.91-22.34-4.3-28.47-2.5c-6.5,1.91-12.31,8.58-12.31,8.58s-1.93-0.58-5.04-0.51 c-1.49,0.04-2.67,0.28-3.54,0.54c2.64-5.99,4.51-12.08,7.57-18.76c1.95-0.81,4.63-1.86,6.35-2.23c2.96-0.64,6.45-0.84,6.45-0.84 c0.82,0.64,2,1.39,3.69,2.23c9.56,4.78,21.5,2.16,27.35-0.16c8.13-3.23,20.21-12.95,20.21-13.69s-5.5-3.38-13.32-5.71 c-7.82-2.33-18.27-2.44-26.21,0.95c-7.28,3.11-10.67,8.58-12.54,11.86c0,0-2.9,0.46-5,0.82c-1.56,0.27-2.96,0.64-4.07,0.99 c0.22-0.4,0.45-0.81,0.68-1.21C67.77,58.61,72.83,52.5,77,48.2c5.87,0.55,17.89,0.35,27.62-8.46 c15.64-14.15,18.46-35.92,18.07-36.35S97.35,3.34,84.54,14.91c-12.19,11.01-11.97,25.4-11.4,30.69c-3.97,3.71-8.81,9.17-14.2,17.12 c-0.04-2.12-0.29-4.73-0.29-4.73s7.19-6.73,7.72-17.18c0.42-8.24-0.46-15.89-5-24.14c-3.56-6.43-6.53-8.03-7.06-7.93 c-0.93,0.19-5.33,7.06-8.03,13.63c-2.13,5.17-4.26,18.38-0.45,26.52s8.22,9.68,8.22,9.68s0.54,2.37,0.48,5.55 c-0.02,1.36-0.13,4.51-0.18,5.98c-3.57,6.32-5.96,12.07-8.23,17.22c-0.34-0.99-0.73-1.96-1.11-2.65c-1.16-2.11-1.59-2.85-1.59-2.85 s2.57-15.99-1.8-29.17C36.45,37,27.57,31.08,19.33,27.59C11.09,24.1,6.54,24.11,5.8,24.95c-1.08,1.23,1.37,4.33,1.59,11.31 c0.17,5.71,1.16,25.05,6.87,34.98s13.63,12.37,16.17,13.21c2.54,0.85,8.03,0.95,8.03,0.95s2.33,2.01,3.17,4.86 c0.39,1.31,0.78,2.92,1.09,4.27c-1.95,3.71-4.17,7-7.21,9.86c-5.01,4.71-13.09,7.94-13.09,7.94s-6.47-0.15-6.91,0.15 c-0.44,0.29-1.73,3.53,0.69,7.51c2,3.29,5.05,4.12,6.08,4.26c1.03,0.15,2.94-4.27,3.68-4.86c0.74-0.59,9.43-3.93,15.6-10.74 c2.83-3.13,5.02-6.16,6.81-9.17c1.65-1.01,4.07-2.17,6.72-2.31c2.64-0.15,4.94,1.12,4.94,1.12s2.22,9.16,12.15,13 c12.5,4.83,25.83,0.61,31.64-1.4c5.81-2,19.83-8.42,19.94-10.22C123.86,97.87,115.66,92.13,101.39,86.21z"/>
  </g>
</svg></span></a>

  <div class="row links">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.4.0/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>  

</header>
    
    <nav id="sidebar">

  <div class="row">
    
    <a class="text-link" href="https://www.javadoc.io/doc/com.github.j-mie6/parsley_2.13/4.4.0/">API</a>
    
    <a class="icon-link svg-link" href="https://github.com/j-mie6/parsley"><span class="github" title="Source Code"><svg class="svg-icon" width="100%" height="100%" viewBox="0 0 100 100" version="1.1" xmlns="http://www.w3.org/2000/svg" xml:space="preserve" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;">
  <g class="svg-shape">
    <path d="M49.995,1c-27.609,-0 -49.995,22.386 -49.995,50.002c-0,22.09 14.325,40.83 34.194,47.444c2.501,0.458 3.413,-1.086 3.413,-2.412c0,-1.185 -0.043,-4.331 -0.067,-8.503c-13.908,3.021 -16.843,-6.704 -16.843,-6.704c-2.274,-5.773 -5.552,-7.311 -5.552,-7.311c-4.54,-3.103 0.344,-3.042 0.344,-3.042c5.018,0.356 7.658,5.154 7.658,5.154c4.46,7.64 11.704,5.433 14.552,4.156c0.454,-3.232 1.744,-5.436 3.174,-6.685c-11.102,-1.262 -22.775,-5.553 -22.775,-24.713c-0,-5.457 1.949,-9.92 5.147,-13.416c-0.516,-1.265 -2.231,-6.348 0.488,-13.233c0,0 4.199,-1.344 13.751,5.126c3.988,-1.108 8.266,-1.663 12.518,-1.682c4.245,0.019 8.523,0.574 12.517,1.682c9.546,-6.47 13.736,-5.126 13.736,-5.126c2.728,6.885 1.013,11.968 0.497,13.233c3.204,3.496 5.141,7.959 5.141,13.416c0,19.209 -11.691,23.436 -22.83,24.673c1.795,1.544 3.394,4.595 3.394,9.26c0,6.682 -0.061,12.076 -0.061,13.715c0,1.338 0.899,2.894 3.438,2.406c19.853,-6.627 34.166,-25.354 34.166,-47.438c-0,-27.616 -22.389,-50.002 -50.005,-50.002"/>
  </g>
</svg></span></a>
    
  </div>

  <ul class="nav-list">
    <li class="level1 nav-leaf"><a href="../../downloads.html">Documentation Downloads</a></li>
    <li class="level1 nav-leaf"><a href="../">Home</a></li>
    <li class="level1 nav-leaf"><a href="../faq.html">FAQ</a></li>
    <li class="level1 nav-leaf"><a href="../cheatsheet.html">Cheatsheet</a></li>
    <li class="level1 nav-node"><a href="../api-guide/">Understanding the API</a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/Parsley.html"><code>parsley.Parsley</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/character.html"><code>parsley.character</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/combinator.html"><code>parsley.combinator</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/generic.html"><code>parsley.genericbridges</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/syntax.html"><code>parsley.implicits</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/position.html"><code>parsley.position</code></a></li>
    <li class="level2 nav-leaf"><a href="../api-guide/state.html"><code>parsley.registers</code></a></li>
    <li class="level2 nav-header"><code>parsley.expr</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/chain.html"><code>chain</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/infix.html"><code>infix</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/expr/precedence.html"><code>precedence</code></a></li>
    <li class="level2 nav-header"><code>parsley.token</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/Lexer.html"><code>Lexer</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/descriptions.html"><code>descriptions</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/token/errors.html"><code>errors</code></a></li>
    <li class="level2 nav-header"><code>parsley.errors</code></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/combinator.html"><code>combinator</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/patterns.html"><code>patterns</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/ErrorBuilder.html"><code>ErrorBuilder</code></a></li>
    <li class="level3 nav-leaf"><a href="../api-guide/errors/tokenextractors.html"><code>tokenextractors</code></a></li>
    <li class="level1 nav-node"><a href="index.html">Parser Combinator Tutorial</a></li>
    <li class="level2 nav-leaf"><a href="basics-of-combinators.html">Basics of Combinators</a></li>
    <li class="level2 nav-leaf"><a href="building-expression-parsers.html">Building Expression Parsers</a></li>
    <li class="level2 nav-leaf"><a href="effective-whitespace-parsing.html">Effective Whitespace Parsing</a></li>
    <li class="level2 nav-leaf"><a href="effective-lexing.html">Effective Lexing</a></li>
    <li class="level2 nav-leaf"><a href="parser-bridge-pattern.html">The Parser Bridge Pattern</a></li>
    <li class="level2 nav-leaf"><a href="interlude-1-haskell.html">Interlude 1: Building a Parser for Haskell</a></li>
    <li class="level2 active nav-leaf"><a href="#">Customising Error Messages</a></li>
    <li class="level2 nav-leaf"><a href="advanced-error-messages.html">Advanced Error Messages</a></li>
    <li class="level1 nav-header">Related Projects</li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/parsley-cats">parsley-cats</a></li>
    <li class="level2 nav-leaf"><a href="https://github.com/j-mie6/gigaparsec">gigaparsec (Haskell)</a></li>
  </ul>

</nav>

    <div id="container">

      
<nav id="page-nav">
  <p class="header"><a href="#">Customising Error Messages</a></p>

  <ul class="nav-list">
    <li class="level1 nav-node"><a href="#adjusting-error-content"><span class="section-number">1 </span>Adjusting Error Content</a></li>
    <li class="level2 nav-leaf"><a href="#using-label"><span class="section-number">1.1 </span>Using <code>label</code></a></li>
    <li class="level2 nav-leaf"><a href="#wrapping-up-the-expression-example"><span class="section-number">1.2 </span>Wrapping up the Expression Example</a></li>
    <li class="level2 nav-leaf"><a href="#using-explain"><span class="section-number">1.3 </span>Using <code>explain</code></a></li>
    <li class="level1 nav-leaf"><a href="#adjusting-error-formatting"><span class="section-number">2 </span>Adjusting Error Formatting</a></li>
  </ul>

  <p class="footer"><a href="https://github.com/j-mie6/parsley/blob/wiki-improvements/docs/tutorial/customising-error-messages.md"><i class="icofont-laika edit" title="Edit">&#xef10;</i>Source for this page</a></p>
</nav>


      <main class="content">

        <h1 id="customising-error-messages" class="title">Customising Error Messages</h1>
        <p>Previously, in <a href="effective-lexing.html#effective-lexing">Effective Lexing</a>
        we saw how we could extend our parsers to handle whitespace and lexing. In this wiki post we&#39;ll finally address
        error messages. Thoughout all the other entries in this series I have neglected to talk about error
        messages at all, but they are a very important part of a parser.</p>
        
        <h1 id="adjusting-error-content" class="section"><a class="anchor-link left" href="#adjusting-error-content"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">1 </span>Adjusting Error Content</h1>
        <p>I&#39;m going to start with the parser from last time, but before we introduced the <code>Lexer</code> class. The
        reason for this is that the <code>Lexer</code> functionality has error messages baked into it, which means this
        post would be even shorter! It&#39;s not perfect, however, but it does make some good error messages for
        your basic lexemes. There is nothing stopping you from using the techniques here to change those
        messages if you wish though. Simply put: the original grammar has more room for exploration for us.</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>, </span><span class="type-name">Parsley</span><span>.</span><span class="identifier">atomic</span><span>

</span><span class="keyword">object</span><span> </span><span class="identifier">lexer</span><span> {
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.{</span><span class="identifier">digit</span><span>, </span><span class="identifier">whitespace</span><span>, </span><span class="identifier">string</span><span>, </span><span class="identifier">item</span><span>, </span><span class="identifier">endOfLine</span><span>}
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">combinator</span><span>.{</span><span class="identifier">manyUntil</span><span>, </span><span class="identifier">skipMany</span><span>, </span><span class="identifier">eof</span><span>}

    </span><span class="keyword">private</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">symbol</span><span>(</span><span class="identifier">str</span><span>: </span><span class="type-name">String</span><span>) = </span><span class="identifier">atomic</span><span>(</span><span class="identifier">string</span><span>(</span><span class="identifier">str</span><span>)).</span><span class="identifier">void</span><span>
    </span><span class="keyword">private</span><span> </span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">implicitSymbol</span><span>(</span><span class="identifier">tok</span><span>: </span><span class="type-name">String</span><span>) = </span><span class="identifier">symbol</span><span>(</span><span class="identifier">tok</span><span>)

    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">lineComment</span><span> = </span><span class="string-literal">&quot;//&quot;</span><span> ~&gt; </span><span class="identifier">manyUntil</span><span>(</span><span class="identifier">item</span><span>, </span><span class="identifier">endOfLine</span><span>)
    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">multiComment</span><span> = </span><span class="string-literal">&quot;/*&quot;</span><span> ~&gt; </span><span class="identifier">manyUntil</span><span>(</span><span class="identifier">item</span><span>, </span><span class="string-literal">&quot;*/&quot;</span><span>)
    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">comment</span><span> = </span><span class="identifier">lineComment</span><span> | </span><span class="identifier">multiComment</span><span>
    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">skipWhitespace</span><span> = </span><span class="identifier">skipMany</span><span>(</span><span class="identifier">whitespace</span><span> | </span><span class="identifier">comment</span><span>)

    </span><span class="keyword">private</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">lexeme</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">p</span><span>: =&gt;</span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]) = </span><span class="identifier">p</span><span> &lt;~ </span><span class="identifier">skipWhitespace</span><span>
    </span><span class="keyword">private</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">token</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">p</span><span>: =&gt;</span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]) = </span><span class="identifier">lexeme</span><span>(</span><span class="identifier">atomic</span><span>(</span><span class="identifier">p</span><span>))
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">fully</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">p</span><span>: =&gt;</span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="identifier">skipWhitespace</span><span> ~&gt; </span><span class="identifier">p</span><span> &lt;~ </span><span class="identifier">eof</span><span>

    </span><span class="keyword">val</span><span> </span><span class="identifier">number</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">BigInt</span><span>] =
        </span><span class="identifier">token</span><span>(</span><span class="identifier">digit</span><span>.</span><span class="identifier">foldLeft1</span><span>[</span><span class="type-name">BigInt</span><span>](</span><span class="number-literal">0</span><span>)((</span><span class="identifier">n</span><span>, </span><span class="identifier">d</span><span>) =&gt; </span><span class="identifier">n</span><span> * </span><span class="number-literal">10</span><span> + </span><span class="identifier">d</span><span>.</span><span class="identifier">asDigit</span><span>))

    </span><span class="keyword">object</span><span> </span><span class="identifier">implicits</span><span> {
        </span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">implicitSymbol</span><span>(</span><span class="identifier">s</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">lexeme</span><span>(</span><span class="identifier">symbol</span><span>(</span><span class="identifier">s</span><span>))
    }
}

</span><span class="keyword">object</span><span> </span><span class="identifier">expressions</span><span> {
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.{</span><span class="identifier">precedence</span><span>, </span><span class="type-name">Ops</span><span>, </span><span class="type-name">InfixL</span><span>}

    </span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">implicitSymbol</span><span>
    </span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.{</span><span class="identifier">number</span><span>, </span><span class="identifier">fully</span><span>}

    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">atom</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">BigInt</span><span>] = </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">expr</span><span> &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span> | </span><span class="identifier">number</span><span>
    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span> = </span><span class="identifier">precedence</span><span>[</span><span class="type-name">BigInt</span><span>](</span><span class="identifier">atom</span><span>)(
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="string-literal">&quot;*&quot;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> * </span><span class="identifier">_</span><span>)),
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="string-literal">&quot;+&quot;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> + </span><span class="identifier">_</span><span>), </span><span class="string-literal">&quot;-&quot;</span><span> </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> - </span><span class="identifier">_</span><span>)))

    </span><span class="keyword">val</span><span> </span><span class="identifier">parser</span><span> = </span><span class="identifier">fully</span><span>(</span><span class="identifier">expr</span><span>)
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">parse</span><span>(</span><span class="identifier">input</span><span>: </span><span class="type-name">String</span><span>) = </span><span class="identifier">parser</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="identifier">input</span><span>)
}</span></code></pre>
        <p>So, before, we saw how this ran on succesful cases. Let&#39;s now start to see how it works on <em>bad</em>
        input.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">expressions</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;5d&quot;</span><span>)
</span><span class="comment">// res0: parsley.Result[String, BigInt] = Failure((line 1, column 2):
//   unexpected &quot;d&quot;
//   expected &quot;*&quot;, &quot;+&quot;, &quot;-&quot;, &quot;/*&quot;, &quot;//&quot;, digit, end of input, or whitespace
//   &gt;5d
//     ^)</span></code></pre>
        <p>Let&#39;s start by breaking this error down first and understanding what the components of it are and
        why this information has appeared. The first line of the error reports the line and column number
        of the message (in Parsley hard tabs are treated as aligning to the nearest 4th column). If you are
        using <code>parseFromFile</code> then this will also display the filename. The last two lines always show the
        location at which the error occured. This is going to be <em>the point</em> at which the error that
        eventually ended up being reported occured, <em>not</em> necessarily where the parser ended up. This can
        be improved in the future. Next you can see the <em>unexpected</em> and <em>expected</em> clauses. The unexpected
        &quot;d&quot; here is telling us roughly what we already knew. The expected clause on the other hand tells us
        all the things we could have used to fix our problem. There is definitely a lot of noise here though.</p>
        <p>First let&#39;s just make sure we understand where each of these alternatives came from. Firstly, it&#39;s
        clear that since the last thing we read was a 5, a good way of carrying on would be reading another
        digit to make the number bigger. We could also read a space or start a comment as a way of making
        more progress too. Of course, another way we could make progress would have been using one of the
        operators and in the process continued our expression. Finally we could simply remove the d and it
        would run perfectly fine. Notice how <code>(</code> and <code>)</code> are not suggested as alternatives despite appearing
        in the parser: <code>5(</code> or <code>5)</code> makes no sense either. As another small example, let&#39;s see what happens
        to the error if we add a space between the 5 and the d.</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">expressions</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;5 d&quot;</span><span>)
</span><span class="comment">// res1: parsley.Result[String, BigInt] = Failure((line 1, column 3):
//   unexpected &quot;d&quot;
//   expected &quot;*&quot;, &quot;+&quot;, &quot;-&quot;, &quot;/*&quot;, &quot;//&quot;, end of input, or whitespace
//   &gt;5 d
//      ^)</span></code></pre>
        <p>Neat, so this time round <code>digit</code> is no longer a valid alternative: clearly the number has come to
        an end because we wrote a space. But the other possibilities from before are still valid. So, how
        can we start making improvements? There are seven core combinators available to us for this purpose:</p>
        <ul>
          <li><code>.label</code> or <code>?</code> is the most common combinator you&#39;ll be using. It influences the way an <em>expected</em>
          behaves for the parser it annotates. Importantly, if the parser it is annotating failed <em>and</em>
          consumed input in the process, then the label will not be applied. We&#39;ll see an example of why
          this is useful later.</li>
          <li><code>fail</code> is useful, but a bit of a sledgehammer. When <code>fail</code> (or any of its derivative combinators
          like <code>guardAgainst</code>) is used, it removes the unexpected and expected information and just replaces it
          with a given message. If there are multiple <code>fail</code>s that appear in the same message, they are
          each written on a newline.</li>
          <li><code>unexpected</code> is the least commonly used combinator in practice. When it is used, it will,
          like <code>fail</code>, immediately fails except it reports a custom unexpected message. Currently, only
          one unexpected message can be present in the error at once, so this is not very useful unless you
          really know what you are doing.</li>
          <li><code>.hide</code> is a method that removes the output of a parser from the error.</li>
          <li><code>.explain</code> is a method that can provide <em>reasons</em> for a parser&#39;s failure. If the parser can recover
          and move onto other alternatives, the reasons may be lost. But they can still be quite nice when
          used in the correct place!</li>
          <li><code>amend</code> and <code>entrench</code> are a pair of combinators that work together to correct the position of
          some error messages. These are quite rare in practice.</li>
        </ul>
        <p>All of these can be found in the <code>parsley.errors.combinator</code> module.</p>
        
        <h2 id="using-label" class="section"><a class="anchor-link left" href="#using-label"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">1.1 </span>Using <code>label</code></h2>
        <p>From this section, we are only going to be using <code>label</code> and <code>hide</code>, as they are by far the most useful
        and effective of the five methods. That being said, <code>explain</code> can be <em>very</em> useful, but we&#39;ll find
        there are no compelling use-cases for it in this example. Let&#39;s start off by giving a label to
        <code>comment</code> and see what happens:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">errors</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">comment</span><span> = (</span><span class="identifier">lineComment</span><span> | </span><span class="identifier">multiComment</span><span>).</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;comment&quot;</span><span>)</span></code></pre>
        <p>Now let&#39;s run our parser from before:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">expressions</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;5d&quot;</span><span>)
</span><span class="comment">// res3: parsley.Result[String, BigInt] = Failure((line 1, column 2):
//   unexpected &quot;d&quot;
//   expected &quot;*&quot;, &quot;+&quot;, &quot;-&quot;, comment, digit, end of input, or whitespace
//   &gt;5d
//     ^)</span></code></pre>
        <p>Nice! So, if you compare the two, you&#39;ll notice that <code>&quot;/*&quot;</code> and <code>&quot;//&quot;</code> both disappeared from the
        message, but <code>comment</code> was added. You can tell when <code>label</code> is being used because there are not
        quotes surrounding the items. Knowing this, you can probably guess that <code>digit</code>, <code>eof</code>, and
        <code>whitespace</code> all have error labels of their own.</p>
        
        <h3 id="using-hide-to-trim-away-junk" class="section"><a class="anchor-link left" href="#using-hide-to-trim-away-junk"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">1.1.1 </span>Using <code>hide</code> to trim away junk</h3>
        <p>This is a good start, but normally we might say
        that whitespace suggestions in an error message are normally just noise: of course we expect to be
        able to write whitespace in places, it&#39;s not <em>usually</em> the solution to someone&#39;s problem. This makes
        it a good candidate for the <code>hide</code> combinator:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">errors</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">skipWhitespace</span><span> = </span><span class="identifier">skipMany</span><span>(</span><span class="identifier">whitespace</span><span> &lt;|&gt; </span><span class="identifier">comment</span><span>).</span><span class="identifier">hide</span></code></pre>
        <p>Now let&#39;s check again:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">expressions</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;5d&quot;</span><span>)
</span><span class="comment">// res4: parsley.Result[String, BigInt] = Failure((line 1, column 2):
//   unexpected &quot;d&quot;
//   expected &quot;*&quot;, &quot;+&quot;, &quot;-&quot;, digit, or end of input
//   &gt;5d
//     ^)</span></code></pre>
        <p>Great! The <code>hide</code> combinator has removed the information from the error message, and now it&#39;s
        looking a lot cleaner. But what if we started writing a comment, what would happen then?</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">expressions</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;5/*&quot;</span><span>)
</span><span class="comment">// res5: parsley.Result[String, BigInt] = Failure((line 1, column 4):
//   unexpected end of input
//   expected &quot;*/&quot; or any character
//   &gt;5/*
//       ^)</span></code></pre>
        <p>So, as I mentioned earlier, <code>hide</code> is just a <code>label</code>, and <code>label</code> will not relabel something if it
        fails and consumes input. That means, by opening our comment but not <em>finishing</em> it, we can see
        some different suggestions. In this case, end of input is not allowed, and any character will work
        to extend the comment, but clearly <code>*/</code> is a way to properly end it. Let&#39;s add a label to that,
        however, to make it a bit friendlier:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">lineComment</span><span> = </span><span class="string-literal">&quot;//&quot;</span><span> *&gt; </span><span class="identifier">manyUntil</span><span>(</span><span class="identifier">item</span><span>, </span><span class="identifier">endOfLine</span><span>.</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;end of comment&quot;</span><span>))
</span><span class="keyword">val</span><span> </span><span class="identifier">multiComment</span><span> = </span><span class="string-literal">&quot;/*&quot;</span><span> *&gt; </span><span class="identifier">manyUntil</span><span>(</span><span class="identifier">item</span><span>, </span><span class="string-literal">&quot;*/&quot;</span><span>.</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;end of comment&quot;</span><span>))</span></code></pre>
        <p>Now we get a more informative error message of:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">expressions</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;5/*&quot;</span><span>)
</span><span class="comment">// res6: parsley.Result[String, BigInt] = Failure((line 1, column 4):
//   unexpected end of input
//   expected any character or end of comment
//   &gt;5/*
//       ^)</span></code></pre>
        <p>Great! Now let&#39;s turn our attention back to expressions and not whitespace.</p>
        
        <h3 id="labelling-our-numbers" class="section"><a class="anchor-link left" href="#labelling-our-numbers"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">1.1.2 </span>Labelling our numbers</h3>
        <p>Let&#39;s take a look at a very simple bad input and see how we can improve on it:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">expressions</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;d&quot;</span><span>)
</span><span class="comment">// res7: parsley.Result[String, BigInt] = Failure((line 1, column 1):
//   unexpected &quot;d&quot;
//   expected &quot;(&quot; or digit
//   &gt;d
//    ^)</span></code></pre>
        <p>So this time, we can see two possible ways of resolving this error are opening brackets, or a
        <code>digit</code>. Now <code>digit</code> is really a poor name here, what we really mean is <code>integer</code> or <code>number</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">number</span><span> =
    </span><span class="identifier">token</span><span>(</span><span class="identifier">digit</span><span>.</span><span class="identifier">foldLeft1</span><span>[</span><span class="type-name">BigInt</span><span>](</span><span class="number-literal">0</span><span>)((</span><span class="identifier">n</span><span>, </span><span class="identifier">d</span><span>) =&gt; </span><span class="identifier">n</span><span> * </span><span class="number-literal">10</span><span> + </span><span class="identifier">d</span><span>.</span><span class="identifier">asDigit</span><span>)).</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;number&quot;</span><span>)</span></code></pre>
        <p>Now we get, the following, nicer error message:</p>
        <pre><code class="nohighlight"><span class="identifier">expressions</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;d&quot;</span><span>)
</span><span class="comment">// res8: parsley.Result[String, BigInt] = Failure((line 1, column 1):
//   unexpected &quot;d&quot;
//   expected &quot;(&quot; or number
//   &gt;d
//    ^)
</span><span>
</span><span class="identifier">expressions</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;5x&quot;</span><span>)
</span><span class="comment">// res9: parsley.Result[String, BigInt] = Failure((line 1, column 2):
//   unexpected &quot;x&quot;
//   expected &quot;*&quot;, &quot;+&quot;, &quot;-&quot;, digit, or end of input
//   &gt;5x
//     ^)</span></code></pre>
        <p>But notice in the second error message, again we have been given <code>digit</code> and not <code>number</code> as our
        alternative. This is good, once we&#39;ve started reading a number by reading <code>5</code> it would be
        inappropriate to suggest a number as a good next step. But <code>digit</code> here is not particularly descriptive
        and we can do better still:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">number</span><span> =
    </span><span class="identifier">token</span><span>(
        </span><span class="identifier">digit</span><span>.</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;end of number&quot;</span><span>).</span><span class="identifier">foldLeft1</span><span>[</span><span class="type-name">BigInt</span><span>](</span><span class="number-literal">0</span><span>)((</span><span class="identifier">n</span><span>, </span><span class="identifier">d</span><span>) =&gt; </span><span class="identifier">n</span><span> * </span><span class="number-literal">10</span><span> + </span><span class="identifier">d</span><span>.</span><span class="identifier">asDigit</span><span>)
    ).</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;number&quot;</span><span>)</span></code></pre>
        <p>This gives us, again, a much nicer message:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">expressions</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;5x&quot;</span><span>)
</span><span class="comment">// res10: parsley.Result[String, BigInt] = Failure((line 1, column 2):
//   unexpected &quot;x&quot;
//   expected &quot;*&quot;, &quot;+&quot;, &quot;-&quot;, end of input, or end of number
//   &gt;5x
//     ^)</span></code></pre>
        
        <h3 id="merging-multiple-labels" class="section"><a class="anchor-link left" href="#merging-multiple-labels"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">1.1.3 </span>Merging multiple labels</h3>
        <p>With an example grammar as small as this, I think we are almost done here! The last thing we could
        improve is the repetition of <code>&quot;*&quot;</code>, <code>&quot;+&quot;</code>, and <code>&quot;-&quot;</code>. Really, we know that there is nothing special
        about any of them individually, so we could more concisely replace this them with <code>arithmetic operator</code>,
        or since we only have arithmetic operators here <code>operator</code> will do. we don&#39;t need to do anything
        special here, when multiple labels are encountered with the same name, they will only appear once!</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span> = </span><span class="identifier">precedence</span><span>[</span><span class="type-name">BigInt</span><span>](</span><span class="identifier">atom</span><span>)(
  </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="string-literal">&quot;*&quot;</span><span>.</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;operator&quot;</span><span>) </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> * </span><span class="identifier">_</span><span>)),
  </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="string-literal">&quot;+&quot;</span><span>.</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;operator&quot;</span><span>) </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> + </span><span class="identifier">_</span><span>), </span><span class="string-literal">&quot;-&quot;</span><span>.</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;operator&quot;</span><span>) </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> - </span><span class="identifier">_</span><span>)))</span></code></pre>
        <p>Now we arrive at our final form:</p>
        <pre><code class="nohighlight"><span class="identifier">expressions</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;5x&quot;</span><span>)
</span><span class="comment">// res11: parsley.Result[String, BigInt] = Failure((line 1, column 2):
//   unexpected &quot;x&quot;
//   expected end of input, end of number, or operator
//   &gt;5x
//     ^)
</span><span>
</span><span class="identifier">expressions</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot; 67 + &quot;</span><span>)
</span><span class="comment">// res12: parsley.Result[String, BigInt] = Failure((line 1, column 7):
//   unexpected end of input
//   expected &quot;(&quot; or number
//   &gt; 67 + 
//          ^)</span></code></pre>
        <p>Great! Now obviously you could take this even further and make <code>&quot;(&quot;</code> become <code>opening parenthesis</code>
        or something, but I don&#39;t really feel that adds much.</p>
        
        <h2 id="wrapping-up-the-expression-example" class="section"><a class="anchor-link left" href="#wrapping-up-the-expression-example"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">1.2 </span>Wrapping up the Expression Example</h2>
        <p>Hopefully, you get a sense of how much of an
        art form and subjective writing good error messages is, but Parsley provides decent error messages
        out of the box (now based on <code>megaparsec</code>&#39;s error messages from Haskell). It doesn&#39;t have to be hard
        though, so just play around and see what feels right. I would say, however, there is an interesting
        phenomenon in the programming languages and compilers community:
        <strong>compiler writers write error messages that are tailored for compiler writers</strong>. It&#39;s an
        interesting problem when you think about it: the person who writes error messages is a compiler
        expert, and so they often rely on the concepts they understand. That means they are more prone to
        including the names of stuff in the grammar to describe syntax problems, and so on. While this is
        great for experts and compiler writers, it seemingly forgets people who are new to programming or
        this &quot;grammar&quot; in particular. That can make error messages needlessly intimidating for the average
        Joe. The take home from this is to try and avoid labelling <code>expr</code> with <code>.label(&quot;expression&quot;)</code>,
        because that just ends up making something that is no longer useful or informative:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">expressions</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;&quot;</span><span>)
</span><span class="comment">// res13: parsley.Result[String, BigInt] = Failure((line 1, column 1):
//   unexpected end of input
//   expected expression
//   &gt;
//    ^)</span></code></pre>
        <p>What use is that to anybody? The same idea applies to statements, and various other abstract
        grammatical notions. Something like
        <code>&quot;expected if statement, while loop, for loop, variable declaration, or assignment&quot;</code> is so much more
        meaningful than <code>&quot;expected statement&quot;</code>. I would ask that you keep that in mind ðŸ™‚. To conclude our
        work with this parser, here is the full code of the finished product. Obviously, with the
        <code>Lexer</code>, some of this work is already done, but you can still apply the lessons learnt here to the
        wider parser!</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>, </span><span class="type-name">Parsley</span><span>.</span><span class="identifier">atomic</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">errors</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">object</span><span> </span><span class="identifier">lexer</span><span> {
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.{</span><span class="identifier">digit</span><span>, </span><span class="identifier">whitespace</span><span>, </span><span class="identifier">string</span><span>, </span><span class="identifier">item</span><span>, </span><span class="identifier">endOfLine</span><span>}
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">combinator</span><span>.{</span><span class="identifier">manyUntil</span><span>, </span><span class="identifier">skipMany</span><span>, </span><span class="identifier">eof</span><span>}

    </span><span class="keyword">private</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">symbol</span><span>(</span><span class="identifier">str</span><span>: </span><span class="type-name">String</span><span>) = </span><span class="identifier">atomic</span><span>(</span><span class="identifier">string</span><span>(</span><span class="identifier">str</span><span>)).</span><span class="identifier">void</span><span>
    </span><span class="keyword">private</span><span> </span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">implicitSymbol</span><span>(</span><span class="identifier">tok</span><span>: </span><span class="type-name">String</span><span>) = </span><span class="identifier">symbol</span><span>(</span><span class="identifier">tok</span><span>)

    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">lineComment</span><span> = </span><span class="string-literal">&quot;//&quot;</span><span> ~&gt; </span><span class="identifier">manyUntil</span><span>(</span><span class="identifier">item</span><span>, </span><span class="identifier">endOfLine</span><span>).</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;end of comment&quot;</span><span>)
    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">multiComment</span><span> = </span><span class="string-literal">&quot;/*&quot;</span><span> ~&gt; </span><span class="identifier">manyUntil</span><span>(</span><span class="identifier">item</span><span>, </span><span class="string-literal">&quot;*/&quot;</span><span>).</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;end of comment&quot;</span><span>)
    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">comment</span><span> = (</span><span class="identifier">lineComment</span><span> | </span><span class="identifier">multiComment</span><span>).</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;comment&quot;</span><span>)
    </span><span class="keyword">private</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">skipWhitespace</span><span> = </span><span class="identifier">skipMany</span><span>(</span><span class="identifier">whitespace</span><span> | </span><span class="identifier">comment</span><span>).</span><span class="identifier">hide</span><span>

    </span><span class="keyword">private</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">lexeme</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">p</span><span>: =&gt;</span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]) = </span><span class="identifier">p</span><span> &lt;~ </span><span class="identifier">skipWhitespace</span><span>
    </span><span class="keyword">private</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">token</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">p</span><span>: =&gt;</span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]) = </span><span class="identifier">lexeme</span><span>(</span><span class="identifier">atomic</span><span>(</span><span class="identifier">p</span><span>))
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">fully</span><span>[</span><span class="type-name">A</span><span>](</span><span class="identifier">p</span><span>: =&gt;</span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>]): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">A</span><span>] = </span><span class="identifier">skipWhitespace</span><span> ~&gt; </span><span class="identifier">p</span><span> &lt;~ </span><span class="identifier">eof</span><span>

    </span><span class="keyword">val</span><span> </span><span class="identifier">number</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">BigInt</span><span>] = </span><span class="identifier">token</span><span> {
        </span><span class="identifier">digit</span><span>.</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;end of number&quot;</span><span>).</span><span class="identifier">foldLeft1</span><span>[</span><span class="type-name">BigInt</span><span>](</span><span class="number-literal">0</span><span>)((</span><span class="identifier">n</span><span>, </span><span class="identifier">d</span><span>) =&gt; </span><span class="identifier">n</span><span> * </span><span class="number-literal">10</span><span> + </span><span class="identifier">d</span><span>.</span><span class="identifier">asDigit</span><span>)
    }.</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;number&quot;</span><span>)

    </span><span class="keyword">object</span><span> </span><span class="identifier">implicits</span><span> {
        </span><span class="keyword">implicit</span><span> </span><span class="keyword">def</span><span> </span><span class="declaration-name">implicitSymbol</span><span>(</span><span class="identifier">s</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">Unit</span><span>] = </span><span class="identifier">lexeme</span><span>(</span><span class="identifier">symbol</span><span>(</span><span class="identifier">s</span><span>))
    }
}

</span><span class="keyword">object</span><span> </span><span class="identifier">expressions</span><span> {
    </span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">expr</span><span>.{</span><span class="identifier">precedence</span><span>, </span><span class="type-name">Ops</span><span>, </span><span class="type-name">InfixL</span><span>}

    </span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">implicitSymbol</span><span>
    </span><span class="keyword">import</span><span> </span><span class="identifier">lexer</span><span>.{</span><span class="identifier">number</span><span>, </span><span class="identifier">fully</span><span>}

    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">atom</span><span>: </span><span class="type-name">Parsley</span><span>[</span><span class="type-name">BigInt</span><span>] = </span><span class="string-literal">&quot;(&quot;</span><span> ~&gt; </span><span class="identifier">expr</span><span> &lt;~ </span><span class="string-literal">&quot;)&quot;</span><span> | </span><span class="identifier">number</span><span>
    </span><span class="keyword">private</span><span> </span><span class="keyword">lazy</span><span> </span><span class="keyword">val</span><span> </span><span class="identifier">expr</span><span> = </span><span class="identifier">precedence</span><span>[</span><span class="type-name">BigInt</span><span>](</span><span class="identifier">atom</span><span>)(
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="string-literal">&quot;*&quot;</span><span>.</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;operator&quot;</span><span>) </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> * </span><span class="identifier">_</span><span>)),
        </span><span class="type-name">Ops</span><span>(</span><span class="type-name">InfixL</span><span>)(</span><span class="string-literal">&quot;+&quot;</span><span>.</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;operator&quot;</span><span>) </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> + </span><span class="identifier">_</span><span>), </span><span class="string-literal">&quot;-&quot;</span><span>.</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;operator&quot;</span><span>) </span><span class="identifier">as</span><span> (</span><span class="identifier">_</span><span> - </span><span class="identifier">_</span><span>)))

    </span><span class="keyword">val</span><span> </span><span class="identifier">parser</span><span> = </span><span class="identifier">fully</span><span>(</span><span class="identifier">expr</span><span>)
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">parse</span><span>(</span><span class="identifier">input</span><span>: </span><span class="type-name">String</span><span>) = </span><span class="identifier">parser</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="identifier">input</span><span>)
}</span></code></pre>
        
        <h2 id="using-explain" class="section"><a class="anchor-link left" href="#using-explain"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">1.3 </span>Using <code>explain</code></h2>
        <p>So far, we&#39;ve seen how <code>label</code> can be used to clean up error messages and make them much more
        presentable and informative. Another way of achieving this is by using the <code>explain</code> combinator.
        Unlike <code>label</code> this is much more freeform and when used properly can be <em>incredibly</em> effective.
        Essentially, with <code>explain</code> you are leveraging your own knowledge about the context you are in
        to provide a much more tailored and hand-crafted message to the user. It can be used to both provide
        an additional hint in an otherwise poor message or to enrich the error with suggestions for how the
        error might be fixed.</p>
        <p>Using it is just as easy as using <code>label</code> and you can&#39;t really go wrong with it: other than being a
        bit... too descriptive. Again, the <code>Lexer</code> class already makes use of this technique to improve its
        own error messages, but let&#39;s suppose we wanted to write some of its functionality ourselves. Let&#39;s
        cook up a string literal parser, supporting some (limited) escape sequences.</p>
        <pre><code class="nohighlight"><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="type-name">Parsley</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">implicits</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">charLift</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">combinator</span><span>.{</span><span class="identifier">between</span><span>, </span><span class="identifier">choice</span><span>}
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">character</span><span>.</span><span class="identifier">_</span><span>
</span><span class="keyword">import</span><span> </span><span class="identifier">parsley</span><span>.</span><span class="identifier">errors</span><span>.</span><span class="identifier">combinator</span><span>.</span><span class="identifier">_</span><span>

</span><span class="keyword">val</span><span> </span><span class="identifier">escapeChar</span><span> =
    </span><span class="identifier">choice</span><span>(</span><span class="char-literal">&#39;n&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="char-literal">&#39;</span><span class="escape-sequence">\n</span><span class="char-literal">&#39;</span><span>, </span><span class="char-literal">&#39;t&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="char-literal">&#39;</span><span class="escape-sequence">\t</span><span class="char-literal">&#39;</span><span>, </span><span class="char-literal">&#39;</span><span class="escape-sequence">\&quot;</span><span class="char-literal">&#39;</span><span>, </span><span class="char-literal">&#39;</span><span class="escape-sequence">\\</span><span class="char-literal">&#39;</span><span>)
</span><span class="keyword">val</span><span> </span><span class="identifier">stringLetter</span><span> =
    </span><span class="identifier">noneOf</span><span>(</span><span class="char-literal">&#39;</span><span class="escape-sequence">\&quot;</span><span class="char-literal">&#39;</span><span>, </span><span class="char-literal">&#39;</span><span class="escape-sequence">\\</span><span class="char-literal">&#39;</span><span>).</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;string character&quot;</span><span>) |
    (</span><span class="char-literal">&#39;</span><span class="escape-sequence">\\</span><span class="char-literal">&#39;</span><span> ~&gt; </span><span class="identifier">escapeChar</span><span>).</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;escape character&quot;</span><span>)

</span><span class="keyword">val</span><span> </span><span class="identifier">stringLiteral</span><span> =
    </span><span class="identifier">between</span><span>(</span><span class="char-literal">&#39;</span><span class="escape-sequence">\&quot;</span><span class="char-literal">&#39;</span><span>,
            </span><span class="char-literal">&#39;</span><span class="escape-sequence">\&quot;</span><span class="char-literal">&#39;</span><span>.</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;end of string&quot;</span><span>),
            </span><span class="identifier">stringOfMany</span><span>(</span><span class="identifier">stringLetter</span><span>))
        .</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;string&quot;</span><span>)</span></code></pre>
        <p>Let&#39;s start with something like this. If we run a couple of examples, we can see where it performs
        well and where it performs less well:</p>
        <pre><code class="nohighlight"><span class="identifier">stringLiteral</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;&quot;</span><span>)
</span><span class="comment">// res16: parsley.Result[String, String] = Failure((line 1, column 1):
//   unexpected end of input
//   expected string
//   &gt;
//    ^)
</span><span>
</span><span class="identifier">stringLiteral</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;</span><span class="escape-sequence">\&quot;</span><span class="string-literal">&quot;</span><span>)
</span><span class="comment">// res17: parsley.Result[String, String] = Failure((line 1, column 2):
//   unexpected end of input
//   expected end of string, escape character, or string character
//   &gt;&quot;
//     ^)
</span><span>
</span><span class="identifier">stringLiteral</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;</span><span class="escape-sequence">\&quot;\\</span><span class="string-literal">a&quot;</span><span>)
</span><span class="comment">// res18: parsley.Result[String, String] = Failure((line 1, column 3):
//   unexpected &quot;a&quot;
//   expected &quot;&quot;&quot;, &quot;\&quot;, &quot;n&quot;, or &quot;t&quot;
//   &gt;&quot;\a
//      ^)</span></code></pre>
        <p>So, for the first two cases, the error message performs quite well. But the last message is a bit
        noisy. One possible approach to improve this could be to label each alternative to give them a
        slightly clearer name, which would result in something like:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">stringLiteral</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;</span><span class="escape-sequence">\&quot;\\</span><span class="string-literal">a&quot;</span><span>)
</span><span class="comment">// res19: parsley.Result[String, String] = Failure((line 1, column 3):
//   unexpected &quot;a&quot;
//   expected \&quot;, \\, \n, or \t
//   &gt;&quot;\a
//      ^)</span></code></pre>
        <p>This is <em>better</em>, but a bit misleading, we don&#39;t expect a <code>\</code>! Now, you could instead opt to remove
        the backslashes, but then that doesn&#39;t give much information about why these things are expected.
        Another option would be to label all alternatives with some common name:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">escapeChar</span><span> =
    </span><span class="identifier">choice</span><span>(</span><span class="char-literal">&#39;n&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="char-literal">&#39;</span><span class="escape-sequence">\n</span><span class="char-literal">&#39;</span><span>, </span><span class="char-literal">&#39;t&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="char-literal">&#39;</span><span class="escape-sequence">\t</span><span class="char-literal">&#39;</span><span>, </span><span class="char-literal">&#39;</span><span class="escape-sequence">\&quot;</span><span class="char-literal">&#39;</span><span>, </span><span class="char-literal">&#39;</span><span class="escape-sequence">\\</span><span class="char-literal">&#39;</span><span>)
        .</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;end of escape sequence&quot;</span><span>)</span></code></pre>
        <p>Which would yield</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">stringLiteral</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;</span><span class="escape-sequence">\&quot;\\</span><span class="string-literal">a&quot;</span><span>)
</span><span class="comment">// res20: parsley.Result[String, String] = Failure((line 1, column 3):
//   unexpected &quot;a&quot;
//   expected end of escape sequence
//   &gt;&quot;\a
//      ^)</span></code></pre>
        <p>This is a bit more helpful, in that it does provide a good name to what we expected. But at the same
        time it doesn&#39;t help the user to understand how to fix their problem: &quot;what is an escape sequence&quot;.
        This is similar to the &quot;statement&quot; problem I described above. In this case, (and indeed in the
        &quot;statement&quot; case), we can add an <code>explain</code> to help the user understand what we mean:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">val</span><span> </span><span class="identifier">escapeChar</span><span> =
    </span><span class="identifier">choice</span><span>(</span><span class="char-literal">&#39;n&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="char-literal">&#39;</span><span class="escape-sequence">\n</span><span class="char-literal">&#39;</span><span>, </span><span class="char-literal">&#39;t&#39;</span><span> </span><span class="identifier">as</span><span> </span><span class="char-literal">&#39;</span><span class="escape-sequence">\t</span><span class="char-literal">&#39;</span><span>, </span><span class="char-literal">&#39;</span><span class="escape-sequence">\&quot;</span><span class="char-literal">&#39;</span><span>, </span><span class="char-literal">&#39;</span><span class="escape-sequence">\\</span><span class="char-literal">&#39;</span><span>)
        .</span><span class="identifier">label</span><span>(</span><span class="string-literal">&quot;end of escape sequence&quot;</span><span>)
        .</span><span class="identifier">explain</span><span>(</span><span class="string-literal">&quot;valid escape sequences include </span><span class="escape-sequence">\\</span><span class="string-literal">n, </span><span class="escape-sequence">\\</span><span class="string-literal">t, </span><span class="escape-sequence">\\\&quot;</span><span class="string-literal">, or </span><span class="escape-sequence">\\\\</span><span class="string-literal">&quot;</span><span>)</span></code></pre>
        <p>The <code>explain</code> combinator annotates failure messages with an additional reason. These can stack, and
        are displayed each on their own line in the error message. With this in place, let&#39;s see what the
        new error message is:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="identifier">stringLiteral</span><span>.</span><span class="identifier">parse</span><span>(</span><span class="string-literal">&quot;</span><span class="escape-sequence">\&quot;\\</span><span class="string-literal">a&quot;</span><span>)
</span><span class="comment">// res21: parsley.Result[String, String] = Failure((line 1, column 3):
//   unexpected &quot;a&quot;
//   expected end of escape sequence
//   valid escape sequences include \n, \t, \&quot;, or \\
//   &gt;&quot;\a
//      ^)</span></code></pre>
        <p>This time, we keep the name of the expected token clear and concise, but we <em>also</em> help the user to
        understand what this actually means. The error isn&#39;t misleading in the sense that we aren&#39;t
        suggesting that a <code>\n</code> would fix the parse error <em>after</em> the <code>\</code> we already wrote, but have have
        said that we expect the end of the escape as well as demonstrated what that would look like. This
        is great!</p>
        <p>There isn&#39;t much more to say about the <code>explain</code> combinator than that really. Hopefully this already
        gives you a sense of how useful it can be. Like I mentioned before, the poor error problem that
        compiler writers often suffer from can be nicely solved using <code>explain</code>. For instance, a message like
        &quot;... expected statement ... valid statements include &#39;if statements&#39;, &#39;loops&#39;, or &#39;assignments&#39;&quot; is
        subjectively better than both of the alternatives (namely &quot;expected statement&quot; or the one that lists
        out every single alternative). This has the benefits of both worlds: for an experienced user, the error
        message gets straight to the point, and for the newcomer, the error message provides a bit more
        information that can help them learn the terminology.</p>
        
        <h1 id="adjusting-error-formatting" class="section"><a class="anchor-link left" href="#adjusting-error-formatting"><i class="icofont-laika link">&#xef71;</i></a><span class="section-number">2 </span>Adjusting Error Formatting</h1>
        <p>As we&#39;ve seen in this post, the error messages produced by parsley are fairly readable. They are
        broken into two kinds: &quot;vanilla&quot; errors built up of &quot;expected&quot;, &quot;unexpected&quot;, and &quot;reason&quot; clauses;
        and &quot;specialised&quot; errors built up solely of &quot;message&quot; clauses. So far, we have only seen examples of
        the &quot;vanilla&quot; errors, and we will see the &quot;specialised&quot; errors in the next post. These have been
        so far formatted using Parsley&#39;s default mechanism, which creates an error as a string. This is ok
        for basic use, but in projects where there is some pre-existing error format, then maintaining consistency
        across error messages is much harder without <em>parsing</em> the resulting <code>String</code> errors to extract
        their content: this is, frankly, ridiculous to expect! Moreover, suppose you wanted to unit test
        your parser in both successful and failing cases, then performing raw string comparision is really
        brittle, especially if Parsley adjusts the format slightly!</p>
        <p>Luckily, Parsley 3.0.0 introduced an abstraction layer between the error messages that the parsers
        work with and the final resulting error message. This means that actually, the error message format
        is not only configurable, but doesn&#39;t <em>have</em> to be a <code>String</code>! The final part of this post is dedicated
        to understanding how to work with this mechanism, using Parsley&#39;s own unit test formatter as an example.</p>
        <p>Firstly, I want to give examples of both types of format, and annotate the names given to each part
        of them:</p>
        <pre><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Vanilla Error                                                       â”‚
â”‚                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â—„â”€â”€â”€â”€â”€â”€â”€â”€ position         â”‚
â”‚                  source  â”‚                â”‚                           â”‚
â”‚                     â”‚    â”‚   line      colâ”‚                           â”‚
â”‚                     â–¼    â”‚     â”‚         â”‚â”‚                           â”‚
â”‚                  â”Œâ”€â”€â”€â”€â”€â” â”‚     â–¼         â–¼â”‚   end of input            â”‚
â”‚               In foo.txt (line 1, column 5):       â”‚                  â”‚
â”‚                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”            â”‚                  â”‚
â”‚unexpected â”€â”€â”€â”€â”€â–ºâ”‚                     â”‚            â”‚  â”Œâ”€â”€â”€â”€â”€ expected â”‚
â”‚                 â”‚          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â—„â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚               â”‚
â”‚                 unexpected end of input               â–¼               â”‚
â”‚                 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”              â”‚
â”‚                 expected &quot;(&quot;, &quot;negate&quot;, digit, or letter              â”‚
â”‚                          â”‚    â””â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”˜     â””â”€â”€â”€â”€â”˜ â—„â”€â”€â”€â”€â”€â”€ namedâ”‚
â”‚                          â”‚       â–²        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚              â”‚
â”‚                          â”‚       â”‚                     â”‚              â”‚
â”‚                          â”‚      raw                    â”‚              â”‚
â”‚                          â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜              â”‚
â”‚                 &#39;-&#39; is a binary operator   â”‚                          â”‚
â”‚                 â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚                          â”‚
â”‚                â”Œâ”€â”€â”€â”€â”€â”€â”        â–²           â”‚                          â”‚
â”‚                â”‚&gt;3+4- â”‚        â”‚           expected items             â”‚
â”‚                â”‚     ^â”‚        â”‚                                      â”‚
â”‚                â””â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ reason              â”‚
â”‚                   â–²                                                   â”‚
â”‚                   â”‚                                                   â”‚
â”‚                   line info                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Specialised Error                                                   â”‚
â”‚                          â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â—„â”€â”€â”€â”€â”€â”€â”€â”€ position         â”‚
â”‚                  source  â”‚                â”‚                           â”‚
â”‚                     â”‚    â”‚   line       col                           â”‚
â”‚                     â–¼    â”‚     â”‚         â”‚                            â”‚
â”‚                  â”Œâ”€â”€â”€â”€â”€â” â”‚     â–¼         â–¼                            â”‚
â”‚               In foo.txt (line 1, column 5):                          â”‚
â”‚                                                                       â”‚
â”‚           â”Œâ”€â”€â”€â–º something went wrong                                  â”‚
â”‚           â”‚                                                           â”‚
â”‚ message â”€â”€â”¼â”€â”€â”€â–º it looks like a binary operator has no argument       â”‚
â”‚           â”‚                                                           â”‚
â”‚           â””â”€â”€â”€â–º &#39;-&#39; is a binary operator                              â”‚
â”‚                â”Œâ”€â”€â”€â”€â”€â”€â”                                               â”‚
â”‚                â”‚&gt;3+4- â”‚                                               â”‚
â”‚                â”‚     ^â”‚                                               â”‚
â”‚                â””â”€â”€â”€â”€â”€â”€â”˜                                               â”‚
â”‚                   â–²                                                   â”‚
â”‚                   â”‚                                                   â”‚
â”‚                   line info                                           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜</code></pre>
        <p>As you can see, the content for a specialised error is (ironically) plainer than a vanilla message.
        This means that the errors are much more customisable from the parser side, but it is less rich
        in parser generated information than the vanilla is. Hopefully you can see that both error messages
        still have a <em>very</em> similar shape other than the error info lines themselves. In both cases, and not
        shown by the diagrams, the main contents of the error -- either unexpected, expected, reasons, and
        line info; or messages and line info -- are called &quot;error info lines&quot;.</p>
        <p>For vanilla errors, notice that the unexpected and expected lines make references to raw, named, and
        end of input: these are collectively known as <em>items</em>. The <code>.label</code> combinator produces named items,
        the <code>eof</code> combinator produces the end of input item, and unlabelled combinators produce raw items.</p>
        <p>Together, all these components are referenced (by these names!) by the <code>ErrorBuilder</code> trait. The way
        it works is that a concrete <code>ErrorBuilder</code> has to be provided to the <code>.parse</code> method of a parser,
        and when the parser has finished failing, the builder is used to construct the final error message,
        converting the internal representation that Parsley uses into the desired output specified by the
        builder: you can think of it like a conversation. The internals of Parsley take a portion of the
        information it has, and talks to the builder how to format it into another intermediate form; it then
        will feed this new information into another method of the builder after possibly more collection.
        To allow all of this plumbing to be fed together and maintain maximum flexiblity to the user, the
        builder makes use of &quot;associated types&quot;. Let&#39;s take a look at the definition of <code>ErrorBuilder</code> without
        all the sub-formatters to understand what I mean:</p>
        <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">ErrorBuilder</span><span>[</span><span class="type-name">Err</span><span>] {
    </span><span class="comment">// This is the top level function which takes all the sub-parts
</span><span>    </span><span class="comment">// and combines them into the final `Err`
</span><span>    </span><span class="keyword">def</span><span> </span><span class="declaration-name">format</span><span>(</span><span class="identifier">pos</span><span>: </span><span class="type-name">Position</span><span>, </span><span class="identifier">source</span><span>: </span><span class="type-name">Source</span><span>, </span><span class="identifier">lines</span><span>: </span><span class="type-name">ErrorInfoLines</span><span>): </span><span class="type-name">Err</span><span>

    </span><span class="keyword">type</span><span> </span><span class="type-name">Position</span><span>
    </span><span class="keyword">type</span><span> </span><span class="type-name">Source</span><span>
    </span><span class="keyword">type</span><span> </span><span class="type-name">ErrorInfoLines</span><span>
    </span><span class="keyword">type</span><span> </span><span class="type-name">ExpectedItems</span><span>
    </span><span class="keyword">type</span><span> </span><span class="type-name">Messages</span><span>
    </span><span class="keyword">type</span><span> </span><span class="type-name">UnexpectedLine</span><span>
    </span><span class="keyword">type</span><span> </span><span class="type-name">ExpectedLine</span><span>
    </span><span class="keyword">type</span><span> </span><span class="type-name">Message</span><span>
    </span><span class="keyword">type</span><span> </span><span class="type-name">LineInfo</span><span>
    </span><span class="keyword">type</span><span> </span><span class="type-name">Item</span><span>
    </span><span class="keyword">type</span><span> </span><span class="type-name">Raw</span><span> &lt;: </span><span class="type-name">Item</span><span>
    </span><span class="keyword">type</span><span> </span><span class="type-name">Named</span><span> &lt;: </span><span class="type-name">Item</span><span>
    </span><span class="keyword">type</span><span> </span><span class="type-name">EndOfInput</span><span> &lt;: </span><span class="type-name">Item</span><span>

    ...
}</span></code></pre>
        <p>Wow, that&#39;s a lot of types! Essentially, each concrete implementation of this trait must specify
        what each of those types are. This means that the representation of the error is as flexible as
        possible. In the <code>format</code> method, you can see that the types <code>Position</code>, <code>Source</code>, and
        <code>ErrorInfoLines</code> are all referenced. Indeed, you can also see these marked on <em>both</em> diagrams: in
        other words, <code>format</code> is responsible for the general shape of <em>both</em> types of error message.</p>
        <p>To understand how these might come about, let&#39;s take a step &quot;into&quot; the formatter to find the sources
        of values for <code>Position</code>, <code>Source</code>, and <code>ErrorInfoLines</code>:</p>
        <pre class="keep-together pdf epub"><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">ErrorBuilder</span><span>[</span><span class="type-name">Err</span><span>] {
    ...

    </span><span class="keyword">def</span><span> </span><span class="declaration-name">pos</span><span>(</span><span class="identifier">line</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">col</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">Position</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">source</span><span>(</span><span class="identifier">sourceName</span><span>: </span><span class="type-name">Option</span><span>[</span><span class="type-name">String</span><span>]): </span><span class="type-name">Source</span><span>

    </span><span class="keyword">def</span><span> </span><span class="declaration-name">vanillaError</span><span>(</span><span class="identifier">unexpected</span><span>: </span><span class="type-name">UnexpectedLine</span><span>, </span><span class="identifier">expected</span><span>: </span><span class="type-name">ExpectedLine</span><span>,
                     </span><span class="identifier">reasons</span><span>: </span><span class="type-name">Messages</span><span>, </span><span class="identifier">line</span><span>: </span><span class="type-name">LineInfo</span><span>): </span><span class="type-name">ErrorInfoLines</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">specialisedError</span><span>(</span><span class="identifier">msgs</span><span>: </span><span class="type-name">Messages</span><span>, </span><span class="identifier">line</span><span>: </span><span class="type-name">LineInfo</span><span>): </span><span class="type-name">ErrorInfoLines</span><span>

    ...
}</span></code></pre>
        <p>Hopefully, you can start to see how this might be structured:</p>
        <ul>
          <li>To get a <code>Position</code> value for the final error message, the line and column information is fed
          <em>straight</em> from the parser into the <code>pos</code> method, which can then hand back the &quot;formatted&quot; position.</li>
          <li>To get the <code>Source</code> name, the filename (if it exists!) is fed into the <code>source</code> method, which can
          then be fed into <code>format</code> by the internals of Parsley.</li>
          <li>To collect up all the <code>ErrorInfoLines</code> there are two possible approaches depending on whether the
          error is vanilla or specialised. In both cases, the relevant information is passed in and can be
          &quot;formatted&quot; into whatever <code>ErrorInfoLines</code> is: for instance, the default in Parsley has
          <code>type ErrorInfoLines = Seq[String]</code>. Neither of these two methods take raw information from the
          parser, they have clearly been fed through another part of the formatter, given their types.</li>
        </ul>
        <p>I won&#39;t continue traversing deeper and deeper into the system, because it&#39;s just going to be the
        same idea over and over again. But I will note all the &quot;terminal&quot; methods that do take information
        directly from the parser:</p>
        <pre><code class="nohighlight"><span class="keyword">trait</span><span> </span><span class="type-name">ErrorBuilder</span><span>[</span><span class="type-name">Err</span><span>] {
    ...

    </span><span class="keyword">def</span><span> </span><span class="declaration-name">pos</span><span>(</span><span class="identifier">line</span><span>: </span><span class="type-name">Int</span><span>, </span><span class="identifier">col</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">Position</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">source</span><span>(</span><span class="identifier">sourceName</span><span>: </span><span class="type-name">Option</span><span>[</span><span class="type-name">String</span><span>]): </span><span class="type-name">Source</span><span>

    </span><span class="keyword">def</span><span> </span><span class="declaration-name">reason</span><span>(</span><span class="identifier">reason</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Message</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">message</span><span>(</span><span class="identifier">msg</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Message</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">lineInfo</span><span>(</span><span class="identifier">line</span><span>: </span><span class="type-name">String</span><span>, </span><span class="identifier">linesBefore</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">String</span><span>],
                 </span><span class="identifier">linesAfter</span><span>: </span><span class="type-name">Seq</span><span>[</span><span class="type-name">String</span><span>], </span><span class="identifier">errorPointsAt</span><span>: </span><span class="type-name">Int</span><span>): </span><span class="type-name">LineInfo</span><span>
    </span><span class="keyword">val</span><span> </span><span class="identifier">numLinesBefore</span><span>: </span><span class="type-name">Int</span><span>
    </span><span class="keyword">val</span><span> </span><span class="identifier">numLinesAfter</span><span>: </span><span class="type-name">Int</span><span>

    </span><span class="keyword">def</span><span> </span><span class="declaration-name">raw</span><span>(</span><span class="identifier">item</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Raw</span><span>
    </span><span class="keyword">def</span><span> </span><span class="declaration-name">named</span><span>(</span><span class="identifier">item</span><span>: </span><span class="type-name">String</span><span>): </span><span class="type-name">Named</span><span>
    </span><span class="keyword">val</span><span> </span><span class="identifier">endOfInput</span><span>: </span><span class="type-name">EndOfInput</span><span>

    </span><span class="keyword">def</span><span> </span><span class="declaration-name">unexpectedToken</span><span>(</span><span class="identifier">cs</span><span>: </span><span class="type-name">Iterable</span><span>[</span><span class="type-name">Char</span><span>], </span><span class="identifier">amountOfInputParserWanted</span><span>: </span><span class="type-name">Int</span><span>,
                        </span><span class="identifier">lexicalError</span><span>: </span><span class="type-name">Boolean</span><span>): </span><span class="type-name">Token</span><span>
}</span></code></pre>
        <p>The two attributes <code>numLinesBefore</code> and <code>numLinesAfter</code> are used by the Parsley internals to decide
        how many raw lines of input both before and after the problematic line to provide to <code>lineInfo</code>. In
        a pinch, overriding these values from <code>DefaultErrorBuilder</code> is a quick way of changing how specific
        your errors are to other lines in the input. The <code>unexpectedToken</code> method is
        special, but I&#39;ll leave a discussion of this <a href="../api-guide/errors/tokenextractors.html">another page</a>. All of the other methods in the <code>ErrorBuilder</code> will make
        use of the refined results from the methods above.</p>
        <p>I hope that, by this point, you have a reasonable idea of how this system all ties together. But, if
        you don&#39;t, or you want an example, take a look at how <code>parsley</code>&#39;s own unit tests format error
        messages to be easier to pattern match on and test against, the implementation can be found <a href="../api-guide/errors/ErrorBuilder.html#constructing-test-errors">here</a>.</p>

        
<hr class="footer-rule"/>
<footer>
  Parsley is distributed under the <a href="https://opensource.org/licenses/BSD-3-Clause">BSD-3-Clause</a> license.
</footer>


      </main>

    </div>

  </body>

</html>